// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pb/moby/container/container.proto

/*
	Package container is a generated protocol buffer package.

	It is generated from these files:
		pb/moby/container/container.proto

	It has these top-level messages:
		HealthConfig
		Config
		ContainerCreateCreatedBody
		DeviceMapping
		RestartPolicy
		LogConfig
		Resources
		HostConfig
*/
package container

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import blkiodev "github.com/tangfeixiong/go-to-docker/pb/moby/blkiodev"
import units "github.com/tangfeixiong/go-to-docker/pb/moby/units"
import nat "github.com/tangfeixiong/go-to-docker/pb/moby/nat"
import mount "github.com/tangfeixiong/go-to-docker/pb/moby/mount"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// HealthConfig holds configuration settings for the HEALTHCHECK feature.
// type HealthConfig struct
type HealthConfig struct {
	// Test []string 0x60json:",omitempty"0x60
	// Test is the test to perform to check that the container is healthy.
	// An empty slice means to inherit the default.
	// The options are:
	// {} : inherit healthcheck
	// {"NONE"} : disable healthcheck
	// {"CMD", args...} : exec arguments directly
	// {"CMD-SHELL", command} : run command with system's default shell
	Test []string `protobuf:"bytes,1,rep,name=test" json:"test,omitempty"`
	// Zero means to inherit. Durations are expressed as integer nanoseconds.
	// Interval time.Duration 0x60json:",omitempty"0x60 // Interval is the time to wait between checks.
	IntervalSeconds int64 `protobuf:"varint,2,opt,name=interval_seconds,json=intervalSeconds,proto3" json:"interval_seconds,omitempty"`
	// Timeout time.Duration 0x60json:",omitempty"0x60 // Timeout is the time to wait before considering the check to have hung.
	TimeoutSeconds int64 `protobuf:"varint,3,opt,name=timeout_seconds,json=timeoutSeconds,proto3" json:"timeout_seconds,omitempty"`
	// StartPeriod time.Duration 0x60json:",omitempty"0x60 // The start period for the container to initialize before the retries starts to count down.
	StartPeriod int64 `protobuf:"varint,4,opt,name=start_period,json=startPeriod,proto3" json:"start_period,omitempty"`
	// Retries int 0x60json:",omitempty"0x60// Retries is the number of consecutive failures needed to consider a container as unhealthy. Zero means inherit.
	Retries int32 `protobuf:"varint,5,opt,name=retries,proto3" json:"retries,omitempty"`
}

func (m *HealthConfig) Reset()                    { *m = HealthConfig{} }
func (m *HealthConfig) String() string            { return proto.CompactTextString(m) }
func (*HealthConfig) ProtoMessage()               {}
func (*HealthConfig) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{0} }

func (m *HealthConfig) GetTest() []string {
	if m != nil {
		return m.Test
	}
	return nil
}

func (m *HealthConfig) GetIntervalSeconds() int64 {
	if m != nil {
		return m.IntervalSeconds
	}
	return 0
}

func (m *HealthConfig) GetTimeoutSeconds() int64 {
	if m != nil {
		return m.TimeoutSeconds
	}
	return 0
}

func (m *HealthConfig) GetStartPeriod() int64 {
	if m != nil {
		return m.StartPeriod
	}
	return 0
}

func (m *HealthConfig) GetRetries() int32 {
	if m != nil {
		return m.Retries
	}
	return 0
}

// Config contains the configuration data about a container.
// It should hold only portable information about the container.
// Here, "portable" means "independent from the host we are running on".
// Non-portable information *should* appear in HostConfig.
// All fields added to this struct must be marked 'omitempty' to keep getting
// predictable hashes from the old 'v1Compatibility' configuration.
// type Config struct
type Config struct {
	// Hostname string // Hostname
	Hostname string `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Domainname string // Domainname
	Domainname string `protobuf:"bytes,2,opt,name=domainname,proto3" json:"domainname,omitempty"`
	// User string // User that will run the command(s) inside the container, also support user:group
	User string `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
	// AttachStdin bool // Attach the standard input, makes possible user interaction
	AttachStdin bool `protobuf:"varint,4,opt,name=attach_stdin,json=attachStdin,proto3" json:"attach_stdin,omitempty"`
	// AttachStdout bool // Attach the standard output
	AttachStdout bool `protobuf:"varint,5,opt,name=attach_stdout,json=attachStdout,proto3" json:"attach_stdout,omitempty"`
	// AttachStderr bool // Attach the standard error
	AttachStderr bool `protobuf:"varint,6,opt,name=attach_stderr,json=attachStderr,proto3" json:"attach_stderr,omitempty"`
	// ExposedPorts nat.PortSet 0x60json",omitempty"0x60 // List of exposed ports
	ExposedPorts *nat.PortSet `protobuf:"bytes,7,opt,name=exposed_ports,json=exposedPorts" json:"exposed_ports,omitempty"`
	// Tty bool // Attach standard streams to a tty, including stdin if it is not closed.
	Tty bool `protobuf:"varint,8,opt,name=tty,proto3" json:"tty,omitempty"`
	// OpenStdin // Open stdin
	OpenStdin bool `protobuf:"varint,9,opt,name=open_stdin,json=openStdin,proto3" json:"open_stdin,omitempty"`
	// StdinOnce bool // If true, close stdin after the 1 attached client disconnects.
	StdinOnce bool `protobuf:"varint,10,opt,name=stdin_once,json=stdinOnce,proto3" json:"stdin_once,omitempty"`
	// Env []string  // List of environment variable to set in the container
	Env []string `protobuf:"bytes,11,rep,name=env" json:"env,omitempty"`
	// Cmd strslice.StrSlice // Command to run when starting the container
	// StrSlice represents a string or an array of strings. We need to override the json decoder to accept both options. // type StrSlice []string
	Cmd []string `protobuf:"bytes,12,rep,name=cmd" json:"cmd,omitempty"`
	// Healthcheck *HealthConfig 0x60json:",omitempty"0x60 // Healthcheck describes how to check the container is healthy
	Healthcheck *HealthConfig `protobuf:"bytes,13,opt,name=healthcheck" json:"healthcheck,omitempty"`
	// ArgsEscaped bool 0x60json",omitempty"0x60 // True if command is already escaped (Windows specific)
	ArgsEscaped bool `protobuf:"varint,14,opt,name=args_escaped,json=argsEscaped,proto3" json:"args_escaped,omitempty"`
	// Image string // Name of the image as it was passed by the operator (e.g. could be symbolic)
	Image string `protobuf:"bytes,15,opt,name=image,proto3" json:"image,omitempty"`
	// Volumes map[string]struct{} // List of volumes (mounts) used for the container
	Volumes map[string]*Config_VoidStruct `protobuf:"bytes,16,rep,name=volumes" json:"volumes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// WorkingDir string // Current directory (PWD) in the command will be launched
	WorkingDir string `protobuf:"bytes,17,opt,name=working_dir,json=workingDir,proto3" json:"working_dir,omitempty"`
	// Entrypoint strslice.StrSlice // Entrypoint to run when starting the container
	Entrypoint []string `protobuf:"bytes,18,rep,name=entrypoint" json:"entrypoint,omitempty"`
	// NetworkDisabled bool 0x60json:",omitempty"0x60 // Is network disabled
	NetworkDisabled bool `protobuf:"varint,19,opt,name=network_disabled,json=networkDisabled,proto3" json:"network_disabled,omitempty"`
	// MacAddress string 0x60json:",omitempty"0x60 // Mac Address of the container
	MacAddress string `protobuf:"bytes,20,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	// OnBuild []string // ONBUILD metadata that were defined on the image Dockerfile
	OnBuild []string `protobuf:"bytes,21,rep,name=on_build,json=onBuild" json:"on_build,omitempty"`
	// Labels map[string]string // List of labels set to this container
	Labels map[string]string `protobuf:"bytes,22,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// StopSignal string 0x60json:",omitempty"0x60 // Signal to stop a container
	StopSignal string `protobuf:"bytes,23,opt,name=stop_signal,json=stopSignal,proto3" json:"stop_signal,omitempty"`
	// StopTimeout 0x60json:",omitempty"0x60 // Timeout (in seconds) to stop a container
	StopTimeout int32 `protobuf:"varint,24,opt,name=stop_timeout,json=stopTimeout,proto3" json:"stop_timeout,omitempty"`
	// Shell strslice.StrSlice 0x60json:",omitempty"0x60 // Shell for shell-form of RUN, CMD, ENTRYPOINT
	Shell []string `protobuf:"bytes,25,rep,name=shell" json:"shell,omitempty"`
}

func (m *Config) Reset()                    { *m = Config{} }
func (m *Config) String() string            { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()               {}
func (*Config) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{1} }

func (m *Config) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Config) GetDomainname() string {
	if m != nil {
		return m.Domainname
	}
	return ""
}

func (m *Config) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *Config) GetAttachStdin() bool {
	if m != nil {
		return m.AttachStdin
	}
	return false
}

func (m *Config) GetAttachStdout() bool {
	if m != nil {
		return m.AttachStdout
	}
	return false
}

func (m *Config) GetAttachStderr() bool {
	if m != nil {
		return m.AttachStderr
	}
	return false
}

func (m *Config) GetExposedPorts() *nat.PortSet {
	if m != nil {
		return m.ExposedPorts
	}
	return nil
}

func (m *Config) GetTty() bool {
	if m != nil {
		return m.Tty
	}
	return false
}

func (m *Config) GetOpenStdin() bool {
	if m != nil {
		return m.OpenStdin
	}
	return false
}

func (m *Config) GetStdinOnce() bool {
	if m != nil {
		return m.StdinOnce
	}
	return false
}

func (m *Config) GetEnv() []string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *Config) GetCmd() []string {
	if m != nil {
		return m.Cmd
	}
	return nil
}

func (m *Config) GetHealthcheck() *HealthConfig {
	if m != nil {
		return m.Healthcheck
	}
	return nil
}

func (m *Config) GetArgsEscaped() bool {
	if m != nil {
		return m.ArgsEscaped
	}
	return false
}

func (m *Config) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *Config) GetVolumes() map[string]*Config_VoidStruct {
	if m != nil {
		return m.Volumes
	}
	return nil
}

func (m *Config) GetWorkingDir() string {
	if m != nil {
		return m.WorkingDir
	}
	return ""
}

func (m *Config) GetEntrypoint() []string {
	if m != nil {
		return m.Entrypoint
	}
	return nil
}

func (m *Config) GetNetworkDisabled() bool {
	if m != nil {
		return m.NetworkDisabled
	}
	return false
}

func (m *Config) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *Config) GetOnBuild() []string {
	if m != nil {
		return m.OnBuild
	}
	return nil
}

func (m *Config) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Config) GetStopSignal() string {
	if m != nil {
		return m.StopSignal
	}
	return ""
}

func (m *Config) GetStopTimeout() int32 {
	if m != nil {
		return m.StopTimeout
	}
	return 0
}

func (m *Config) GetShell() []string {
	if m != nil {
		return m.Shell
	}
	return nil
}

type Config_VoidStruct struct {
}

func (m *Config_VoidStruct) Reset()                    { *m = Config_VoidStruct{} }
func (m *Config_VoidStruct) String() string            { return proto.CompactTextString(m) }
func (*Config_VoidStruct) ProtoMessage()               {}
func (*Config_VoidStruct) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{1, 2} }

// ContainerCreateCreatedBody OK response to ContainerCreate operation
// type ContainerCreateCreatedBody struct
type ContainerCreateCreatedBody struct {
	// The ID of the created container. Required: true
	// ID string 0x60json:"Id"0x60
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Warnings encountered when creating the container. Required: true
	// Warnings []string 0x60json:"Warnings"0x60
	Warnings []string `protobuf:"bytes,2,rep,name=warnings" json:"warnings,omitempty"`
}

func (m *ContainerCreateCreatedBody) Reset()         { *m = ContainerCreateCreatedBody{} }
func (m *ContainerCreateCreatedBody) String() string { return proto.CompactTextString(m) }
func (*ContainerCreateCreatedBody) ProtoMessage()    {}
func (*ContainerCreateCreatedBody) Descriptor() ([]byte, []int) {
	return fileDescriptorContainer, []int{2}
}

func (m *ContainerCreateCreatedBody) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ContainerCreateCreatedBody) GetWarnings() []string {
	if m != nil {
		return m.Warnings
	}
	return nil
}

// DeviceMapping represents the device mapping between the host and the container.
// type DeviceMapping struct
type DeviceMapping struct {
	// PathOnHost string
	PathOnHost string `protobuf:"bytes,1,opt,name=path_on_host,json=pathOnHost,proto3" json:"path_on_host,omitempty"`
	// PathInContainer string
	PathInContainer string `protobuf:"bytes,2,opt,name=path_in_container,json=pathInContainer,proto3" json:"path_in_container,omitempty"`
	// CgroupPermissions string
	CgroupPermissions string `protobuf:"bytes,3,opt,name=cgroup_permissions,json=cgroupPermissions,proto3" json:"cgroup_permissions,omitempty"`
}

func (m *DeviceMapping) Reset()                    { *m = DeviceMapping{} }
func (m *DeviceMapping) String() string            { return proto.CompactTextString(m) }
func (*DeviceMapping) ProtoMessage()               {}
func (*DeviceMapping) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{3} }

func (m *DeviceMapping) GetPathOnHost() string {
	if m != nil {
		return m.PathOnHost
	}
	return ""
}

func (m *DeviceMapping) GetPathInContainer() string {
	if m != nil {
		return m.PathInContainer
	}
	return ""
}

func (m *DeviceMapping) GetCgroupPermissions() string {
	if m != nil {
		return m.CgroupPermissions
	}
	return ""
}

// RestartPolicy represents the restart policies of the container.
// type RestartPolicy struct
type RestartPolicy struct {
	// Name string
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// MaximumRetryCount int
	MaximumRetryCount int32 `protobuf:"varint,2,opt,name=maximum_retry_count,json=maximumRetryCount,proto3" json:"maximum_retry_count,omitempty"`
}

func (m *RestartPolicy) Reset()                    { *m = RestartPolicy{} }
func (m *RestartPolicy) String() string            { return proto.CompactTextString(m) }
func (*RestartPolicy) ProtoMessage()               {}
func (*RestartPolicy) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{4} }

func (m *RestartPolicy) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RestartPolicy) GetMaximumRetryCount() int32 {
	if m != nil {
		return m.MaximumRetryCount
	}
	return 0
}

// LogConfig represents the logging configuration of the container.
// type LogConfig struct
type LogConfig struct {
	// Type string // "", "blocking", "non-blocking"
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Config map[string]string
	Config map[string]string `protobuf:"bytes,2,rep,name=config" json:"config,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *LogConfig) Reset()                    { *m = LogConfig{} }
func (m *LogConfig) String() string            { return proto.CompactTextString(m) }
func (*LogConfig) ProtoMessage()               {}
func (*LogConfig) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{5} }

func (m *LogConfig) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *LogConfig) GetConfig() map[string]string {
	if m != nil {
		return m.Config
	}
	return nil
}

// Resources contains container's resources (cgroups config, ulimits...)
// to see https://github.com/moby/moby/blob/master/api/types/container/host_config.go
type Resources struct {
	// Applicable to all platforms
	//
	// CPUShares int64 0x60json:"CpuShares"0x60 // CPU shares (relative weight vs. other containers)
	CpuShares int64 `protobuf:"varint,1,opt,name=cpu_shares,json=cpuShares,proto3" json:"cpu_shares,omitempty"`
	// Memory int64 // Memory limit (in bytes)
	Memory int64 `protobuf:"varint,2,opt,name=memory,proto3" json:"memory,omitempty"`
	// NanoCPUs int64 0x60json:"NonoCpus"0x60 // CPU quota in units of 10<sup>-9</sup> CPUs.
	NanoCpus int64 `protobuf:"varint,3,opt,name=nano_cpus,json=nanoCpus,proto3" json:"nano_cpus,omitempty"`
	// Applicable to UNIX platforms
	//
	// CgroupParent string // Parent cgroup.
	CgroupParent string `protobuf:"bytes,4,opt,name=cgroup_parent,json=cgroupParent,proto3" json:"cgroup_parent,omitempty"`
	// BlkioWeight uint16 // Block IO weight (relative weight vs. other containers)
	BlkioWeight int32 `protobuf:"varint,5,opt,name=blkio_weight,json=blkioWeight,proto3" json:"blkio_weight,omitempty"`
	// BlkioWeightDevice []*blkiodev.WeightDevice
	BlkioWeightDevice []*blkiodev.WeightDevice `protobuf:"bytes,6,rep,name=blkio_weight_device,json=blkioWeightDevice" json:"blkio_weight_device,omitempty"`
	// BlkioDeviceReadBps []*blkiodev.ThrottleDevice
	BlkioDeviceReadBps []*blkiodev.ThrottleDevice `protobuf:"bytes,7,rep,name=blkio_device_read_bps,json=blkioDeviceReadBps" json:"blkio_device_read_bps,omitempty"`
	// BlkioDeviceWriteBps []*blkiodev.ThrottleDevice
	BlkioDeviceWriteBps []*blkiodev.ThrottleDevice `protobuf:"bytes,8,rep,name=blkio_device_write_bps,json=blkioDeviceWriteBps" json:"blkio_device_write_bps,omitempty"`
	// BlkioDeviceReadIOps []*blkiodev.ThrottleDevice
	BlkioDeviceReadIops []*blkiodev.ThrottleDevice `protobuf:"bytes,9,rep,name=blkio_device_read_iops,json=blkioDeviceReadIops" json:"blkio_device_read_iops,omitempty"`
	// BlkioDeviceWriteIOps []*blkiodev.ThrottleDevice
	BlkioDeviceWriteIops []*blkiodev.ThrottleDevice `protobuf:"bytes,10,rep,name=blkio_device_write_iops,json=blkioDeviceWriteIops" json:"blkio_device_write_iops,omitempty"`
	// CPUPeriod int64 0x60json:"CpuPeriod"0x60 // CPU CFS (Completely Fair Scheduler) period
	CpuPeriod int64 `protobuf:"varint,11,opt,name=cpu_period,json=cpuPeriod,proto3" json:"cpu_period,omitempty"`
	// CPUQuota int64 0x60json:"CpuQuota"0x60 // CPU CFS (Completely Fair Scheduler) quota
	CpuQuota int64 `protobuf:"varint,12,opt,name=cpu_quota,json=cpuQuota,proto3" json:"cpu_quota,omitempty"`
	// CPURealtimePeriod int64 0x60json:"CpuRealtimePeriod"0x60 // CPU real-time period
	CpuRealtimePeriod int64 `protobuf:"varint,13,opt,name=cpu_realtime_period,json=cpuRealtimePeriod,proto3" json:"cpu_realtime_period,omitempty"`
	// CPURealtimeRuntime int64 0x60json:"CpuRealtimeRuntime"0x60 // CPU real-time runtime
	CpuRealtimeRuntime int64 `protobuf:"varint,14,opt,name=cpu_realtime_runtime,json=cpuRealtimeRuntime,proto3" json:"cpu_realtime_runtime,omitempty"`
	// CpusetCpus string // CpusetCpus 0-2, 0,1
	CpusetCpus string `protobuf:"bytes,15,opt,name=cpuset_cpus,json=cpusetCpus,proto3" json:"cpuset_cpus,omitempty"`
	// CpusetMems string // CpusetMems 0-2, 0,1
	CpusetMems string `protobuf:"bytes,16,opt,name=cpuset_mems,json=cpusetMems,proto3" json:"cpuset_mems,omitempty"`
	// Devices []DeviceMapping // List of devices to map inside the container
	Devices []*DeviceMapping `protobuf:"bytes,17,rep,name=devices" json:"devices,omitempty"`
	// DeviceCgroupRules []string // List of rule to be added to the device cgroup
	DeviceCgroupRules []string `protobuf:"bytes,18,rep,name=device_cgroup_rules,json=deviceCgroupRules" json:"device_cgroup_rules,omitempty"`
	// DiskQuota int64 // Disk limit (in bytes)
	DiskQuota int64 `protobuf:"varint,19,opt,name=disk_quota,json=diskQuota,proto3" json:"disk_quota,omitempty"`
	// KernelMemory int64 // Kernel memory limit (in bytes)
	KernelMemory int64 `protobuf:"varint,20,opt,name=kernel_memory,json=kernelMemory,proto3" json:"kernel_memory,omitempty"`
	// MemoryReservation int64 // Memory soft limit (in bytes)
	MemoryReservation int64 `protobuf:"varint,21,opt,name=memory_reservation,json=memoryReservation,proto3" json:"memory_reservation,omitempty"`
	// MemorySwap int64 // Total memory usage (memory + swap); set `-1` to enable unlimited swap
	MemorySwap int64 `protobuf:"varint,22,opt,name=memory_swap,json=memorySwap,proto3" json:"memory_swap,omitempty"`
	// MemorySwappiness *int64 // Tuning container memory swappiness behaviour
	MemorySwappiness int64 `protobuf:"varint,23,opt,name=memory_swappiness,json=memorySwappiness,proto3" json:"memory_swappiness,omitempty"`
	// OomKillDisable *bool // Whether to disable OOM Killer or not
	OomKillDisable bool `protobuf:"varint,24,opt,name=oom_kill_disable,json=oomKillDisable,proto3" json:"oom_kill_disable,omitempty"`
	// PidsLimit int64 // Setting pids limit for a container
	PidsLimit int64 `protobuf:"varint,25,opt,name=pids_limit,json=pidsLimit,proto3" json:"pids_limit,omitempty"`
	// Ulimits []*units.Ulimit // List of ulimits to be set in the container
	Ulimits []*units.Ulimit `protobuf:"bytes,26,rep,name=ulimits" json:"ulimits,omitempty"`
	// Applicable to Windows
	//
	// CPUCount int64 // CPU count
	CpuCount int64 `protobuf:"varint,27,opt,name=cpu_count,json=cpuCount,proto3" json:"cpu_count,omitempty"`
	// CPUPercent int64 // CPU percent
	CpuPercent int64 `protobuf:"varint,28,opt,name=cpu_percent,json=cpuPercent,proto3" json:"cpu_percent,omitempty"`
	// IOMaximumIOps uint64 // Maximum IOps for the container system drive
	IoMaximumIops uint64 `protobuf:"varint,29,opt,name=io_maximum_iops,json=ioMaximumIops,proto3" json:"io_maximum_iops,omitempty"`
	// IOMaximumBandwidth // Maximum IO in bytes per second for the container system drive
	IoMaximumBandwidth uint64 `protobuf:"varint,30,opt,name=io_maximum_bandwidth,json=ioMaximumBandwidth,proto3" json:"io_maximum_bandwidth,omitempty"`
}

func (m *Resources) Reset()                    { *m = Resources{} }
func (m *Resources) String() string            { return proto.CompactTextString(m) }
func (*Resources) ProtoMessage()               {}
func (*Resources) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{6} }

func (m *Resources) GetCpuShares() int64 {
	if m != nil {
		return m.CpuShares
	}
	return 0
}

func (m *Resources) GetMemory() int64 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *Resources) GetNanoCpus() int64 {
	if m != nil {
		return m.NanoCpus
	}
	return 0
}

func (m *Resources) GetCgroupParent() string {
	if m != nil {
		return m.CgroupParent
	}
	return ""
}

func (m *Resources) GetBlkioWeight() int32 {
	if m != nil {
		return m.BlkioWeight
	}
	return 0
}

func (m *Resources) GetBlkioWeightDevice() []*blkiodev.WeightDevice {
	if m != nil {
		return m.BlkioWeightDevice
	}
	return nil
}

func (m *Resources) GetBlkioDeviceReadBps() []*blkiodev.ThrottleDevice {
	if m != nil {
		return m.BlkioDeviceReadBps
	}
	return nil
}

func (m *Resources) GetBlkioDeviceWriteBps() []*blkiodev.ThrottleDevice {
	if m != nil {
		return m.BlkioDeviceWriteBps
	}
	return nil
}

func (m *Resources) GetBlkioDeviceReadIops() []*blkiodev.ThrottleDevice {
	if m != nil {
		return m.BlkioDeviceReadIops
	}
	return nil
}

func (m *Resources) GetBlkioDeviceWriteIops() []*blkiodev.ThrottleDevice {
	if m != nil {
		return m.BlkioDeviceWriteIops
	}
	return nil
}

func (m *Resources) GetCpuPeriod() int64 {
	if m != nil {
		return m.CpuPeriod
	}
	return 0
}

func (m *Resources) GetCpuQuota() int64 {
	if m != nil {
		return m.CpuQuota
	}
	return 0
}

func (m *Resources) GetCpuRealtimePeriod() int64 {
	if m != nil {
		return m.CpuRealtimePeriod
	}
	return 0
}

func (m *Resources) GetCpuRealtimeRuntime() int64 {
	if m != nil {
		return m.CpuRealtimeRuntime
	}
	return 0
}

func (m *Resources) GetCpusetCpus() string {
	if m != nil {
		return m.CpusetCpus
	}
	return ""
}

func (m *Resources) GetCpusetMems() string {
	if m != nil {
		return m.CpusetMems
	}
	return ""
}

func (m *Resources) GetDevices() []*DeviceMapping {
	if m != nil {
		return m.Devices
	}
	return nil
}

func (m *Resources) GetDeviceCgroupRules() []string {
	if m != nil {
		return m.DeviceCgroupRules
	}
	return nil
}

func (m *Resources) GetDiskQuota() int64 {
	if m != nil {
		return m.DiskQuota
	}
	return 0
}

func (m *Resources) GetKernelMemory() int64 {
	if m != nil {
		return m.KernelMemory
	}
	return 0
}

func (m *Resources) GetMemoryReservation() int64 {
	if m != nil {
		return m.MemoryReservation
	}
	return 0
}

func (m *Resources) GetMemorySwap() int64 {
	if m != nil {
		return m.MemorySwap
	}
	return 0
}

func (m *Resources) GetMemorySwappiness() int64 {
	if m != nil {
		return m.MemorySwappiness
	}
	return 0
}

func (m *Resources) GetOomKillDisable() bool {
	if m != nil {
		return m.OomKillDisable
	}
	return false
}

func (m *Resources) GetPidsLimit() int64 {
	if m != nil {
		return m.PidsLimit
	}
	return 0
}

func (m *Resources) GetUlimits() []*units.Ulimit {
	if m != nil {
		return m.Ulimits
	}
	return nil
}

func (m *Resources) GetCpuCount() int64 {
	if m != nil {
		return m.CpuCount
	}
	return 0
}

func (m *Resources) GetCpuPercent() int64 {
	if m != nil {
		return m.CpuPercent
	}
	return 0
}

func (m *Resources) GetIoMaximumIops() uint64 {
	if m != nil {
		return m.IoMaximumIops
	}
	return 0
}

func (m *Resources) GetIoMaximumBandwidth() uint64 {
	if m != nil {
		return m.IoMaximumBandwidth
	}
	return 0
}

// HostConfig the non-portable Config structure of a container.
// Here, "non-portable" means "dependent of the host we are running on".
// Portable information *should* appear in Config.
// type HostConfig struct
type HostConfig struct {
	// Applicable to all platforms
	//
	// Binds []string // List of volume bindings for this container
	Binds []string `protobuf:"bytes,1,rep,name=binds" json:"binds,omitempty"`
	// ContainerIDFile // File (path) where the containerId is written
	ContainerIdFile string `protobuf:"bytes,2,opt,name=container_id_file,json=containerIdFile,proto3" json:"container_id_file,omitempty"`
	// LogConfig LogConfig // Configuration of the logs for this container
	LogConfig *LogConfig `protobuf:"bytes,3,opt,name=log_config,json=logConfig" json:"log_config,omitempty"`
	// NetworkMode NetworkMode // Network mode to use for the container, "none", "default", "container:<id>"
	// NetworkMode represents the container network stack. // type NetworkMode string
	NetworkMode string `protobuf:"bytes,4,opt,name=network_mode,json=networkMode,proto3" json:"network_mode,omitempty"`
	// PortBindings nat.PortMap // Port mapping between the exposed port (container) and the host
	PortBindings *nat.PortMap `protobuf:"bytes,5,opt,name=port_bindings,json=portBindings" json:"port_bindings,omitempty"`
	// RestartPolicy RestartPolicy // Restart policy to be used for the container
	RestartPolicy *RestartPolicy `protobuf:"bytes,6,opt,name=restart_policy,json=restartPolicy" json:"restart_policy,omitempty"`
	// AutoRemove bool // Automatically remove container when it exits
	AutoRemove bool `protobuf:"varint,7,opt,name=auto_remove,json=autoRemove,proto3" json:"auto_remove,omitempty"`
	// VolumeDriver string // Name of the volume driver used to mount volumes
	VolumeDriver string `protobuf:"bytes,8,opt,name=volume_driver,json=volumeDriver,proto3" json:"volume_driver,omitempty"`
	// VolumesFrom []string // List of volumes to take from other container
	VolumesFrom []string `protobuf:"bytes,9,rep,name=volumes_from,json=volumesFrom" json:"volumes_from,omitempty"`
	// Applicable to UNIX platforms
	//
	// CapAdd strslice.StrSlice // List of kernel capabilities to add to the container
	CapAdd []string `protobuf:"bytes,10,rep,name=cap_add,json=capAdd" json:"cap_add,omitempty"`
	// CapDrop strslice.StrSlice // List of kernel capabilities to remove from the container
	CapDrop []string `protobuf:"bytes,11,rep,name=cap_drop,json=capDrop" json:"cap_drop,omitempty"`
	// DNS []string 0x60json:"Dns"0x60 // List of DNS server to lookup
	Dns []string `protobuf:"bytes,12,rep,name=dns" json:"dns,omitempty"`
	// DNSOptions []string 0x60json:"DnsOptions"0x60 // List of DNSOption to look for
	DnsOptions []string `protobuf:"bytes,13,rep,name=dns_options,json=dnsOptions" json:"dns_options,omitempty"`
	// DNSSearch []string 0x60json:"DnsSearch"0x60 // List of DNSSearch to look for
	DnsSearch []string `protobuf:"bytes,14,rep,name=dns_search,json=dnsSearch" json:"dns_search,omitempty"`
	// ExtraHosts []string // List of extra hosts
	ExtraHosts []string `protobuf:"bytes,15,rep,name=extra_hosts,json=extraHosts" json:"extra_hosts,omitempty"`
	// GroupAdd []string // List of additional groups that the container process will run as
	GroupAdd []string `protobuf:"bytes,16,rep,name=group_add,json=groupAdd" json:"group_add,omitempty"`
	// IpcMode IpcMode // IPC namespace to use for the container, "", "host", "container"
	// IpcMode represents the container ipc stack. // type IpcMode string
	IpcMode string `protobuf:"bytes,17,opt,name=ipc_mode,json=ipcMode,proto3" json:"ipc_mode,omitempty"`
	// Cgroup CgroupSpec // Cgroup to use for the container, "container:<id>"
	// CgroupSpec represents the cgroup to use for the container. // type CgroupSpec string
	Cgroup string `protobuf:"bytes,18,opt,name=cgroup,proto3" json:"cgroup,omitempty"`
	// Links []string // List of links (in the name:alias form)
	Links []string `protobuf:"bytes,19,rep,name=links" json:"links,omitempty"`
	// OomScoreAdj int // Container preference for OOM-killing
	OomScoreAdj int32 `protobuf:"varint,20,opt,name=oom_score_adj,json=oomScoreAdj,proto3" json:"oom_score_adj,omitempty"`
	// PidMode PidMode // PID namespace to use for the container
	// PidMode represents the pid namespace of the container. // type PidMode string
	PidMode string `protobuf:"bytes,21,opt,name=pid_mode,json=pidMode,proto3" json:"pid_mode,omitempty"`
	// Privieged bool // Is the container in privileged mode
	Privileged bool `protobuf:"varint,22,opt,name=privileged,proto3" json:"privileged,omitempty"`
	// PublishAllPorts bool // Should docker publish all exposed port for the container
	PublishAllPorts bool `protobuf:"varint,23,opt,name=publish_all_ports,json=publishAllPorts,proto3" json:"publish_all_ports,omitempty"`
	// ReadonlyRootfs bool // Is the container root filesystem in read-only
	ReadonlyRootfs bool `protobuf:"varint,24,opt,name=readonly_rootfs,json=readonlyRootfs,proto3" json:"readonly_rootfs,omitempty"`
	// SecurityOpt []string // List of string values to customize labels for MLS systems, such as SELinux.
	SecurityOpt []string `protobuf:"bytes,25,rep,name=security_opt,json=securityOpt" json:"security_opt,omitempty"`
	// Storage driver options per container.
	// StorageOpt map[string]string 0x60json:",omitempty"0x60
	StorageOpt map[string]string `protobuf:"bytes,26,rep,name=storage_opt,json=storageOpt" json:"storage_opt,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// List of tmpfs (mounts) used for the container
	// Tmpfs map[string]string 0x60json:",omitempty"0x60
	Tmpfs map[string]string `protobuf:"bytes,27,rep,name=tmpfs" json:"tmpfs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// UTSMode UTSMode // UTSMode represents the UTS namespace of the container. // type UTSMode string
	// UTS namespace to use for the container
	UtsMode string `protobuf:"bytes,28,opt,name=uts_mode,json=utsMode,proto3" json:"uts_mode,omitempty"`
	// UsernsMode UsernsMode // UsernsMode represents userns mode in the container. // type UsernsMode string
	// The user namespace to use for the container
	UsernsMode string `protobuf:"bytes,29,opt,name=userns_mode,json=usernsMode,proto3" json:"userns_mode,omitempty"`
	// ShmSize int64
	// Total shm memory usage
	ShmSize int64 `protobuf:"varint,30,opt,name=shm_size,json=shmSize,proto3" json:"shm_size,omitempty"`
	// Sysctls map[string]string 0x60json:",omitempty"0x60
	// List of Namespaced sysctls used for the container
	Sysctls map[string]string `protobuf:"bytes,31,rep,name=sysctls" json:"sysctls,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Runtime string 0x60json:",omitempty"0x60
	// Runtime to use with this container
	Runtime string `protobuf:"bytes,32,opt,name=runtime,proto3" json:"runtime,omitempty"`
	// Applicable to Windows
	//
	// ConsoleSize [2]uint // Initial console size (height,width)
	ConsoleSizeHeight uint32 `protobuf:"varint,33,opt,name=console_size_height,json=consoleSizeHeight,proto3" json:"console_size_height,omitempty"`
	ConsoleSizeWidth  uint32 `protobuf:"varint,34,opt,name=console_size_width,json=consoleSizeWidth,proto3" json:"console_size_width,omitempty"`
	// Isolation Isolation // Isolation technology of the container (e.g. default, hyperv)
	// Isolation represents the isolation technology of a container. The supported values are platform specific // type Isolation string
	Isolation string `protobuf:"bytes,35,opt,name=isolation,proto3" json:"isolation,omitempty"`
	// Contains container's resources (cgroups, ulimits)
	// Resources
	Resources *Resources `protobuf:"bytes,36,opt,name=resources" json:"resources,omitempty"`
	// Mounts specs used by the container
	// Mounts []mount.Mount 0x60json:",omitempty"0x60
	Mounts []*mount.Mount `protobuf:"bytes,37,rep,name=mounts" json:"mounts,omitempty"`
	// MaskedPaths is the list of paths to be masked inside the container (this overrides the default set of paths)
	// MaskedPaths []string
	MaskedPaths []string `protobuf:"bytes,38,rep,name=masked_paths,json=maskedPaths" json:"masked_paths,omitempty"`
	// ReadonlyPaths is the list of paths to be set as read-only inside the container (this overrides the default set of paths)
	// ReadonlyPaths []string
	ReadonlyPaths []string `protobuf:"bytes,39,rep,name=readonly_paths,json=readonlyPaths" json:"readonly_paths,omitempty"`
	// Run a custom init inside the container, if null, use the daemon's configured settings
	// Init *bool 0x60json:",omitempty"0x60
	Init bool `protobuf:"varint,40,opt,name=init,proto3" json:"init,omitempty"`
}

func (m *HostConfig) Reset()                    { *m = HostConfig{} }
func (m *HostConfig) String() string            { return proto.CompactTextString(m) }
func (*HostConfig) ProtoMessage()               {}
func (*HostConfig) Descriptor() ([]byte, []int) { return fileDescriptorContainer, []int{7} }

func (m *HostConfig) GetBinds() []string {
	if m != nil {
		return m.Binds
	}
	return nil
}

func (m *HostConfig) GetContainerIdFile() string {
	if m != nil {
		return m.ContainerIdFile
	}
	return ""
}

func (m *HostConfig) GetLogConfig() *LogConfig {
	if m != nil {
		return m.LogConfig
	}
	return nil
}

func (m *HostConfig) GetNetworkMode() string {
	if m != nil {
		return m.NetworkMode
	}
	return ""
}

func (m *HostConfig) GetPortBindings() *nat.PortMap {
	if m != nil {
		return m.PortBindings
	}
	return nil
}

func (m *HostConfig) GetRestartPolicy() *RestartPolicy {
	if m != nil {
		return m.RestartPolicy
	}
	return nil
}

func (m *HostConfig) GetAutoRemove() bool {
	if m != nil {
		return m.AutoRemove
	}
	return false
}

func (m *HostConfig) GetVolumeDriver() string {
	if m != nil {
		return m.VolumeDriver
	}
	return ""
}

func (m *HostConfig) GetVolumesFrom() []string {
	if m != nil {
		return m.VolumesFrom
	}
	return nil
}

func (m *HostConfig) GetCapAdd() []string {
	if m != nil {
		return m.CapAdd
	}
	return nil
}

func (m *HostConfig) GetCapDrop() []string {
	if m != nil {
		return m.CapDrop
	}
	return nil
}

func (m *HostConfig) GetDns() []string {
	if m != nil {
		return m.Dns
	}
	return nil
}

func (m *HostConfig) GetDnsOptions() []string {
	if m != nil {
		return m.DnsOptions
	}
	return nil
}

func (m *HostConfig) GetDnsSearch() []string {
	if m != nil {
		return m.DnsSearch
	}
	return nil
}

func (m *HostConfig) GetExtraHosts() []string {
	if m != nil {
		return m.ExtraHosts
	}
	return nil
}

func (m *HostConfig) GetGroupAdd() []string {
	if m != nil {
		return m.GroupAdd
	}
	return nil
}

func (m *HostConfig) GetIpcMode() string {
	if m != nil {
		return m.IpcMode
	}
	return ""
}

func (m *HostConfig) GetCgroup() string {
	if m != nil {
		return m.Cgroup
	}
	return ""
}

func (m *HostConfig) GetLinks() []string {
	if m != nil {
		return m.Links
	}
	return nil
}

func (m *HostConfig) GetOomScoreAdj() int32 {
	if m != nil {
		return m.OomScoreAdj
	}
	return 0
}

func (m *HostConfig) GetPidMode() string {
	if m != nil {
		return m.PidMode
	}
	return ""
}

func (m *HostConfig) GetPrivileged() bool {
	if m != nil {
		return m.Privileged
	}
	return false
}

func (m *HostConfig) GetPublishAllPorts() bool {
	if m != nil {
		return m.PublishAllPorts
	}
	return false
}

func (m *HostConfig) GetReadonlyRootfs() bool {
	if m != nil {
		return m.ReadonlyRootfs
	}
	return false
}

func (m *HostConfig) GetSecurityOpt() []string {
	if m != nil {
		return m.SecurityOpt
	}
	return nil
}

func (m *HostConfig) GetStorageOpt() map[string]string {
	if m != nil {
		return m.StorageOpt
	}
	return nil
}

func (m *HostConfig) GetTmpfs() map[string]string {
	if m != nil {
		return m.Tmpfs
	}
	return nil
}

func (m *HostConfig) GetUtsMode() string {
	if m != nil {
		return m.UtsMode
	}
	return ""
}

func (m *HostConfig) GetUsernsMode() string {
	if m != nil {
		return m.UsernsMode
	}
	return ""
}

func (m *HostConfig) GetShmSize() int64 {
	if m != nil {
		return m.ShmSize
	}
	return 0
}

func (m *HostConfig) GetSysctls() map[string]string {
	if m != nil {
		return m.Sysctls
	}
	return nil
}

func (m *HostConfig) GetRuntime() string {
	if m != nil {
		return m.Runtime
	}
	return ""
}

func (m *HostConfig) GetConsoleSizeHeight() uint32 {
	if m != nil {
		return m.ConsoleSizeHeight
	}
	return 0
}

func (m *HostConfig) GetConsoleSizeWidth() uint32 {
	if m != nil {
		return m.ConsoleSizeWidth
	}
	return 0
}

func (m *HostConfig) GetIsolation() string {
	if m != nil {
		return m.Isolation
	}
	return ""
}

func (m *HostConfig) GetResources() *Resources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *HostConfig) GetMounts() []*mount.Mount {
	if m != nil {
		return m.Mounts
	}
	return nil
}

func (m *HostConfig) GetMaskedPaths() []string {
	if m != nil {
		return m.MaskedPaths
	}
	return nil
}

func (m *HostConfig) GetReadonlyPaths() []string {
	if m != nil {
		return m.ReadonlyPaths
	}
	return nil
}

func (m *HostConfig) GetInit() bool {
	if m != nil {
		return m.Init
	}
	return false
}

func init() {
	proto.RegisterType((*HealthConfig)(nil), "container.HealthConfig")
	proto.RegisterType((*Config)(nil), "container.Config")
	proto.RegisterType((*Config_VoidStruct)(nil), "container.Config.VoidStruct")
	proto.RegisterType((*ContainerCreateCreatedBody)(nil), "container.ContainerCreateCreatedBody")
	proto.RegisterType((*DeviceMapping)(nil), "container.DeviceMapping")
	proto.RegisterType((*RestartPolicy)(nil), "container.RestartPolicy")
	proto.RegisterType((*LogConfig)(nil), "container.LogConfig")
	proto.RegisterType((*Resources)(nil), "container.Resources")
	proto.RegisterType((*HostConfig)(nil), "container.HostConfig")
}
func (m *HealthConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Test) > 0 {
		for _, s := range m.Test {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IntervalSeconds != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.IntervalSeconds))
	}
	if m.TimeoutSeconds != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.TimeoutSeconds))
	}
	if m.StartPeriod != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.StartPeriod))
	}
	if m.Retries != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.Retries))
	}
	return i, nil
}

func (m *Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Config) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hostname) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	if len(m.Domainname) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.Domainname)))
		i += copy(dAtA[i:], m.Domainname)
	}
	if len(m.User) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	if m.AttachStdin {
		dAtA[i] = 0x20
		i++
		if m.AttachStdin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AttachStdout {
		dAtA[i] = 0x28
		i++
		if m.AttachStdout {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AttachStderr {
		dAtA[i] = 0x30
		i++
		if m.AttachStderr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ExposedPorts != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.ExposedPorts.Size()))
		n1, err := m.ExposedPorts.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Tty {
		dAtA[i] = 0x40
		i++
		if m.Tty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OpenStdin {
		dAtA[i] = 0x48
		i++
		if m.OpenStdin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StdinOnce {
		dAtA[i] = 0x50
		i++
		if m.StdinOnce {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Env) > 0 {
		for _, s := range m.Env {
			dAtA[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Cmd) > 0 {
		for _, s := range m.Cmd {
			dAtA[i] = 0x62
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Healthcheck != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.Healthcheck.Size()))
		n2, err := m.Healthcheck.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.ArgsEscaped {
		dAtA[i] = 0x70
		i++
		if m.ArgsEscaped {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.Volumes) > 0 {
		for k, _ := range m.Volumes {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			v := m.Volumes[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovContainer(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovContainer(uint64(len(k))) + msgSize
			i = encodeVarintContainer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintContainer(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintContainer(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	if len(m.WorkingDir) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.WorkingDir)))
		i += copy(dAtA[i:], m.WorkingDir)
	}
	if len(m.Entrypoint) > 0 {
		for _, s := range m.Entrypoint {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.NetworkDisabled {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.NetworkDisabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	if len(m.OnBuild) > 0 {
		for _, s := range m.OnBuild {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovContainer(uint64(len(k))) + 1 + len(v) + sovContainer(uint64(len(v)))
			i = encodeVarintContainer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintContainer(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintContainer(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.StopSignal) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.StopSignal)))
		i += copy(dAtA[i:], m.StopSignal)
	}
	if m.StopTimeout != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.StopTimeout))
	}
	if len(m.Shell) > 0 {
		for _, s := range m.Shell {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Config_VoidStruct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Config_VoidStruct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ContainerCreateCreatedBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerCreateCreatedBody) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Warnings) > 0 {
		for _, s := range m.Warnings {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *DeviceMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceMapping) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PathOnHost) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.PathOnHost)))
		i += copy(dAtA[i:], m.PathOnHost)
	}
	if len(m.PathInContainer) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.PathInContainer)))
		i += copy(dAtA[i:], m.PathInContainer)
	}
	if len(m.CgroupPermissions) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.CgroupPermissions)))
		i += copy(dAtA[i:], m.CgroupPermissions)
	}
	return i, nil
}

func (m *RestartPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestartPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.MaximumRetryCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.MaximumRetryCount))
	}
	return i, nil
}

func (m *LogConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Config) > 0 {
		for k, _ := range m.Config {
			dAtA[i] = 0x12
			i++
			v := m.Config[k]
			mapSize := 1 + len(k) + sovContainer(uint64(len(k))) + 1 + len(v) + sovContainer(uint64(len(v)))
			i = encodeVarintContainer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintContainer(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintContainer(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *Resources) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resources) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CpuShares != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.CpuShares))
	}
	if m.Memory != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.Memory))
	}
	if m.NanoCpus != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.NanoCpus))
	}
	if len(m.CgroupParent) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.CgroupParent)))
		i += copy(dAtA[i:], m.CgroupParent)
	}
	if m.BlkioWeight != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.BlkioWeight))
	}
	if len(m.BlkioWeightDevice) > 0 {
		for _, msg := range m.BlkioWeightDevice {
			dAtA[i] = 0x32
			i++
			i = encodeVarintContainer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BlkioDeviceReadBps) > 0 {
		for _, msg := range m.BlkioDeviceReadBps {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintContainer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BlkioDeviceWriteBps) > 0 {
		for _, msg := range m.BlkioDeviceWriteBps {
			dAtA[i] = 0x42
			i++
			i = encodeVarintContainer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BlkioDeviceReadIops) > 0 {
		for _, msg := range m.BlkioDeviceReadIops {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintContainer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BlkioDeviceWriteIops) > 0 {
		for _, msg := range m.BlkioDeviceWriteIops {
			dAtA[i] = 0x52
			i++
			i = encodeVarintContainer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CpuPeriod != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.CpuPeriod))
	}
	if m.CpuQuota != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.CpuQuota))
	}
	if m.CpuRealtimePeriod != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.CpuRealtimePeriod))
	}
	if m.CpuRealtimeRuntime != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.CpuRealtimeRuntime))
	}
	if len(m.CpusetCpus) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.CpusetCpus)))
		i += copy(dAtA[i:], m.CpusetCpus)
	}
	if len(m.CpusetMems) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.CpusetMems)))
		i += copy(dAtA[i:], m.CpusetMems)
	}
	if len(m.Devices) > 0 {
		for _, msg := range m.Devices {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintContainer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DeviceCgroupRules) > 0 {
		for _, s := range m.DeviceCgroupRules {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.DiskQuota != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.DiskQuota))
	}
	if m.KernelMemory != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.KernelMemory))
	}
	if m.MemoryReservation != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.MemoryReservation))
	}
	if m.MemorySwap != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.MemorySwap))
	}
	if m.MemorySwappiness != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.MemorySwappiness))
	}
	if m.OomKillDisable {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		if m.OomKillDisable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PidsLimit != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.PidsLimit))
	}
	if len(m.Ulimits) > 0 {
		for _, msg := range m.Ulimits {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintContainer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CpuCount != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.CpuCount))
	}
	if m.CpuPercent != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.CpuPercent))
	}
	if m.IoMaximumIops != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.IoMaximumIops))
	}
	if m.IoMaximumBandwidth != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.IoMaximumBandwidth))
	}
	return i, nil
}

func (m *HostConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Binds) > 0 {
		for _, s := range m.Binds {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ContainerIdFile) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.ContainerIdFile)))
		i += copy(dAtA[i:], m.ContainerIdFile)
	}
	if m.LogConfig != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.LogConfig.Size()))
		n4, err := m.LogConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.NetworkMode) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.NetworkMode)))
		i += copy(dAtA[i:], m.NetworkMode)
	}
	if m.PortBindings != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.PortBindings.Size()))
		n5, err := m.PortBindings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.RestartPolicy != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.RestartPolicy.Size()))
		n6, err := m.RestartPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.AutoRemove {
		dAtA[i] = 0x38
		i++
		if m.AutoRemove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.VolumeDriver) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.VolumeDriver)))
		i += copy(dAtA[i:], m.VolumeDriver)
	}
	if len(m.VolumesFrom) > 0 {
		for _, s := range m.VolumesFrom {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.CapAdd) > 0 {
		for _, s := range m.CapAdd {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.CapDrop) > 0 {
		for _, s := range m.CapDrop {
			dAtA[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Dns) > 0 {
		for _, s := range m.Dns {
			dAtA[i] = 0x62
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DnsOptions) > 0 {
		for _, s := range m.DnsOptions {
			dAtA[i] = 0x6a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DnsSearch) > 0 {
		for _, s := range m.DnsSearch {
			dAtA[i] = 0x72
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ExtraHosts) > 0 {
		for _, s := range m.ExtraHosts {
			dAtA[i] = 0x7a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.GroupAdd) > 0 {
		for _, s := range m.GroupAdd {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.IpcMode) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.IpcMode)))
		i += copy(dAtA[i:], m.IpcMode)
	}
	if len(m.Cgroup) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.Cgroup)))
		i += copy(dAtA[i:], m.Cgroup)
	}
	if len(m.Links) > 0 {
		for _, s := range m.Links {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.OomScoreAdj != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.OomScoreAdj))
	}
	if len(m.PidMode) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.PidMode)))
		i += copy(dAtA[i:], m.PidMode)
	}
	if m.Privileged {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		if m.Privileged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PublishAllPorts {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		if m.PublishAllPorts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReadonlyRootfs {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		if m.ReadonlyRootfs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.SecurityOpt) > 0 {
		for _, s := range m.SecurityOpt {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.StorageOpt) > 0 {
		for k, _ := range m.StorageOpt {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x1
			i++
			v := m.StorageOpt[k]
			mapSize := 1 + len(k) + sovContainer(uint64(len(k))) + 1 + len(v) + sovContainer(uint64(len(v)))
			i = encodeVarintContainer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintContainer(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintContainer(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Tmpfs) > 0 {
		for k, _ := range m.Tmpfs {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x1
			i++
			v := m.Tmpfs[k]
			mapSize := 1 + len(k) + sovContainer(uint64(len(k))) + 1 + len(v) + sovContainer(uint64(len(v)))
			i = encodeVarintContainer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintContainer(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintContainer(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.UtsMode) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.UtsMode)))
		i += copy(dAtA[i:], m.UtsMode)
	}
	if len(m.UsernsMode) > 0 {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.UsernsMode)))
		i += copy(dAtA[i:], m.UsernsMode)
	}
	if m.ShmSize != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.ShmSize))
	}
	if len(m.Sysctls) > 0 {
		for k, _ := range m.Sysctls {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x1
			i++
			v := m.Sysctls[k]
			mapSize := 1 + len(k) + sovContainer(uint64(len(k))) + 1 + len(v) + sovContainer(uint64(len(v)))
			i = encodeVarintContainer(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintContainer(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintContainer(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Runtime) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.Runtime)))
		i += copy(dAtA[i:], m.Runtime)
	}
	if m.ConsoleSizeHeight != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.ConsoleSizeHeight))
	}
	if m.ConsoleSizeWidth != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.ConsoleSizeWidth))
	}
	if len(m.Isolation) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContainer(dAtA, i, uint64(len(m.Isolation)))
		i += copy(dAtA[i:], m.Isolation)
	}
	if m.Resources != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintContainer(dAtA, i, uint64(m.Resources.Size()))
		n7, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Mounts) > 0 {
		for _, msg := range m.Mounts {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintContainer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MaskedPaths) > 0 {
		for _, s := range m.MaskedPaths {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x2
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ReadonlyPaths) > 0 {
		for _, s := range m.ReadonlyPaths {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x2
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Init {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		if m.Init {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeVarintContainer(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *HealthConfig) Size() (n int) {
	var l int
	_ = l
	if len(m.Test) > 0 {
		for _, s := range m.Test {
			l = len(s)
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	if m.IntervalSeconds != 0 {
		n += 1 + sovContainer(uint64(m.IntervalSeconds))
	}
	if m.TimeoutSeconds != 0 {
		n += 1 + sovContainer(uint64(m.TimeoutSeconds))
	}
	if m.StartPeriod != 0 {
		n += 1 + sovContainer(uint64(m.StartPeriod))
	}
	if m.Retries != 0 {
		n += 1 + sovContainer(uint64(m.Retries))
	}
	return n
}

func (m *Config) Size() (n int) {
	var l int
	_ = l
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	l = len(m.Domainname)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	if m.AttachStdin {
		n += 2
	}
	if m.AttachStdout {
		n += 2
	}
	if m.AttachStderr {
		n += 2
	}
	if m.ExposedPorts != nil {
		l = m.ExposedPorts.Size()
		n += 1 + l + sovContainer(uint64(l))
	}
	if m.Tty {
		n += 2
	}
	if m.OpenStdin {
		n += 2
	}
	if m.StdinOnce {
		n += 2
	}
	if len(m.Env) > 0 {
		for _, s := range m.Env {
			l = len(s)
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	if len(m.Cmd) > 0 {
		for _, s := range m.Cmd {
			l = len(s)
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	if m.Healthcheck != nil {
		l = m.Healthcheck.Size()
		n += 1 + l + sovContainer(uint64(l))
	}
	if m.ArgsEscaped {
		n += 2
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	if len(m.Volumes) > 0 {
		for k, v := range m.Volumes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovContainer(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovContainer(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovContainer(uint64(mapEntrySize))
		}
	}
	l = len(m.WorkingDir)
	if l > 0 {
		n += 2 + l + sovContainer(uint64(l))
	}
	if len(m.Entrypoint) > 0 {
		for _, s := range m.Entrypoint {
			l = len(s)
			n += 2 + l + sovContainer(uint64(l))
		}
	}
	if m.NetworkDisabled {
		n += 3
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 2 + l + sovContainer(uint64(l))
	}
	if len(m.OnBuild) > 0 {
		for _, s := range m.OnBuild {
			l = len(s)
			n += 2 + l + sovContainer(uint64(l))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovContainer(uint64(len(k))) + 1 + len(v) + sovContainer(uint64(len(v)))
			n += mapEntrySize + 2 + sovContainer(uint64(mapEntrySize))
		}
	}
	l = len(m.StopSignal)
	if l > 0 {
		n += 2 + l + sovContainer(uint64(l))
	}
	if m.StopTimeout != 0 {
		n += 2 + sovContainer(uint64(m.StopTimeout))
	}
	if len(m.Shell) > 0 {
		for _, s := range m.Shell {
			l = len(s)
			n += 2 + l + sovContainer(uint64(l))
		}
	}
	return n
}

func (m *Config_VoidStruct) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ContainerCreateCreatedBody) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	if len(m.Warnings) > 0 {
		for _, s := range m.Warnings {
			l = len(s)
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	return n
}

func (m *DeviceMapping) Size() (n int) {
	var l int
	_ = l
	l = len(m.PathOnHost)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	l = len(m.PathInContainer)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	l = len(m.CgroupPermissions)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	return n
}

func (m *RestartPolicy) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	if m.MaximumRetryCount != 0 {
		n += 1 + sovContainer(uint64(m.MaximumRetryCount))
	}
	return n
}

func (m *LogConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	if len(m.Config) > 0 {
		for k, v := range m.Config {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovContainer(uint64(len(k))) + 1 + len(v) + sovContainer(uint64(len(v)))
			n += mapEntrySize + 1 + sovContainer(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Resources) Size() (n int) {
	var l int
	_ = l
	if m.CpuShares != 0 {
		n += 1 + sovContainer(uint64(m.CpuShares))
	}
	if m.Memory != 0 {
		n += 1 + sovContainer(uint64(m.Memory))
	}
	if m.NanoCpus != 0 {
		n += 1 + sovContainer(uint64(m.NanoCpus))
	}
	l = len(m.CgroupParent)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	if m.BlkioWeight != 0 {
		n += 1 + sovContainer(uint64(m.BlkioWeight))
	}
	if len(m.BlkioWeightDevice) > 0 {
		for _, e := range m.BlkioWeightDevice {
			l = e.Size()
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	if len(m.BlkioDeviceReadBps) > 0 {
		for _, e := range m.BlkioDeviceReadBps {
			l = e.Size()
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	if len(m.BlkioDeviceWriteBps) > 0 {
		for _, e := range m.BlkioDeviceWriteBps {
			l = e.Size()
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	if len(m.BlkioDeviceReadIops) > 0 {
		for _, e := range m.BlkioDeviceReadIops {
			l = e.Size()
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	if len(m.BlkioDeviceWriteIops) > 0 {
		for _, e := range m.BlkioDeviceWriteIops {
			l = e.Size()
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	if m.CpuPeriod != 0 {
		n += 1 + sovContainer(uint64(m.CpuPeriod))
	}
	if m.CpuQuota != 0 {
		n += 1 + sovContainer(uint64(m.CpuQuota))
	}
	if m.CpuRealtimePeriod != 0 {
		n += 1 + sovContainer(uint64(m.CpuRealtimePeriod))
	}
	if m.CpuRealtimeRuntime != 0 {
		n += 1 + sovContainer(uint64(m.CpuRealtimeRuntime))
	}
	l = len(m.CpusetCpus)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	l = len(m.CpusetMems)
	if l > 0 {
		n += 2 + l + sovContainer(uint64(l))
	}
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 2 + l + sovContainer(uint64(l))
		}
	}
	if len(m.DeviceCgroupRules) > 0 {
		for _, s := range m.DeviceCgroupRules {
			l = len(s)
			n += 2 + l + sovContainer(uint64(l))
		}
	}
	if m.DiskQuota != 0 {
		n += 2 + sovContainer(uint64(m.DiskQuota))
	}
	if m.KernelMemory != 0 {
		n += 2 + sovContainer(uint64(m.KernelMemory))
	}
	if m.MemoryReservation != 0 {
		n += 2 + sovContainer(uint64(m.MemoryReservation))
	}
	if m.MemorySwap != 0 {
		n += 2 + sovContainer(uint64(m.MemorySwap))
	}
	if m.MemorySwappiness != 0 {
		n += 2 + sovContainer(uint64(m.MemorySwappiness))
	}
	if m.OomKillDisable {
		n += 3
	}
	if m.PidsLimit != 0 {
		n += 2 + sovContainer(uint64(m.PidsLimit))
	}
	if len(m.Ulimits) > 0 {
		for _, e := range m.Ulimits {
			l = e.Size()
			n += 2 + l + sovContainer(uint64(l))
		}
	}
	if m.CpuCount != 0 {
		n += 2 + sovContainer(uint64(m.CpuCount))
	}
	if m.CpuPercent != 0 {
		n += 2 + sovContainer(uint64(m.CpuPercent))
	}
	if m.IoMaximumIops != 0 {
		n += 2 + sovContainer(uint64(m.IoMaximumIops))
	}
	if m.IoMaximumBandwidth != 0 {
		n += 2 + sovContainer(uint64(m.IoMaximumBandwidth))
	}
	return n
}

func (m *HostConfig) Size() (n int) {
	var l int
	_ = l
	if len(m.Binds) > 0 {
		for _, s := range m.Binds {
			l = len(s)
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	l = len(m.ContainerIdFile)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	if m.LogConfig != nil {
		l = m.LogConfig.Size()
		n += 1 + l + sovContainer(uint64(l))
	}
	l = len(m.NetworkMode)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	if m.PortBindings != nil {
		l = m.PortBindings.Size()
		n += 1 + l + sovContainer(uint64(l))
	}
	if m.RestartPolicy != nil {
		l = m.RestartPolicy.Size()
		n += 1 + l + sovContainer(uint64(l))
	}
	if m.AutoRemove {
		n += 2
	}
	l = len(m.VolumeDriver)
	if l > 0 {
		n += 1 + l + sovContainer(uint64(l))
	}
	if len(m.VolumesFrom) > 0 {
		for _, s := range m.VolumesFrom {
			l = len(s)
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	if len(m.CapAdd) > 0 {
		for _, s := range m.CapAdd {
			l = len(s)
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	if len(m.CapDrop) > 0 {
		for _, s := range m.CapDrop {
			l = len(s)
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	if len(m.Dns) > 0 {
		for _, s := range m.Dns {
			l = len(s)
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	if len(m.DnsOptions) > 0 {
		for _, s := range m.DnsOptions {
			l = len(s)
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	if len(m.DnsSearch) > 0 {
		for _, s := range m.DnsSearch {
			l = len(s)
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	if len(m.ExtraHosts) > 0 {
		for _, s := range m.ExtraHosts {
			l = len(s)
			n += 1 + l + sovContainer(uint64(l))
		}
	}
	if len(m.GroupAdd) > 0 {
		for _, s := range m.GroupAdd {
			l = len(s)
			n += 2 + l + sovContainer(uint64(l))
		}
	}
	l = len(m.IpcMode)
	if l > 0 {
		n += 2 + l + sovContainer(uint64(l))
	}
	l = len(m.Cgroup)
	if l > 0 {
		n += 2 + l + sovContainer(uint64(l))
	}
	if len(m.Links) > 0 {
		for _, s := range m.Links {
			l = len(s)
			n += 2 + l + sovContainer(uint64(l))
		}
	}
	if m.OomScoreAdj != 0 {
		n += 2 + sovContainer(uint64(m.OomScoreAdj))
	}
	l = len(m.PidMode)
	if l > 0 {
		n += 2 + l + sovContainer(uint64(l))
	}
	if m.Privileged {
		n += 3
	}
	if m.PublishAllPorts {
		n += 3
	}
	if m.ReadonlyRootfs {
		n += 3
	}
	if len(m.SecurityOpt) > 0 {
		for _, s := range m.SecurityOpt {
			l = len(s)
			n += 2 + l + sovContainer(uint64(l))
		}
	}
	if len(m.StorageOpt) > 0 {
		for k, v := range m.StorageOpt {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovContainer(uint64(len(k))) + 1 + len(v) + sovContainer(uint64(len(v)))
			n += mapEntrySize + 2 + sovContainer(uint64(mapEntrySize))
		}
	}
	if len(m.Tmpfs) > 0 {
		for k, v := range m.Tmpfs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovContainer(uint64(len(k))) + 1 + len(v) + sovContainer(uint64(len(v)))
			n += mapEntrySize + 2 + sovContainer(uint64(mapEntrySize))
		}
	}
	l = len(m.UtsMode)
	if l > 0 {
		n += 2 + l + sovContainer(uint64(l))
	}
	l = len(m.UsernsMode)
	if l > 0 {
		n += 2 + l + sovContainer(uint64(l))
	}
	if m.ShmSize != 0 {
		n += 2 + sovContainer(uint64(m.ShmSize))
	}
	if len(m.Sysctls) > 0 {
		for k, v := range m.Sysctls {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovContainer(uint64(len(k))) + 1 + len(v) + sovContainer(uint64(len(v)))
			n += mapEntrySize + 2 + sovContainer(uint64(mapEntrySize))
		}
	}
	l = len(m.Runtime)
	if l > 0 {
		n += 2 + l + sovContainer(uint64(l))
	}
	if m.ConsoleSizeHeight != 0 {
		n += 2 + sovContainer(uint64(m.ConsoleSizeHeight))
	}
	if m.ConsoleSizeWidth != 0 {
		n += 2 + sovContainer(uint64(m.ConsoleSizeWidth))
	}
	l = len(m.Isolation)
	if l > 0 {
		n += 2 + l + sovContainer(uint64(l))
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 2 + l + sovContainer(uint64(l))
	}
	if len(m.Mounts) > 0 {
		for _, e := range m.Mounts {
			l = e.Size()
			n += 2 + l + sovContainer(uint64(l))
		}
	}
	if len(m.MaskedPaths) > 0 {
		for _, s := range m.MaskedPaths {
			l = len(s)
			n += 2 + l + sovContainer(uint64(l))
		}
	}
	if len(m.ReadonlyPaths) > 0 {
		for _, s := range m.ReadonlyPaths {
			l = len(s)
			n += 2 + l + sovContainer(uint64(l))
		}
	}
	if m.Init {
		n += 3
	}
	return n
}

func sovContainer(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozContainer(x uint64) (n int) {
	return sovContainer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HealthConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Test", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Test = append(m.Test, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalSeconds", wireType)
			}
			m.IntervalSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntervalSeconds |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutSeconds", wireType)
			}
			m.TimeoutSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutSeconds |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPeriod", wireType)
			}
			m.StartPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPeriod |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retries", wireType)
			}
			m.Retries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retries |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domainname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domainname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachStdin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AttachStdin = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachStdout", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AttachStdout = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachStderr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AttachStderr = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExposedPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExposedPorts == nil {
				m.ExposedPorts = &nat.PortSet{}
			}
			if err := m.ExposedPorts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tty = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenStdin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OpenStdin = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StdinOnce", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StdinOnce = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = append(m.Env, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmd = append(m.Cmd, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Healthcheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Healthcheck == nil {
				m.Healthcheck = &HealthConfig{}
			}
			if err := m.Healthcheck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgsEscaped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ArgsEscaped = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Volumes == nil {
				m.Volumes = make(map[string]*Config_VoidStruct)
			}
			var mapkey string
			var mapvalue *Config_VoidStruct
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowContainer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowContainer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthContainer
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowContainer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthContainer
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthContainer
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Config_VoidStruct{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipContainer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthContainer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Volumes[mapkey] = mapvalue
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkingDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entrypoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entrypoint = append(m.Entrypoint, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkDisabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NetworkDisabled = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnBuild", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnBuild = append(m.OnBuild, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowContainer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowContainer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthContainer
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowContainer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthContainer
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipContainer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthContainer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopSignal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StopSignal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopTimeout", wireType)
			}
			m.StopTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StopTimeout |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shell", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shell = append(m.Shell, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Config_VoidStruct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VoidStruct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VoidStruct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerCreateCreatedBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerCreateCreatedBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerCreateCreatedBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Warnings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Warnings = append(m.Warnings, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathOnHost", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathOnHost = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathInContainer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathInContainer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CgroupPermissions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CgroupPermissions = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestartPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestartPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestartPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumRetryCount", wireType)
			}
			m.MaximumRetryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumRetryCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowContainer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowContainer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthContainer
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowContainer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthContainer
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipContainer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthContainer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Config[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resources) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resources: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resources: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuShares", wireType)
			}
			m.CpuShares = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuShares |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NanoCpus", wireType)
			}
			m.NanoCpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NanoCpus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CgroupParent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CgroupParent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlkioWeight", wireType)
			}
			m.BlkioWeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlkioWeight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlkioWeightDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlkioWeightDevice = append(m.BlkioWeightDevice, &blkiodev.WeightDevice{})
			if err := m.BlkioWeightDevice[len(m.BlkioWeightDevice)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlkioDeviceReadBps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlkioDeviceReadBps = append(m.BlkioDeviceReadBps, &blkiodev.ThrottleDevice{})
			if err := m.BlkioDeviceReadBps[len(m.BlkioDeviceReadBps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlkioDeviceWriteBps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlkioDeviceWriteBps = append(m.BlkioDeviceWriteBps, &blkiodev.ThrottleDevice{})
			if err := m.BlkioDeviceWriteBps[len(m.BlkioDeviceWriteBps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlkioDeviceReadIops", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlkioDeviceReadIops = append(m.BlkioDeviceReadIops, &blkiodev.ThrottleDevice{})
			if err := m.BlkioDeviceReadIops[len(m.BlkioDeviceReadIops)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlkioDeviceWriteIops", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlkioDeviceWriteIops = append(m.BlkioDeviceWriteIops, &blkiodev.ThrottleDevice{})
			if err := m.BlkioDeviceWriteIops[len(m.BlkioDeviceWriteIops)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuPeriod", wireType)
			}
			m.CpuPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuPeriod |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuQuota", wireType)
			}
			m.CpuQuota = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuQuota |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuRealtimePeriod", wireType)
			}
			m.CpuRealtimePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuRealtimePeriod |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuRealtimeRuntime", wireType)
			}
			m.CpuRealtimeRuntime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuRealtimeRuntime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpusetCpus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpusetCpus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpusetMems", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpusetMems = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, &DeviceMapping{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceCgroupRules", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceCgroupRules = append(m.DeviceCgroupRules, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskQuota", wireType)
			}
			m.DiskQuota = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskQuota |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelMemory", wireType)
			}
			m.KernelMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KernelMemory |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryReservation", wireType)
			}
			m.MemoryReservation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryReservation |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemorySwap", wireType)
			}
			m.MemorySwap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemorySwap |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemorySwappiness", wireType)
			}
			m.MemorySwappiness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemorySwappiness |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OomKillDisable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OomKillDisable = bool(v != 0)
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PidsLimit", wireType)
			}
			m.PidsLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PidsLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ulimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ulimits = append(m.Ulimits, &units.Ulimit{})
			if err := m.Ulimits[len(m.Ulimits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuCount", wireType)
			}
			m.CpuCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuPercent", wireType)
			}
			m.CpuPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuPercent |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoMaximumIops", wireType)
			}
			m.IoMaximumIops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IoMaximumIops |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoMaximumBandwidth", wireType)
			}
			m.IoMaximumBandwidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IoMaximumBandwidth |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Binds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Binds = append(m.Binds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerIdFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerIdFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LogConfig == nil {
				m.LogConfig = &LogConfig{}
			}
			if err := m.LogConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortBindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortBindings == nil {
				m.PortBindings = &nat.PortMap{}
			}
			if err := m.PortBindings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestartPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RestartPolicy == nil {
				m.RestartPolicy = &RestartPolicy{}
			}
			if err := m.RestartPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoRemove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoRemove = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeDriver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeDriver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumesFrom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumesFrom = append(m.VolumesFrom, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapAdd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapAdd = append(m.CapAdd, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapDrop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapDrop = append(m.CapDrop, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dns = append(m.Dns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsOptions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsOptions = append(m.DnsOptions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsSearch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsSearch = append(m.DnsSearch, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraHosts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraHosts = append(m.ExtraHosts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupAdd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupAdd = append(m.GroupAdd, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpcMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpcMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cgroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cgroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Links = append(m.Links, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OomScoreAdj", wireType)
			}
			m.OomScoreAdj = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OomScoreAdj |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PidMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PidMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Privileged = bool(v != 0)
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishAllPorts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PublishAllPorts = bool(v != 0)
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadonlyRootfs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadonlyRootfs = bool(v != 0)
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityOpt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityOpt = append(m.SecurityOpt, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageOpt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageOpt == nil {
				m.StorageOpt = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowContainer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowContainer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthContainer
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowContainer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthContainer
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipContainer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthContainer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.StorageOpt[mapkey] = mapvalue
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tmpfs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tmpfs == nil {
				m.Tmpfs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowContainer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowContainer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthContainer
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowContainer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthContainer
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipContainer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthContainer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tmpfs[mapkey] = mapvalue
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UtsMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UtsMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsernsMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsernsMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShmSize", wireType)
			}
			m.ShmSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShmSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sysctls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sysctls == nil {
				m.Sysctls = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowContainer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowContainer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthContainer
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowContainer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthContainer
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipContainer(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthContainer
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Sysctls[mapkey] = mapvalue
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Runtime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Runtime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsoleSizeHeight", wireType)
			}
			m.ConsoleSizeHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConsoleSizeHeight |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsoleSizeWidth", wireType)
			}
			m.ConsoleSizeWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConsoleSizeWidth |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isolation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Isolation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &Resources{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mounts = append(m.Mounts, &mount.Mount{})
			if err := m.Mounts[len(m.Mounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaskedPaths", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaskedPaths = append(m.MaskedPaths, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadonlyPaths", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContainer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadonlyPaths = append(m.ReadonlyPaths, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Init", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Init = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipContainer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthContainer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipContainer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowContainer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowContainer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthContainer
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowContainer
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipContainer(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthContainer = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowContainer   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("pb/moby/container/container.proto", fileDescriptorContainer) }

var fileDescriptorContainer = []byte{
	// 2178 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x58, 0xcd, 0x72, 0x14, 0xc9,
	0xf1, 0xff, 0x0f, 0x42, 0x1f, 0x93, 0x33, 0xa3, 0x8f, 0x92, 0x90, 0x1a, 0x01, 0x42, 0x68, 0x97,
	0x45, 0x7f, 0xdb, 0xab, 0x5d, 0x6b, 0xc3, 0x0e, 0x76, 0xc3, 0x0e, 0x07, 0x12, 0x4b, 0x40, 0x2c,
	0x0a, 0xe1, 0x1e, 0x6c, 0x7c, 0xeb, 0x68, 0x75, 0x17, 0x33, 0xb5, 0xea, 0xae, 0x6a, 0x57, 0x55,
	0x4b, 0xcc, 0x3e, 0x83, 0x8f, 0x3e, 0xf8, 0x3d, 0x7c, 0xf3, 0x13, 0xf8, 0xe8, 0x47, 0x70, 0xe0,
	0x77, 0xf0, 0xd5, 0x8e, 0xcc, 0xac, 0x9e, 0x69, 0x01, 0x8e, 0x0d, 0x0e, 0x0c, 0x55, 0xbf, 0xfc,
	0x55, 0x56, 0x56, 0x56, 0x56, 0x66, 0xb6, 0xe0, 0x5e, 0x75, 0xf6, 0x45, 0x69, 0xce, 0x26, 0x5f,
	0x64, 0x46, 0xfb, 0x54, 0x69, 0x69, 0x67, 0xa3, 0x83, 0xca, 0x1a, 0x6f, 0x44, 0x77, 0x0a, 0x6c,
	0xdf, 0x6d, 0xd8, 0x67, 0xc5, 0xb9, 0x32, 0xb9, 0xbc, 0x98, 0x0e, 0x98, 0xbb, 0x7d, 0xb3, 0x21,
	0xd4, 0x5a, 0x79, 0xc7, 0xbf, 0x41, 0x74, 0xa3, 0x11, 0xe9, 0xd4, 0xe3, 0xbf, 0x77, 0x57, 0x94,
	0xa6, 0xd6, 0x9e, 0x7f, 0x59, 0xb4, 0xf7, 0xd7, 0x0e, 0xf4, 0x9f, 0xca, 0xb4, 0xf0, 0xe3, 0x63,
	0xa3, 0x5f, 0xab, 0x91, 0x10, 0x70, 0xdd, 0x4b, 0xe7, 0xa3, 0xce, 0xee, 0xdc, 0x7e, 0x37, 0xa6,
	0xb1, 0xf8, 0x7f, 0x58, 0x55, 0xda, 0x4b, 0x7b, 0x91, 0x16, 0x89, 0x93, 0x99, 0xd1, 0xb9, 0x8b,
	0xae, 0xed, 0x76, 0xf6, 0xe7, 0xe2, 0x95, 0x06, 0x1f, 0x32, 0x2c, 0x1e, 0xc0, 0x8a, 0x57, 0xa5,
	0x34, 0xb5, 0x9f, 0x32, 0xe7, 0x88, 0xb9, 0x1c, 0xe0, 0x86, 0x78, 0x0f, 0xfa, 0xce, 0xa7, 0xd6,
	0x27, 0x95, 0xb4, 0xca, 0xe4, 0xd1, 0x75, 0x62, 0xf5, 0x08, 0x7b, 0x41, 0x90, 0x88, 0x60, 0xd1,
	0x4a, 0x6f, 0x95, 0x74, 0xd1, 0xfc, 0x6e, 0x67, 0x7f, 0x3e, 0x6e, 0xa6, 0x7b, 0xff, 0x5e, 0x84,
	0x85, 0x60, 0xef, 0x36, 0x2c, 0x8d, 0x8d, 0xf3, 0x3a, 0x2d, 0x65, 0xd4, 0xd9, 0xed, 0xec, 0x77,
	0xe3, 0xe9, 0x5c, 0xec, 0x00, 0xe4, 0xa6, 0x4c, 0x95, 0x26, 0xe9, 0x35, 0x92, 0xb6, 0x10, 0x3c,
	0x6b, 0xed, 0xa4, 0x25, 0x0b, 0xbb, 0x31, 0x8d, 0xd1, 0xae, 0xd4, 0xfb, 0x34, 0x1b, 0x27, 0xce,
	0xe7, 0x4a, 0x93, 0x5d, 0x4b, 0x71, 0x8f, 0xb1, 0x21, 0x42, 0xe2, 0x13, 0x18, 0xcc, 0x28, 0xa6,
	0xf6, 0x64, 0xdd, 0x52, 0xdc, 0x9f, 0x72, 0x4c, 0xed, 0xaf, 0x92, 0xa4, 0xb5, 0xd1, 0xc2, 0x3b,
	0x24, 0x69, 0xad, 0xf8, 0x39, 0x0c, 0xe4, 0x9b, 0xca, 0x38, 0x99, 0x27, 0x95, 0xb1, 0xde, 0x45,
	0x8b, 0xbb, 0x9d, 0xfd, 0xde, 0x61, 0xff, 0x00, 0xef, 0xee, 0x85, 0xb1, 0x7e, 0x28, 0x7d, 0xdc,
	0x0f, 0x14, 0x9c, 0x3b, 0xb1, 0x0a, 0x73, 0xde, 0x4f, 0xa2, 0x25, 0xd2, 0x86, 0x43, 0x71, 0x07,
	0xc0, 0x54, 0x52, 0x07, 0x7b, 0xbb, 0x24, 0xe8, 0x22, 0xc2, 0xd6, 0xde, 0x01, 0x20, 0x49, 0x62,
	0x74, 0x26, 0x23, 0x60, 0x31, 0x21, 0xa7, 0x3a, 0x93, 0xa8, 0x4f, 0xea, 0x8b, 0xa8, 0x47, 0xd7,
	0x8d, 0x43, 0x44, 0xb2, 0x32, 0x8f, 0xfa, 0x8c, 0x64, 0x65, 0x2e, 0xbe, 0x86, 0xde, 0x98, 0x62,
	0x24, 0x1b, 0xcb, 0xec, 0x3c, 0x1a, 0x90, 0x91, 0x5b, 0x07, 0xb3, 0x20, 0x6e, 0x47, 0x50, 0xdc,
	0xe6, 0x92, 0x3b, 0xed, 0xc8, 0x25, 0xd2, 0x65, 0x69, 0x25, 0xf3, 0x68, 0x39, 0xb8, 0xd3, 0x8e,
	0xdc, 0xb7, 0x0c, 0x89, 0x0d, 0x98, 0x57, 0x65, 0x3a, 0x92, 0xd1, 0x0a, 0x5d, 0x03, 0x4f, 0xc4,
	0x43, 0x58, 0xbc, 0x30, 0x45, 0x5d, 0x4a, 0x17, 0xad, 0xee, 0xce, 0xed, 0xf7, 0x0e, 0x77, 0x5a,
	0xfb, 0xf1, 0x4e, 0x07, 0xbf, 0x67, 0xc2, 0xb7, 0xda, 0xdb, 0x49, 0xdc, 0xd0, 0xc5, 0x5d, 0xe8,
	0x5d, 0x1a, 0x7b, 0xae, 0xf4, 0x28, 0xc9, 0x95, 0x8d, 0xd6, 0xf8, 0xda, 0x03, 0xf4, 0x58, 0x59,
	0x0c, 0x0b, 0x89, 0x4b, 0x2a, 0xa3, 0xb4, 0x8f, 0x04, 0x9d, 0xb3, 0x85, 0x60, 0xb8, 0x6b, 0xe9,
	0x71, 0x41, 0x92, 0x2b, 0x97, 0x9e, 0x15, 0x32, 0x8f, 0xd6, 0xc9, 0xee, 0x95, 0x80, 0x3f, 0x0e,
	0x30, 0xee, 0x55, 0xa6, 0x59, 0x92, 0xe6, 0xb9, 0x95, 0xce, 0x45, 0x1b, 0xbc, 0x57, 0x99, 0x66,
	0x8f, 0x18, 0x11, 0x37, 0x61, 0xc9, 0xe8, 0xe4, 0xac, 0x56, 0x45, 0x1e, 0xdd, 0xa0, 0x9d, 0x16,
	0x8d, 0x3e, 0xc2, 0xa9, 0xf8, 0x05, 0x2c, 0x14, 0xe9, 0x99, 0x2c, 0x5c, 0xb4, 0x49, 0x07, 0xbc,
	0xf3, 0xfe, 0x01, 0x9f, 0x93, 0x9c, 0xcf, 0x17, 0xc8, 0xb8, 0xa5, 0xf3, 0xa6, 0x4a, 0x9c, 0x1a,
	0xe9, 0xb4, 0x88, 0xb6, 0x78, 0x4b, 0x84, 0x86, 0x84, 0xf0, 0xcb, 0x32, 0x55, 0x12, 0x1e, 0x5c,
	0x14, 0xd1, 0xdb, 0xa1, 0x45, 0x2f, 0x19, 0x42, 0x97, 0xbb, 0xb1, 0x2c, 0x8a, 0xe8, 0x26, 0x99,
	0xc4, 0x93, 0xed, 0x3f, 0x40, 0xbf, 0xed, 0x51, 0x0c, 0x84, 0x73, 0x39, 0x09, 0xaf, 0x0a, 0x87,
	0xe2, 0x10, 0xe6, 0x2f, 0xd2, 0xa2, 0xe6, 0xb7, 0xd4, 0x3b, 0xbc, 0xfd, 0xa1, 0x2b, 0x51, 0xf9,
	0xd0, 0xdb, 0x3a, 0xf3, 0x31, 0x53, 0xbf, 0xb9, 0xf6, 0xb0, 0xb3, 0xfd, 0x35, 0xf4, 0x5a, 0x47,
	0xf9, 0x80, 0xe2, 0x8d, 0xb6, 0xe2, 0x6e, 0x7b, 0x69, 0x1f, 0x60, 0xa6, 0x73, 0xef, 0x29, 0x6c,
	0x1f, 0x37, 0x5b, 0x1e, 0x5b, 0x99, 0x7a, 0xc9, 0xbf, 0xf9, 0x91, 0xc9, 0x27, 0x62, 0x19, 0xae,
	0xa9, 0x3c, 0xa8, 0xbd, 0xa6, 0x72, 0xcc, 0x0d, 0x97, 0xa9, 0xd5, 0x4a, 0x8f, 0x30, 0x5f, 0xe1,
	0x49, 0xa7, 0xf3, 0xbd, 0x3f, 0x75, 0x60, 0xf0, 0x58, 0x5e, 0xa8, 0x4c, 0x9e, 0xa4, 0x55, 0xa5,
	0xf4, 0x48, 0xec, 0x42, 0xbf, 0x4a, 0xfd, 0x38, 0x31, 0x3a, 0xc1, 0x0c, 0x12, 0xf4, 0x00, 0x62,
	0xa7, 0xfa, 0xa9, 0x71, 0x5e, 0xfc, 0x04, 0xd6, 0x88, 0xa1, 0x74, 0x32, 0x3d, 0x78, 0xb0, 0x78,
	0x05, 0x05, 0xcf, 0xf4, 0xd4, 0x38, 0xf1, 0x39, 0x88, 0x6c, 0x64, 0x4d, 0x5d, 0x61, 0x82, 0x2b,
	0x95, 0x73, 0xca, 0x68, 0x17, 0x32, 0xcd, 0x1a, 0x4b, 0x5e, 0xcc, 0x04, 0x7b, 0x43, 0x18, 0xc4,
	0x92, 0x93, 0x9f, 0x29, 0x54, 0x36, 0xc1, 0xdc, 0xd4, 0xca, 0x69, 0x34, 0x16, 0x07, 0xb0, 0x5e,
	0xa6, 0x6f, 0x54, 0x59, 0x97, 0x09, 0x66, 0xc2, 0x49, 0x92, 0x61, 0x26, 0x27, 0x0b, 0xe6, 0xe3,
	0xb5, 0x20, 0x8a, 0x51, 0x72, 0x8c, 0x82, 0xbd, 0x3f, 0x77, 0xa0, 0xfb, 0xdc, 0x8c, 0x5a, 0x99,
	0x7d, 0x52, 0x4d, 0x35, 0xe2, 0x58, 0x3c, 0x84, 0x85, 0x8c, 0xa4, 0xe4, 0x9f, 0xde, 0xe1, 0x6e,
	0xeb, 0x46, 0xa7, 0x2b, 0xc3, 0xdd, 0x86, 0x30, 0x64, 0x3e, 0x5e, 0x69, 0x0b, 0xfe, 0x98, 0x2b,
	0xdd, 0xfb, 0x1b, 0x40, 0x37, 0x96, 0xce, 0xd4, 0x36, 0x93, 0x0e, 0xf3, 0x53, 0x56, 0xd5, 0x89,
	0x1b, 0xa7, 0x56, 0x3a, 0x52, 0x30, 0x17, 0x77, 0xb3, 0xaa, 0x1e, 0x12, 0x20, 0x36, 0x61, 0xa1,
	0x94, 0xa5, 0xb1, 0x93, 0x50, 0x71, 0xc2, 0x4c, 0xdc, 0x82, 0xae, 0x4e, 0xb5, 0x49, 0xb2, 0xaa,
	0x6e, 0x4a, 0xcc, 0x12, 0x02, 0xc7, 0x55, 0xed, 0x30, 0xf9, 0x36, 0xce, 0x4f, 0xad, 0xd4, 0x9e,
	0xb2, 0x78, 0x37, 0xee, 0x07, 0xbf, 0x13, 0x86, 0xef, 0x84, 0x2a, 0x6b, 0x72, 0x29, 0xd5, 0x68,
	0xec, 0x43, 0x8d, 0xe9, 0x11, 0xf6, 0x8a, 0x20, 0xf1, 0x04, 0xd6, 0xdb, 0x94, 0x24, 0xa7, 0x80,
	0x89, 0x16, 0xc8, 0x57, 0x9b, 0x07, 0xd3, 0xc2, 0xcc, 0x74, 0x0e, 0xa7, 0x78, 0xad, 0xa5, 0x81,
	0x21, 0xf1, 0x1d, 0xdc, 0x60, 0x3d, 0xac, 0x20, 0xb1, 0x32, 0xcd, 0x93, 0xb3, 0x0a, 0xf3, 0x3d,
	0x6a, 0x8a, 0x66, 0x9a, 0x5e, 0x8e, 0xad, 0xf1, 0xbe, 0x90, 0x41, 0x97, 0x20, 0x41, 0x98, 0xc8,
	0x34, 0x3f, 0xaa, 0x9c, 0x38, 0x81, 0xcd, 0x2b, 0xca, 0x2e, 0xad, 0xf2, 0x92, 0xb4, 0x2d, 0xfd,
	0x88, 0xb6, 0xf5, 0x96, 0xb6, 0x57, 0xb8, 0xea, 0x43, 0xea, 0xc8, 0x36, 0x65, 0x2a, 0x17, 0x75,
	0x3f, 0x42, 0x1d, 0x1a, 0xf7, 0xcc, 0x54, 0x4e, 0x9c, 0xc2, 0xd6, 0x07, 0xac, 0x23, 0x7d, 0xf0,
	0x23, 0xfa, 0x36, 0xde, 0x35, 0x8f, 0x14, 0x86, 0xf8, 0x08, 0x6d, 0x42, 0x6f, 0x1a, 0x1f, 0xa1,
	0x49, 0xb8, 0x05, 0x38, 0x49, 0xfe, 0x58, 0x1b, 0x9f, 0x46, 0x7d, 0x8e, 0x83, 0xac, 0xaa, 0x7f,
	0x8b, 0x73, 0x7c, 0x30, 0x28, 0xb4, 0x58, 0x90, 0x54, 0x29, 0x1b, 0x25, 0x03, 0xa2, 0xad, 0x65,
	0x55, 0x1d, 0x07, 0x49, 0x50, 0xf6, 0x25, 0x6c, 0x5c, 0xe1, 0xdb, 0x5a, 0xe3, 0xff, 0x54, 0xb5,
	0xe6, 0x62, 0xd1, 0x5a, 0x10, 0xb3, 0x04, 0xb3, 0x31, 0x46, 0xa0, 0xf4, 0x1c, 0x88, 0x5c, 0xc2,
	0x80, 0x21, 0x0a, 0xc5, 0x19, 0xa1, 0x94, 0x25, 0xd6, 0xb2, 0x16, 0xe1, 0x44, 0x96, 0x4e, 0x1c,
	0xc2, 0x22, 0xbb, 0xca, 0x45, 0x6b, 0xc1, 0x41, 0xb3, 0x37, 0x78, 0x25, 0x43, 0xc5, 0x0d, 0x11,
	0xcf, 0x15, 0xdc, 0x1b, 0xc2, 0xdc, 0xd6, 0x85, 0x74, 0xa1, 0x94, 0xad, 0xb1, 0xe8, 0x98, 0x24,
	0x31, 0x0a, 0xd0, 0x87, 0xb9, 0x72, 0xe7, 0xc1, 0x4b, 0xeb, 0xec, 0x43, 0x44, 0xd8, 0x4d, 0x9f,
	0xc0, 0xe0, 0x5c, 0x5a, 0x2d, 0x8b, 0x24, 0x3c, 0xb5, 0x0d, 0x62, 0xf4, 0x19, 0x3c, 0xe1, 0x07,
	0xf7, 0x39, 0x08, 0x96, 0x26, 0x56, 0x3a, 0xec, 0xf9, 0xbc, 0x32, 0x3a, 0xba, 0xc1, 0xae, 0x64,
	0x49, 0x3c, 0x13, 0x50, 0x65, 0x64, 0xba, 0xbb, 0x4c, 0xab, 0x68, 0x93, 0x78, 0xc0, 0xd0, 0xf0,
	0x32, 0xad, 0xc4, 0x4f, 0x61, 0xad, 0x45, 0xa8, 0x94, 0xc6, 0x02, 0xba, 0x45, 0xb4, 0xd5, 0x19,
	0x8d, 0x71, 0xb1, 0x0f, 0xab, 0xc6, 0x94, 0xc9, 0xb9, 0x2a, 0x8a, 0xa6, 0x26, 0x53, 0x5d, 0x5b,
	0x8a, 0x97, 0x8d, 0x29, 0xbf, 0x53, 0x45, 0x11, 0x4a, 0x32, 0x1e, 0xb5, 0x52, 0xb9, 0x4b, 0x0a,
	0x55, 0x2a, 0x1f, 0xdd, 0xe4, 0xa3, 0x22, 0xf2, 0x1c, 0x01, 0xf1, 0x00, 0x16, 0x6b, 0x12, 0xb9,
	0x68, 0x9b, 0xbc, 0x3d, 0x38, 0xe0, 0x06, 0xfa, 0x77, 0x84, 0xc6, 0x8d, 0xb4, 0x89, 0x2b, 0xce,
	0xb0, 0xb7, 0xa6, 0x71, 0x45, 0x89, 0x35, 0x5c, 0x2a, 0x86, 0x53, 0x86, 0xd9, 0xe5, 0x36, 0x1f,
	0x8e, 0x83, 0x12, 0x11, 0xf1, 0x19, 0xac, 0x28, 0x93, 0x34, 0xc9, 0x9a, 0xa2, 0xff, 0xce, 0x6e,
	0x67, 0xff, 0x7a, 0x3c, 0x50, 0xe6, 0x84, 0x51, 0x0a, 0xee, 0x2f, 0x61, 0xa3, 0xc5, 0x3b, 0x4b,
	0x75, 0x7e, 0xa9, 0x72, 0x3f, 0x8e, 0x76, 0x88, 0x2c, 0xa6, 0xe4, 0xa3, 0x46, 0xb2, 0xf7, 0x9f,
	0x3e, 0x00, 0x16, 0xa3, 0x90, 0xd4, 0x37, 0x60, 0xfe, 0x4c, 0x61, 0x97, 0xcd, 0xfd, 0x3a, 0x4f,
	0xb0, 0x50, 0x4d, 0x63, 0x28, 0x51, 0x79, 0xf2, 0x5a, 0x15, 0x4d, 0x1e, 0x5e, 0x99, 0x0a, 0x9e,
	0xe5, 0x4f, 0x54, 0x21, 0xc5, 0x57, 0x00, 0x85, 0x19, 0x25, 0xa1, 0x0c, 0xcc, 0x51, 0x61, 0xdf,
	0xf8, 0x50, 0x19, 0x88, 0xbb, 0xc5, 0xb4, 0x96, 0xdc, 0x83, 0x7e, 0xd3, 0x22, 0x95, 0x26, 0x97,
	0x21, 0xbf, 0xf6, 0x02, 0x76, 0x62, 0x72, 0x89, 0xbd, 0x2d, 0xf6, 0xb4, 0x09, 0x5a, 0x44, 0x15,
	0x78, 0xfe, 0x9d, 0xde, 0xf6, 0x24, 0xad, 0xe2, 0x3e, 0x52, 0x8e, 0x02, 0x43, 0xfc, 0x06, 0x96,
	0xad, 0x0c, 0x5f, 0x05, 0x54, 0x05, 0xa9, 0x69, 0xbe, 0xfa, 0x22, 0xae, 0x54, 0xc9, 0x78, 0x60,
	0xaf, 0x14, 0xcd, 0xbb, 0xd0, 0x4b, 0x6b, 0x6f, 0x12, 0x2b, 0x4b, 0x73, 0x21, 0xa9, 0x9b, 0x5e,
	0x8a, 0x01, 0xa1, 0x98, 0x10, 0x8c, 0x74, 0x6e, 0x13, 0x93, 0xdc, 0xaa, 0x0b, 0x69, 0xa9, 0x8f,
	0xee, 0xc6, 0x7d, 0x06, 0x1f, 0x13, 0x86, 0x87, 0x0b, 0xbd, 0x64, 0xf2, 0xda, 0x9a, 0x92, 0xf2,
	0x60, 0x37, 0xee, 0x05, 0xec, 0x89, 0x35, 0xa5, 0xd8, 0x82, 0xc5, 0x2c, 0xad, 0xb0, 0xef, 0xa3,
	0xac, 0xd6, 0x8d, 0x17, 0xb2, 0xb4, 0x7a, 0x94, 0xe7, 0xd8, 0xef, 0xa1, 0x20, 0xb7, 0xa6, 0x0a,
	0x3d, 0x35, 0x12, 0x1f, 0x5b, 0x53, 0x61, 0x89, 0xcc, 0xb5, 0x6b, 0xfa, 0xea, 0x5c, 0x53, 0x6e,
	0xc8, 0xb5, 0x4b, 0x4c, 0xe5, 0xa9, 0x39, 0x18, 0x70, 0x27, 0x9a, 0x6b, 0x77, 0xca, 0x08, 0xbd,
	0x5b, 0xed, 0x12, 0x27, 0x53, 0x9b, 0x8d, 0xa3, 0x65, 0x92, 0x77, 0x73, 0xed, 0x86, 0x04, 0xe0,
	0x7a, 0xf9, 0xc6, 0xdb, 0x94, 0xfa, 0x15, 0x4c, 0x3e, 0xdc, 0xc9, 0x22, 0x84, 0x21, 0x42, 0x41,
	0xcc, 0xf9, 0x01, 0x0d, 0x5d, 0xe5, 0x0e, 0x88, 0x80, 0x60, 0xaa, 0xaa, 0x32, 0xbe, 0x3f, 0x6e,
	0x92, 0x17, 0x55, 0x95, 0xd1, 0xdd, 0x6d, 0xc2, 0x02, 0x27, 0x96, 0x48, 0x90, 0x20, 0xcc, 0x30,
	0xda, 0x0a, 0xa5, 0xcf, 0x5d, 0xb4, 0xce, 0xd1, 0x46, 0x13, 0xb1, 0x07, 0x03, 0x7c, 0x9c, 0x2e,
	0x33, 0x56, 0x26, 0x69, 0xfe, 0x3d, 0xa5, 0x8f, 0xf9, 0xb8, 0x67, 0x4c, 0x39, 0x44, 0xec, 0x51,
	0xfe, 0x3d, 0x6e, 0x56, 0xa9, 0x9c, 0x37, 0xbb, 0xc1, 0x9b, 0x55, 0x2a, 0xa7, 0xcd, 0x76, 0x00,
	0x2a, 0xab, 0x2e, 0x54, 0x21, 0x47, 0x32, 0xa7, 0x44, 0xb1, 0x14, 0xb7, 0x10, 0xea, 0xba, 0xea,
	0xb3, 0x42, 0xb9, 0x71, 0x92, 0x16, 0x45, 0xf8, 0x50, 0xda, 0xe2, 0x7e, 0x3c, 0x08, 0x1e, 0x15,
	0x05, 0x7f, 0x1d, 0x3d, 0x80, 0x15, 0xac, 0x5f, 0x46, 0x17, 0x93, 0xc4, 0x1a, 0xe3, 0x5f, 0xbb,
	0x26, 0x4d, 0x34, 0x70, 0x4c, 0x28, 0x35, 0xc9, 0x32, 0xab, 0xad, 0xf2, 0x13, 0xf4, 0x7f, 0x68,
	0x84, 0x7b, 0x0d, 0x76, 0x5a, 0x61, 0xf1, 0xc7, 0x9e, 0xd9, 0xa6, 0x23, 0x49, 0x0c, 0x4e, 0x17,
	0xf7, 0xdb, 0x5f, 0x3d, 0xd3, 0x67, 0x78, 0x30, 0x64, 0xe2, 0x69, 0xe5, 0xb9, 0x4b, 0x02, 0x37,
	0x05, 0xc4, 0x2f, 0x61, 0xde, 0x97, 0xd5, 0x6b, 0x17, 0xdd, 0x7a, 0xaf, 0xc5, 0x6a, 0x69, 0x78,
	0x89, 0x14, 0x5e, 0xcc, 0x74, 0x74, 0x59, 0xed, 0x1d, 0xbb, 0xec, 0x36, 0xbb, 0xac, 0xf6, 0x8e,
	0x5c, 0x76, 0x17, 0x7a, 0xf8, 0xb1, 0xaa, 0x83, 0xf4, 0x0e, 0x17, 0x15, 0x86, 0x88, 0x70, 0x13,
	0x96, 0xdc, 0xb8, 0x4c, 0x9c, 0xfa, 0x41, 0x52, 0x2e, 0x99, 0x8b, 0x17, 0xdd, 0xb8, 0x1c, 0xaa,
	0x1f, 0xa4, 0xf8, 0x15, 0x2c, 0xba, 0x89, 0xcb, 0x7c, 0xe1, 0xa2, 0xbb, 0x64, 0xd0, 0xde, 0xff,
	0x38, 0x12, 0x93, 0xc2, 0xc7, 0x55, 0x58, 0x42, 0xdf, 0xe4, 0xa1, 0x28, 0xee, 0xb2, 0x4d, 0x61,
	0x4a, 0xb5, 0xd6, 0x68, 0x67, 0x0a, 0x49, 0xdb, 0x26, 0x63, 0xee, 0xaa, 0xee, 0xed, 0x76, 0xf6,
	0x07, 0xf1, 0x5a, 0x10, 0xa1, 0x05, 0x4f, 0xb9, 0xb7, 0xfa, 0x19, 0x88, 0x2b, 0x7c, 0x4e, 0x7c,
	0x7b, 0x44, 0x5f, 0x6d, 0xd1, 0x5f, 0x21, 0x2e, 0x6e, 0x43, 0x57, 0x39, 0x53, 0x70, 0xd1, 0xf9,
	0x84, 0x76, 0x9e, 0x01, 0xe2, 0x10, 0xba, 0xb6, 0x69, 0x28, 0xa3, 0x4f, 0xdf, 0x4b, 0x61, 0xd3,
	0x66, 0x33, 0x9e, 0xd1, 0xc4, 0xa7, 0xb0, 0x40, 0x7f, 0x08, 0x71, 0xd1, 0x7d, 0x72, 0x43, 0xff,
	0x80, 0xff, 0x2e, 0x72, 0x82, 0xbf, 0x71, 0x90, 0x61, 0x9c, 0x94, 0xa9, 0x3b, 0xc7, 0x0f, 0xf4,
	0xd4, 0x8f, 0x5d, 0xf4, 0x19, 0xc7, 0x09, 0x63, 0x2f, 0x10, 0x12, 0xf7, 0x61, 0x1a, 0x5c, 0x81,
	0xf4, 0x80, 0x48, 0x83, 0x06, 0x65, 0x9a, 0x80, 0xeb, 0x4a, 0x2b, 0x1f, 0xed, 0x53, 0x3c, 0xd2,
	0x78, 0xfb, 0xd7, 0xb0, 0xf2, 0x4e, 0xe4, 0x7c, 0xd4, 0xb7, 0xd1, 0x43, 0x80, 0x59, 0xd8, 0x7c,
	0xd4, 0xca, 0x6f, 0xa0, 0xdf, 0xbe, 0xdf, 0x8f, 0x59, 0x7b, 0xb4, 0xfa, 0xf7, 0xb7, 0x3b, 0x9d,
	0x7f, 0xbc, 0xdd, 0xe9, 0xfc, 0xf3, 0xed, 0x4e, 0xe7, 0x2f, 0xff, 0xda, 0xf9, 0xbf, 0xb3, 0x05,
	0xfa, 0x5b, 0xd2, 0x57, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x52, 0x32, 0xeb, 0x09, 0xe9, 0x12,
	0x00, 0x00,
}
