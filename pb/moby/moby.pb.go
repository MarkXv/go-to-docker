// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pb/moby/moby.proto

/*
	Package moby is a generated protocol buffer package.

	It is generated from these files:
		pb/moby/moby.proto

	It has these top-level messages:
		AuthConfig
		ContainerListOptions
		NetworkListOptions
		ImageBuildOptions
		ImageBuildResponse
		ImageCreateOptions
		ImageImportSource
		ImageImportOptions
		ImageListOptions
		ImageLoadResponse
		ImagePullOptions
		ImagePushOptions
		ImageRemoveOptions
		ImageSearchOptions
		GraphDriverData
		ImageSummary
		Port
		RootFS
		ImageInspect
		ImageMetadata
		Container
		HealthcheckResult
		Health
		ContainerState
		ContainerNode
		ContainerJSONBase
		ContainerJSON
		NetworkSettings
		SummaryNetworkSettings
		NetworkSettingsBase
		DefaultNetworkSettings
		MountPoint
		NetworkResource
		EndpointResource
		NetworkCreate
		NetworkCreateRequest
		NetworkCreateResponse
		NetworkConnect
		NetworkDisconnect
		NetworkInspectOptions
		Image
*/
package moby

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import container "github.com/tangfeixiong/go-to-docker/pb/moby/container"
import network "github.com/tangfeixiong/go-to-docker/pb/moby/network"
import units "github.com/tangfeixiong/go-to-docker/pb/moby/units"
import filters "github.com/tangfeixiong/go-to-docker/pb/moby/filters"
import nat "github.com/tangfeixiong/go-to-docker/pb/moby/nat"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

//
// https://github.com/moby/moby/blob/master/api/types/auth.go
//
// AuthConfig contains authorization information for connecting to a Registry
// type AuthConfig struct
type AuthConfig struct {
	// Username string 0x60json:"username,omitempty"0x60
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	// Password string 0x60json:"password,omitempty"0x60
	Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	// Auth string  0x60json:"auth,omitempty"0x60
	Auth string `protobuf:"bytes,3,opt,name=auth,proto3" json:"auth,omitempty"`
	// Email string 0x60json:"email,omitempty"0x60 // Email is an Operational value associated with the username. This field is deprecated and will be removed in a later version of docker.
	Email string `protobuf:"bytes,4,opt,name=email,proto3" json:"email,omitempty"`
	// ServerAddress string 0x60json:"serveraddress,omitempty"0x60
	Serveraddress string `protobuf:"bytes,5,opt,name=serveraddress,proto3" json:"serveraddress,omitempty"`
	// IdentityToken string 0x60json:"identitytoken,omitempty"0x60 // IdentityToken is used to authenticate the user and get an access token for the registry.
	Identitytoken string `protobuf:"bytes,6,opt,name=identitytoken,proto3" json:"identitytoken,omitempty"`
	// RegistryToken string 0x60json:"registrytoken,omitempty"0x60 // RegistryToken is a bearer token to be sent to a registry
	Registrytoken string `protobuf:"bytes,7,opt,name=registrytoken,proto3" json:"registrytoken,omitempty"`
}

func (m *AuthConfig) Reset()                    { *m = AuthConfig{} }
func (m *AuthConfig) String() string            { return proto.CompactTextString(m) }
func (*AuthConfig) ProtoMessage()               {}
func (*AuthConfig) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{0} }

func (m *AuthConfig) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *AuthConfig) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *AuthConfig) GetAuth() string {
	if m != nil {
		return m.Auth
	}
	return ""
}

func (m *AuthConfig) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *AuthConfig) GetServeraddress() string {
	if m != nil {
		return m.Serveraddress
	}
	return ""
}

func (m *AuthConfig) GetIdentitytoken() string {
	if m != nil {
		return m.Identitytoken
	}
	return ""
}

func (m *AuthConfig) GetRegistrytoken() string {
	if m != nil {
		return m.Registrytoken
	}
	return ""
}

//
// https://github.com/moby/moby/blob/master/api/types/client.go
//
// ContainerListOptions holds parameters to list containers with.
// type ContainerListOptions struct
type ContainerListOptions struct {
	// Quiet bool
	Quiet bool `protobuf:"varint,1,opt,name=quiet,proto3" json:"quiet,omitempty"`
	// Size bool
	Size_ bool `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	// All bool
	All bool `protobuf:"varint,3,opt,name=all,proto3" json:"all,omitempty"`
	// Latest bool
	Latest bool `protobuf:"varint,4,opt,name=latest,proto3" json:"latest,omitempty"`
	// Since string
	Since string `protobuf:"bytes,5,opt,name=since,proto3" json:"since,omitempty"`
	// Before string
	Before string `protobuf:"bytes,6,opt,name=before,proto3" json:"before,omitempty"`
	// Limit int
	Limit int32 `protobuf:"varint,7,opt,name=limit,proto3" json:"limit,omitempty"`
	// Filters filters.Args
	Filters *filters.Args `protobuf:"bytes,8,opt,name=filters" json:"filters,omitempty"`
}

func (m *ContainerListOptions) Reset()                    { *m = ContainerListOptions{} }
func (m *ContainerListOptions) String() string            { return proto.CompactTextString(m) }
func (*ContainerListOptions) ProtoMessage()               {}
func (*ContainerListOptions) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{1} }

func (m *ContainerListOptions) GetQuiet() bool {
	if m != nil {
		return m.Quiet
	}
	return false
}

func (m *ContainerListOptions) GetSize_() bool {
	if m != nil {
		return m.Size_
	}
	return false
}

func (m *ContainerListOptions) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

func (m *ContainerListOptions) GetLatest() bool {
	if m != nil {
		return m.Latest
	}
	return false
}

func (m *ContainerListOptions) GetSince() string {
	if m != nil {
		return m.Since
	}
	return ""
}

func (m *ContainerListOptions) GetBefore() string {
	if m != nil {
		return m.Before
	}
	return ""
}

func (m *ContainerListOptions) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ContainerListOptions) GetFilters() *filters.Args {
	if m != nil {
		return m.Filters
	}
	return nil
}

// NetworkListOptions holds parameters to filter the list of networks with.
// type NetworkListOptions struct
type NetworkListOptions struct {
	// Filters filters.Args
	Filters *filters.Args `protobuf:"bytes,1,opt,name=filters" json:"filters,omitempty"`
}

func (m *NetworkListOptions) Reset()                    { *m = NetworkListOptions{} }
func (m *NetworkListOptions) String() string            { return proto.CompactTextString(m) }
func (*NetworkListOptions) ProtoMessage()               {}
func (*NetworkListOptions) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{2} }

func (m *NetworkListOptions) GetFilters() *filters.Args {
	if m != nil {
		return m.Filters
	}
	return nil
}

// ImageBuildOptions holds the information necessary to build images.
// type ImageBuildOptions struct
type ImageBuildOptions struct {
	// Tags []string
	Tags []string `protobuf:"bytes,1,rep,name=tags" json:"tags,omitempty"`
	// SuppressOutput bool
	SuppressOutput bool `protobuf:"varint,2,opt,name=suppress_output,json=suppressOutput,proto3" json:"suppress_output,omitempty"`
	// RemoteContext string
	RemoteContext string `protobuf:"bytes,3,opt,name=remote_context,json=remoteContext,proto3" json:"remote_context,omitempty"`
	// NoCache bool
	NoCache bool `protobuf:"varint,4,opt,name=no_cache,json=noCache,proto3" json:"no_cache,omitempty"`
	// Remove bool
	Remove bool `protobuf:"varint,5,opt,name=remove,proto3" json:"remove,omitempty"`
	// ForceRemove bool
	ForceRemove bool `protobuf:"varint,6,opt,name=force_remove,json=forceRemove,proto3" json:"force_remove,omitempty"`
	// PullParent bool
	PullParent bool `protobuf:"varint,7,opt,name=pull_parent,json=pullParent,proto3" json:"pull_parent,omitempty"`
	// Isolation container.Isolation // Isolation represents the isolation technology of a container. The supported value are platform specific. // type Isolation string
	Isolation string `protobuf:"bytes,8,opt,name=isolation,proto3" json:"isolation,omitempty"`
	// CPUSetCPUs string
	CpuSetCpus string `protobuf:"bytes,9,opt,name=cpu_set_cpus,json=cpuSetCpus,proto3" json:"cpu_set_cpus,omitempty"`
	// CPUSetMems string
	CpuSetMems string `protobuf:"bytes,10,opt,name=cpu_set_mems,json=cpuSetMems,proto3" json:"cpu_set_mems,omitempty"`
	// CPUShares int64
	CpuShares int64 `protobuf:"varint,11,opt,name=cpu_shares,json=cpuShares,proto3" json:"cpu_shares,omitempty"`
	// CPUQuota int64
	CpuQuota int64 `protobuf:"varint,12,opt,name=cpu_quota,json=cpuQuota,proto3" json:"cpu_quota,omitempty"`
	// CPUPeriod int64
	CpuPeriod int64 `protobuf:"varint,13,opt,name=cpu_period,json=cpuPeriod,proto3" json:"cpu_period,omitempty"`
	// Memory int64
	Memory int64 `protobuf:"varint,14,opt,name=memory,proto3" json:"memory,omitempty"`
	// MemorySwap int64
	MemorySwap int64 `protobuf:"varint,15,opt,name=memory_swap,json=memorySwap,proto3" json:"memory_swap,omitempty"`
	// CgroupParent string
	CgroupParent string `protobuf:"bytes,16,opt,name=cgroup_parent,json=cgroupParent,proto3" json:"cgroup_parent,omitempty"`
	// NetworkMode string
	NetworkMode string `protobuf:"bytes,17,opt,name=network_mode,json=networkMode,proto3" json:"network_mode,omitempty"`
	// ShmSize int64
	ShmSize int64 `protobuf:"varint,18,opt,name=shm_size,json=shmSize,proto3" json:"shm_size,omitempty"`
	// Dockerfile string
	Dockerfile string `protobuf:"bytes,19,opt,name=dockerfile,proto3" json:"dockerfile,omitempty"`
	// Ulimits []*units.Ulimit
	Ulimits []*units.Ulimit `protobuf:"bytes,20,rep,name=ulimits" json:"ulimits,omitempty"`
	// BuildArgs map[string]*string // BuildArgs needs to be a *string instead of just a string so that we can tell the difference between "" (empty string) and no value at all (nil). See the parsing of buildArgs in api/server/router/build/build_routers.go for even more info.
	BuildArgs map[string][]byte `protobuf:"bytes,21,rep,name=build_args,json=buildArgs" json:"build_args,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// AuthConfigs map[string]AuthConfig
	AuthConfigs map[string]*AuthConfig `protobuf:"bytes,22,rep,name=auth_configs,json=authConfigs" json:"auth_configs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Context io.Reader
	Context []byte `protobuf:"bytes,23,opt,name=context,proto3" json:"context,omitempty"`
	// Labels map[string]string
	Labels map[string]string `protobuf:"bytes,24,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Squash bool // squash the resulting image's layers to the parent preserve the original image and creates a new one from the parent with all the changes applied to a single layer
	Squash bool `protobuf:"varint,25,opt,name=squash,proto3" json:"squash,omitempty"`
	// CacheFrom []string // CacheFrom specifies images that are used for matching cache. Images specified here do not need to have a valid parent chain to match cache.
	CacheFrom []string `protobuf:"bytes,26,rep,name=cache_from,json=cacheFrom" json:"cache_from,omitempty"`
	// SecurityOpt []string
	SecurityOpt []string `protobuf:"bytes,27,rep,name=security_opt,json=securityOpt" json:"security_opt,omitempty"`
	// ExtraHosts []string // List of extra hosts
	EextraHosts []string `protobuf:"bytes,28,rep,name=eextra_hosts,json=eextraHosts" json:"eextra_hosts,omitempty"`
	// Target string
	Target string `protobuf:"bytes,29,opt,name=target,proto3" json:"target,omitempty"`
	// SessionID string
	SessionId string `protobuf:"bytes,30,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// Platform string
	Platform string `protobuf:"bytes,31,opt,name=platform,proto3" json:"platform,omitempty"`
	// Version BuildVersion // Version specifies the version of the underlying builder to use // type BuilderVersion string // BuilderV1 is the first generation builder in docker daemon. BuilderV1 BuilderVersion = "1" // BuilderBuildKit is builder based on moby/buildkit project. BuilderBuildKit = "2"
	BuildVersion string `protobuf:"bytes,32,opt,name=build_version,json=buildVersion,proto3" json:"build_version,omitempty"`
	// BuildID string // BuildID is an Operational identifier that can be passed together with the build request. Tha same identifier can be used to gracefully cancel the build with the cancel request.
	BuildId string `protobuf:"bytes,33,opt,name=build_id,json=buildId,proto3" json:"build_id,omitempty"`
}

func (m *ImageBuildOptions) Reset()                    { *m = ImageBuildOptions{} }
func (m *ImageBuildOptions) String() string            { return proto.CompactTextString(m) }
func (*ImageBuildOptions) ProtoMessage()               {}
func (*ImageBuildOptions) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{3} }

func (m *ImageBuildOptions) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *ImageBuildOptions) GetSuppressOutput() bool {
	if m != nil {
		return m.SuppressOutput
	}
	return false
}

func (m *ImageBuildOptions) GetRemoteContext() string {
	if m != nil {
		return m.RemoteContext
	}
	return ""
}

func (m *ImageBuildOptions) GetNoCache() bool {
	if m != nil {
		return m.NoCache
	}
	return false
}

func (m *ImageBuildOptions) GetRemove() bool {
	if m != nil {
		return m.Remove
	}
	return false
}

func (m *ImageBuildOptions) GetForceRemove() bool {
	if m != nil {
		return m.ForceRemove
	}
	return false
}

func (m *ImageBuildOptions) GetPullParent() bool {
	if m != nil {
		return m.PullParent
	}
	return false
}

func (m *ImageBuildOptions) GetIsolation() string {
	if m != nil {
		return m.Isolation
	}
	return ""
}

func (m *ImageBuildOptions) GetCpuSetCpus() string {
	if m != nil {
		return m.CpuSetCpus
	}
	return ""
}

func (m *ImageBuildOptions) GetCpuSetMems() string {
	if m != nil {
		return m.CpuSetMems
	}
	return ""
}

func (m *ImageBuildOptions) GetCpuShares() int64 {
	if m != nil {
		return m.CpuShares
	}
	return 0
}

func (m *ImageBuildOptions) GetCpuQuota() int64 {
	if m != nil {
		return m.CpuQuota
	}
	return 0
}

func (m *ImageBuildOptions) GetCpuPeriod() int64 {
	if m != nil {
		return m.CpuPeriod
	}
	return 0
}

func (m *ImageBuildOptions) GetMemory() int64 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *ImageBuildOptions) GetMemorySwap() int64 {
	if m != nil {
		return m.MemorySwap
	}
	return 0
}

func (m *ImageBuildOptions) GetCgroupParent() string {
	if m != nil {
		return m.CgroupParent
	}
	return ""
}

func (m *ImageBuildOptions) GetNetworkMode() string {
	if m != nil {
		return m.NetworkMode
	}
	return ""
}

func (m *ImageBuildOptions) GetShmSize() int64 {
	if m != nil {
		return m.ShmSize
	}
	return 0
}

func (m *ImageBuildOptions) GetDockerfile() string {
	if m != nil {
		return m.Dockerfile
	}
	return ""
}

func (m *ImageBuildOptions) GetUlimits() []*units.Ulimit {
	if m != nil {
		return m.Ulimits
	}
	return nil
}

func (m *ImageBuildOptions) GetBuildArgs() map[string][]byte {
	if m != nil {
		return m.BuildArgs
	}
	return nil
}

func (m *ImageBuildOptions) GetAuthConfigs() map[string]*AuthConfig {
	if m != nil {
		return m.AuthConfigs
	}
	return nil
}

func (m *ImageBuildOptions) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *ImageBuildOptions) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ImageBuildOptions) GetSquash() bool {
	if m != nil {
		return m.Squash
	}
	return false
}

func (m *ImageBuildOptions) GetCacheFrom() []string {
	if m != nil {
		return m.CacheFrom
	}
	return nil
}

func (m *ImageBuildOptions) GetSecurityOpt() []string {
	if m != nil {
		return m.SecurityOpt
	}
	return nil
}

func (m *ImageBuildOptions) GetEextraHosts() []string {
	if m != nil {
		return m.EextraHosts
	}
	return nil
}

func (m *ImageBuildOptions) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *ImageBuildOptions) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *ImageBuildOptions) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *ImageBuildOptions) GetBuildVersion() string {
	if m != nil {
		return m.BuildVersion
	}
	return ""
}

func (m *ImageBuildOptions) GetBuildId() string {
	if m != nil {
		return m.BuildId
	}
	return ""
}

// ImageBuildResponse holds information returned by a server after building an image
// type ImageBuildResponse struct
type ImageBuildResponse struct {
	// Body io.ReadCloser
	Body []byte `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// OSType string
	OsType string `protobuf:"bytes,2,opt,name=os_type,json=osType,proto3" json:"os_type,omitempty"`
}

func (m *ImageBuildResponse) Reset()                    { *m = ImageBuildResponse{} }
func (m *ImageBuildResponse) String() string            { return proto.CompactTextString(m) }
func (*ImageBuildResponse) ProtoMessage()               {}
func (*ImageBuildResponse) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{4} }

func (m *ImageBuildResponse) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *ImageBuildResponse) GetOsType() string {
	if m != nil {
		return m.OsType
	}
	return ""
}

// ImageCreateOptions holds information to create images.
// type ImageCreateOptions struct
type ImageCreateOptions struct {
	// RegistryAuth string // RegistryAuth is the base64 encoded credentials for the registry.
	RegistryAuth string `protobuf:"bytes,1,opt,name=registry_auth,json=registryAuth,proto3" json:"registry_auth,omitempty"`
	// Platform string // Platform is the target platform of the image if it needs to be pulled from the registry.
	Platform string `protobuf:"bytes,2,opt,name=platform,proto3" json:"platform,omitempty"`
}

func (m *ImageCreateOptions) Reset()                    { *m = ImageCreateOptions{} }
func (m *ImageCreateOptions) String() string            { return proto.CompactTextString(m) }
func (*ImageCreateOptions) ProtoMessage()               {}
func (*ImageCreateOptions) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{5} }

func (m *ImageCreateOptions) GetRegistryAuth() string {
	if m != nil {
		return m.RegistryAuth
	}
	return ""
}

func (m *ImageCreateOptions) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

// ImageImportSource holds source information for ImageImport
// type ImageImportSource struct
type ImageImportSource struct {
	// Source io.Reader // Source is the data to send to the server to create this image from. You must set SourceName to "-" to leverage this.
	Source []byte `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	// SourceName string // SourceName is the name of the image to pull. Set to "-" to leverage the Source attribute
	SourceName string `protobuf:"bytes,2,opt,name=source_name,json=sourceName,proto3" json:"source_name,omitempty"`
}

func (m *ImageImportSource) Reset()                    { *m = ImageImportSource{} }
func (m *ImageImportSource) String() string            { return proto.CompactTextString(m) }
func (*ImageImportSource) ProtoMessage()               {}
func (*ImageImportSource) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{6} }

func (m *ImageImportSource) GetSource() []byte {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *ImageImportSource) GetSourceName() string {
	if m != nil {
		return m.SourceName
	}
	return ""
}

// ImageImportOptions holds information to import images from the client host.
// type ImageImportOptions struct
type ImageImportOptions struct {
	// Tag string // Tag is the name to tag this image with. This attribute is deprecated.
	Tag string `protobuf:"bytes,1,opt,name=tag,proto3" json:"tag,omitempty"`
	// Message string // Message is the message to tag the image with
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	// Changes []string // Changes are the raw changes to apply to this image
	Changes []string `protobuf:"bytes,3,rep,name=changes" json:"changes,omitempty"`
	// Platform string // Platform is the target platform of the image
	Platform string `protobuf:"bytes,4,opt,name=platform,proto3" json:"platform,omitempty"`
}

func (m *ImageImportOptions) Reset()                    { *m = ImageImportOptions{} }
func (m *ImageImportOptions) String() string            { return proto.CompactTextString(m) }
func (*ImageImportOptions) ProtoMessage()               {}
func (*ImageImportOptions) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{7} }

func (m *ImageImportOptions) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

func (m *ImageImportOptions) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *ImageImportOptions) GetChanges() []string {
	if m != nil {
		return m.Changes
	}
	return nil
}

func (m *ImageImportOptions) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

// ImageListOptions holds parameters to filter the list of images with.
// type ImageListOptions struct
type ImageListOptions struct {
	// All bool
	All bool `protobuf:"varint,1,opt,name=all,proto3" json:"all,omitempty"`
	// Filters filters.Args
	Filters *filters.Args `protobuf:"bytes,2,opt,name=filters" json:"filters,omitempty"`
}

func (m *ImageListOptions) Reset()                    { *m = ImageListOptions{} }
func (m *ImageListOptions) String() string            { return proto.CompactTextString(m) }
func (*ImageListOptions) ProtoMessage()               {}
func (*ImageListOptions) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{8} }

func (m *ImageListOptions) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

func (m *ImageListOptions) GetFilters() *filters.Args {
	if m != nil {
		return m.Filters
	}
	return nil
}

// ImageLoadResponse returns information to the client about a load process
// type ImageLoadResponse struct
type ImageLoadResponse struct {
	// Body must be closed to avoid a response leak
	// Body io.ReadCloser
	Body []byte `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// JSON bool
	Json bool `protobuf:"varint,2,opt,name=json,proto3" json:"json,omitempty"`
}

func (m *ImageLoadResponse) Reset()                    { *m = ImageLoadResponse{} }
func (m *ImageLoadResponse) String() string            { return proto.CompactTextString(m) }
func (*ImageLoadResponse) ProtoMessage()               {}
func (*ImageLoadResponse) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{9} }

func (m *ImageLoadResponse) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *ImageLoadResponse) GetJson() bool {
	if m != nil {
		return m.Json
	}
	return false
}

// ImagePullOptions holds information to pull images.
// type ImagePullOptions struct
type ImagePullOptions struct {
	// All bool
	All bool `protobuf:"varint,1,opt,name=all,proto3" json:"all,omitempty"`
	// RegistryAuth string // RegistryAuth is the base64 encoded credentials for the registry
	RegistryAuth string `protobuf:"bytes,2,opt,name=registry_auth,json=registryAuth,proto3" json:"registry_auth,omitempty"`
	// PrivilegeFunc RequestPrivilegeFunc
	PrivilegeFunc string `protobuf:"bytes,3,opt,name=privilege_func,json=privilegeFunc,proto3" json:"privilege_func,omitempty"`
	// Platform string
	Platform string `protobuf:"bytes,4,opt,name=platform,proto3" json:"platform,omitempty"`
}

func (m *ImagePullOptions) Reset()                    { *m = ImagePullOptions{} }
func (m *ImagePullOptions) String() string            { return proto.CompactTextString(m) }
func (*ImagePullOptions) ProtoMessage()               {}
func (*ImagePullOptions) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{10} }

func (m *ImagePullOptions) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

func (m *ImagePullOptions) GetRegistryAuth() string {
	if m != nil {
		return m.RegistryAuth
	}
	return ""
}

func (m *ImagePullOptions) GetPrivilegeFunc() string {
	if m != nil {
		return m.PrivilegeFunc
	}
	return ""
}

func (m *ImagePullOptions) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

// ImagePushOptions holds information to push images.
// type ImagePushOptions ImagePullOptions
type ImagePushOptions struct {
	// All bool
	All bool `protobuf:"varint,1,opt,name=all,proto3" json:"all,omitempty"`
	// RegistryAuth string // RegistryAuth is the base64 encoded credentials for the registry
	RegistryAuth string `protobuf:"bytes,2,opt,name=registry_auth,json=registryAuth,proto3" json:"registry_auth,omitempty"`
	// PrivilegeFunc RequestPrivilegeFunc
	PrivilegeFunc string `protobuf:"bytes,3,opt,name=privilege_func,json=privilegeFunc,proto3" json:"privilege_func,omitempty"`
	// Platform string
	Platform string `protobuf:"bytes,4,opt,name=platform,proto3" json:"platform,omitempty"`
}

func (m *ImagePushOptions) Reset()                    { *m = ImagePushOptions{} }
func (m *ImagePushOptions) String() string            { return proto.CompactTextString(m) }
func (*ImagePushOptions) ProtoMessage()               {}
func (*ImagePushOptions) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{11} }

func (m *ImagePushOptions) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

func (m *ImagePushOptions) GetRegistryAuth() string {
	if m != nil {
		return m.RegistryAuth
	}
	return ""
}

func (m *ImagePushOptions) GetPrivilegeFunc() string {
	if m != nil {
		return m.PrivilegeFunc
	}
	return ""
}

func (m *ImagePushOptions) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

// ImageRemoveOptions holds parameters to remove images.
// type ImageRemoveOptions struct
type ImageRemoveOptions struct {
	// Force bool
	Force bool `protobuf:"varint,1,opt,name=force,proto3" json:"force,omitempty"`
	// PruneChildren bool
	PruneChildren bool `protobuf:"varint,2,opt,name=prune_children,json=pruneChildren,proto3" json:"prune_children,omitempty"`
}

func (m *ImageRemoveOptions) Reset()                    { *m = ImageRemoveOptions{} }
func (m *ImageRemoveOptions) String() string            { return proto.CompactTextString(m) }
func (*ImageRemoveOptions) ProtoMessage()               {}
func (*ImageRemoveOptions) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{12} }

func (m *ImageRemoveOptions) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

func (m *ImageRemoveOptions) GetPruneChildren() bool {
	if m != nil {
		return m.PruneChildren
	}
	return false
}

// ImageSearchOptions holds parameters to search images with.
// type ImageSearchOptions struct
type ImageSearchOptions struct {
	// RegistryAuth string
	RegistryAuth string `protobuf:"bytes,1,opt,name=registry_auth,json=registryAuth,proto3" json:"registry_auth,omitempty"`
	// PrivilegeFunc RequestPrivilegeFunc
	PrivilegeFunc string `protobuf:"bytes,2,opt,name=privilege_func,json=privilegeFunc,proto3" json:"privilege_func,omitempty"`
	// Filters filters.Args
	Filters *filters.Args `protobuf:"bytes,3,opt,name=filters" json:"filters,omitempty"`
	// Limit int
	Limit int32 `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *ImageSearchOptions) Reset()                    { *m = ImageSearchOptions{} }
func (m *ImageSearchOptions) String() string            { return proto.CompactTextString(m) }
func (*ImageSearchOptions) ProtoMessage()               {}
func (*ImageSearchOptions) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{13} }

func (m *ImageSearchOptions) GetRegistryAuth() string {
	if m != nil {
		return m.RegistryAuth
	}
	return ""
}

func (m *ImageSearchOptions) GetPrivilegeFunc() string {
	if m != nil {
		return m.PrivilegeFunc
	}
	return ""
}

func (m *ImageSearchOptions) GetFilters() *filters.Args {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *ImageSearchOptions) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

//
// https://github.com/moby/moby/blob/master/api/types/graph_driver_data.go
//
// GraphDriverData Information about a container's graph driver.
// swagger:model GraphDriverData
// type GraphDriverData struct
type GraphDriverData struct {
	// data
	// Required: true
	// Data map[string]string 0x60json:"Data"0x60
	Data map[string]string `protobuf:"bytes,1,rep,name=data" json:"data,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// name
	// Required: true
	// Name string 0x60json:"Name"0x60
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GraphDriverData) Reset()                    { *m = GraphDriverData{} }
func (m *GraphDriverData) String() string            { return proto.CompactTextString(m) }
func (*GraphDriverData) ProtoMessage()               {}
func (*GraphDriverData) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{14} }

func (m *GraphDriverData) GetData() map[string]string {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *GraphDriverData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

//
// https://github.com/moby/moby/blob/master/api/types/image_summary.go
//
// ImageSummary image summary
// swagger:model ImageSummary
// type ImageSummary struct
type ImageSummary struct {
	// containers int64 0x60json:"Containers"0x60
	// Required: true
	Containers int64 `protobuf:"varint,1,opt,name=containers,proto3" json:"containers,omitempty"`
	// created int64 0x60json:"Created"0x60
	// Required: true
	Created int64 `protobuf:"varint,2,opt,name=created,proto3" json:"created,omitempty"`
	// Id string 0x60json:"Id"0x60
	// Required: true
	Id string `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
	// labels map[string]string 0x60json:"Labels"0x60
	// Required: true
	Labels map[string]string `protobuf:"bytes,4,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// parent Id
	// Required: true
	// ParentID string 0x60json:"ParentId"0x60
	ParentId string `protobuf:"bytes,5,opt,name=parent_id,json=parentId,proto3" json:"parent_id,omitempty"`
	// repo digests
	// Required: true
	// RepoDigests []string 0x60json:"RepoDigests"0x60
	RepoDigests []string `protobuf:"bytes,6,rep,name=repo_digests,json=repoDigests" json:"repo_digests,omitempty"`
	// repo tags
	// Required: true
	// RepoTags []string 0x60json:"RepoTags"0x60
	RepoTags []string `protobuf:"bytes,7,rep,name=repo_tags,json=repoTags" json:"repo_tags,omitempty"`
	// shared size
	// Required: true
	// SharedSize int64 0x60json:"SharedSize"0x60
	SharedSize int64 `protobuf:"varint,8,opt,name=shared_size,json=sharedSize,proto3" json:"shared_size,omitempty"`
	// size int64 0x60json:"Size"0x60
	// Required: true
	Size_ int64 `protobuf:"varint,9,opt,name=size,proto3" json:"size,omitempty"`
	// virtual size
	// Required: true
	// VirtualSize int64 0x60json:"VirtualSize"0x60
	VirtualSize int64 `protobuf:"varint,10,opt,name=virtual_size,json=virtualSize,proto3" json:"virtual_size,omitempty"`
}

func (m *ImageSummary) Reset()                    { *m = ImageSummary{} }
func (m *ImageSummary) String() string            { return proto.CompactTextString(m) }
func (*ImageSummary) ProtoMessage()               {}
func (*ImageSummary) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{15} }

func (m *ImageSummary) GetContainers() int64 {
	if m != nil {
		return m.Containers
	}
	return 0
}

func (m *ImageSummary) GetCreated() int64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *ImageSummary) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ImageSummary) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ImageSummary) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *ImageSummary) GetRepoDigests() []string {
	if m != nil {
		return m.RepoDigests
	}
	return nil
}

func (m *ImageSummary) GetRepoTags() []string {
	if m != nil {
		return m.RepoTags
	}
	return nil
}

func (m *ImageSummary) GetSharedSize() int64 {
	if m != nil {
		return m.SharedSize
	}
	return 0
}

func (m *ImageSummary) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *ImageSummary) GetVirtualSize() int64 {
	if m != nil {
		return m.VirtualSize
	}
	return 0
}

//
// https://github.com/moby/moby/blob/master/api/types/port.go
//
// Port stores open ports info of container
// e.g. {"PrivatePort": 8080, "PublicPort": 80, "Type": "tcp"}
// type Port struct
type Port struct {
	// Host IP address that the container's port is mapped to
	// IP string 0x60json:"IP,omitempty"0x60
	Ip string `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	// Port on the container
	// Required: true
	// PrivatePort uint16 0x60json:"PrivatePort"0x60
	PrivatePort int32 `protobuf:"varint,2,opt,name=private_port,json=privatePort,proto3" json:"private_port,omitempty"`
	// Port exposed on the host
	// PublicPort uint16 0x60json:"PublicPort,omitempty"0x60
	PublicPort int32 `protobuf:"varint,3,opt,name=public_port,json=publicPort,proto3" json:"public_port,omitempty"`
	// type
	// Required: true
	// Type string 0x60json:"Type"0x60
	Type string `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *Port) Reset()                    { *m = Port{} }
func (m *Port) String() string            { return proto.CompactTextString(m) }
func (*Port) ProtoMessage()               {}
func (*Port) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{16} }

func (m *Port) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *Port) GetPrivatePort() int32 {
	if m != nil {
		return m.PrivatePort
	}
	return 0
}

func (m *Port) GetPublicPort() int32 {
	if m != nil {
		return m.PublicPort
	}
	return 0
}

func (m *Port) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

//
// https://github.com/moby/moby/blob/master/api/types/types.go
//
// RootFS returns Image's RootFS description including the layer IDs.
// type RootFS struct
type RootFS struct {
	// Type string
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Layers []string 0x60json:",omitempty"0x60
	Layers []string `protobuf:"bytes,2,rep,name=layers" json:"layers,omitempty"`
	// BaseLayer string 0x60json:",omitempty"0x60
	BaseLayer string `protobuf:"bytes,3,opt,name=base_layer,json=baseLayer,proto3" json:"base_layer,omitempty"`
}

func (m *RootFS) Reset()                    { *m = RootFS{} }
func (m *RootFS) String() string            { return proto.CompactTextString(m) }
func (*RootFS) ProtoMessage()               {}
func (*RootFS) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{17} }

func (m *RootFS) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *RootFS) GetLayers() []string {
	if m != nil {
		return m.Layers
	}
	return nil
}

func (m *RootFS) GetBaseLayer() string {
	if m != nil {
		return m.BaseLayer
	}
	return ""
}

// ImageInspect contains response of Engine API:
// GET "/images/{name:.*}/json"
// type ImageInspect struct
type ImageInspect struct {
	// ID string 0x60json:"Id"0x60
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// RepoTags []string
	RepoTags []string `protobuf:"bytes,2,rep,name=repo_tags,json=repoTags" json:"repo_tags,omitempty"`
	// RepoDigests []string
	RepoDigests []string `protobuf:"bytes,3,rep,name=repo_digests,json=repoDigests" json:"repo_digests,omitempty"`
	// Parent string
	Parent string `protobuf:"bytes,4,opt,name=parent,proto3" json:"parent,omitempty"`
	// Comment string
	Comment string `protobuf:"bytes,5,opt,name=comment,proto3" json:"comment,omitempty"`
	// Created string
	Created string `protobuf:"bytes,6,opt,name=created,proto3" json:"created,omitempty"`
	// Container string
	Container string `protobuf:"bytes,7,opt,name=container,proto3" json:"container,omitempty"`
	// ContainerConfig *container.Config
	ContainerConfig *container.Config `protobuf:"bytes,8,opt,name=container_config,json=containerConfig" json:"container_config,omitempty"`
	// DockerVersion string
	DockerVersion string `protobuf:"bytes,9,opt,name=docker_version,json=dockerVersion,proto3" json:"docker_version,omitempty"`
	// Author string
	Author string `protobuf:"bytes,10,opt,name=author,proto3" json:"author,omitempty"`
	// Config *container.Config
	Config *container.Config `protobuf:"bytes,11,opt,name=config" json:"config,omitempty"`
	// Architecture string
	Architecture string `protobuf:"bytes,12,opt,name=architecture,proto3" json:"architecture,omitempty"`
	// Os string
	Os string `protobuf:"bytes,13,opt,name=os,proto3" json:"os,omitempty"`
	// OsVersion string 0x60json:",omitempty"0x60
	OsVersion string `protobuf:"bytes,14,opt,name=os_version,json=osVersion,proto3" json:"os_version,omitempty"`
	// Size int64
	Size_ int64 `protobuf:"varint,15,opt,name=size,proto3" json:"size,omitempty"`
	// VirtualSize int64
	VirtualSize int64 `protobuf:"varint,16,opt,name=virtual_size,json=virtualSize,proto3" json:"virtual_size,omitempty"`
	// GraphDriver GraphDriverData
	GraphDriver *GraphDriverData `protobuf:"bytes,17,opt,name=graph_driver,json=graphDriver" json:"graph_driver,omitempty"`
	// RootFS RootFS
	RootFs *RootFS `protobuf:"bytes,18,opt,name=root_fs,json=rootFs" json:"root_fs,omitempty"`
	// Metadata ImageMetadata
	Metadata *ImageMetadata `protobuf:"bytes,19,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *ImageInspect) Reset()                    { *m = ImageInspect{} }
func (m *ImageInspect) String() string            { return proto.CompactTextString(m) }
func (*ImageInspect) ProtoMessage()               {}
func (*ImageInspect) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{18} }

func (m *ImageInspect) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ImageInspect) GetRepoTags() []string {
	if m != nil {
		return m.RepoTags
	}
	return nil
}

func (m *ImageInspect) GetRepoDigests() []string {
	if m != nil {
		return m.RepoDigests
	}
	return nil
}

func (m *ImageInspect) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *ImageInspect) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *ImageInspect) GetCreated() string {
	if m != nil {
		return m.Created
	}
	return ""
}

func (m *ImageInspect) GetContainer() string {
	if m != nil {
		return m.Container
	}
	return ""
}

func (m *ImageInspect) GetContainerConfig() *container.Config {
	if m != nil {
		return m.ContainerConfig
	}
	return nil
}

func (m *ImageInspect) GetDockerVersion() string {
	if m != nil {
		return m.DockerVersion
	}
	return ""
}

func (m *ImageInspect) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

func (m *ImageInspect) GetConfig() *container.Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *ImageInspect) GetArchitecture() string {
	if m != nil {
		return m.Architecture
	}
	return ""
}

func (m *ImageInspect) GetOs() string {
	if m != nil {
		return m.Os
	}
	return ""
}

func (m *ImageInspect) GetOsVersion() string {
	if m != nil {
		return m.OsVersion
	}
	return ""
}

func (m *ImageInspect) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *ImageInspect) GetVirtualSize() int64 {
	if m != nil {
		return m.VirtualSize
	}
	return 0
}

func (m *ImageInspect) GetGraphDriver() *GraphDriverData {
	if m != nil {
		return m.GraphDriver
	}
	return nil
}

func (m *ImageInspect) GetRootFs() *RootFS {
	if m != nil {
		return m.RootFs
	}
	return nil
}

func (m *ImageInspect) GetMetadata() *ImageMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// ImageMetadata contains engine-local data about the image
// type ImageMetadata struct
type ImageMetadata struct {
	// LastTagTime time.Time 0x60json:",omitempty"0x60
	LastTagTime string `protobuf:"bytes,1,opt,name=last_tag_time,json=lastTagTime,proto3" json:"last_tag_time,omitempty"`
}

func (m *ImageMetadata) Reset()                    { *m = ImageMetadata{} }
func (m *ImageMetadata) String() string            { return proto.CompactTextString(m) }
func (*ImageMetadata) ProtoMessage()               {}
func (*ImageMetadata) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{19} }

func (m *ImageMetadata) GetLastTagTime() string {
	if m != nil {
		return m.LastTagTime
	}
	return ""
}

// Container contains response of Remote API:
// GET  "/containers/json"
// type Container struct
type Container struct {
	// ID string 0x60json:"Id"0x60
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Names []string
	Names []string `protobuf:"bytes,2,rep,name=names" json:"names,omitempty"`
	// Image string
	Image string `protobuf:"bytes,3,opt,name=image,proto3" json:"image,omitempty"`
	// ImageID string
	ImageId string `protobuf:"bytes,4,opt,name=image_id,json=imageId,proto3" json:"image_id,omitempty"`
	// Command string
	Command string `protobuf:"bytes,5,opt,name=command,proto3" json:"command,omitempty"`
	// Created int64
	Created int64 `protobuf:"varint,6,opt,name=created,proto3" json:"created,omitempty"`
	// Ports []Port
	Ports []*Port `protobuf:"bytes,7,rep,name=Ports" json:"Ports,omitempty"`
	// SizeRw int64 0x60json:",omitempty"0x60
	SizeRw int64 `protobuf:"varint,8,opt,name=size_rw,json=sizeRw,proto3" json:"size_rw,omitempty"`
	// SizeRootFs int64 0x60json:",omitempty"0x60
	SizeRootFs int64 `protobuf:"varint,9,opt,name=size_root_fs,json=sizeRootFs,proto3" json:"size_root_fs,omitempty"`
	// Labels map[string]string
	Labels map[string]string `protobuf:"bytes,10,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// State string
	State string `protobuf:"bytes,11,opt,name=state,proto3" json:"state,omitempty"`
	// Status string
	Status string `protobuf:"bytes,12,opt,name=status,proto3" json:"status,omitempty"`
	// HostConfig struct
	HostConfig *Container_HostConfig `protobuf:"bytes,13,opt,name=host_config,json=hostConfig" json:"host_config,omitempty"`
	// NetworkSettings *SummaryNetworkSettings
	NetworkSettings *SummaryNetworkSettings `protobuf:"bytes,14,opt,name=network_settings,json=networkSettings" json:"network_settings,omitempty"`
	// Mounts []MountPoint
	Mounts []*MountPoint `protobuf:"bytes,15,rep,name=mounts" json:"mounts,omitempty"`
}

func (m *Container) Reset()                    { *m = Container{} }
func (m *Container) String() string            { return proto.CompactTextString(m) }
func (*Container) ProtoMessage()               {}
func (*Container) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{20} }

func (m *Container) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Container) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

func (m *Container) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *Container) GetImageId() string {
	if m != nil {
		return m.ImageId
	}
	return ""
}

func (m *Container) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *Container) GetCreated() int64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *Container) GetPorts() []*Port {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *Container) GetSizeRw() int64 {
	if m != nil {
		return m.SizeRw
	}
	return 0
}

func (m *Container) GetSizeRootFs() int64 {
	if m != nil {
		return m.SizeRootFs
	}
	return 0
}

func (m *Container) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Container) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *Container) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Container) GetHostConfig() *Container_HostConfig {
	if m != nil {
		return m.HostConfig
	}
	return nil
}

func (m *Container) GetNetworkSettings() *SummaryNetworkSettings {
	if m != nil {
		return m.NetworkSettings
	}
	return nil
}

func (m *Container) GetMounts() []*MountPoint {
	if m != nil {
		return m.Mounts
	}
	return nil
}

type Container_HostConfig struct {
	// NetworkMode String 0x60json:",omitempty"
	NetworkMode string `protobuf:"bytes,1,opt,name=network_mode,json=networkMode,proto3" json:"network_mode,omitempty"`
}

func (m *Container_HostConfig) Reset()                    { *m = Container_HostConfig{} }
func (m *Container_HostConfig) String() string            { return proto.CompactTextString(m) }
func (*Container_HostConfig) ProtoMessage()               {}
func (*Container_HostConfig) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{20, 0} }

func (m *Container_HostConfig) GetNetworkMode() string {
	if m != nil {
		return m.NetworkMode
	}
	return ""
}

// HealthcheckResult stores information about a single run of a healthcheck probe
// type HealthcheckResult struct
type HealthcheckResult struct {
	// Start time.Time // Start is the time this check started
	Start string `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
	// End time.Time // End is the time this check ended
	End string `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
	// ExitCode int // ExitCode meanings: 0=healthy, 1=unhealthy, 2=reserved (considered unhealthy), else=error running probe
	ExitCode int32 `protobuf:"varint,3,opt,name=exit_code,json=exitCode,proto3" json:"exit_code,omitempty"`
	// Output string // Output from last check
	Output string `protobuf:"bytes,4,opt,name=output,proto3" json:"output,omitempty"`
}

func (m *HealthcheckResult) Reset()                    { *m = HealthcheckResult{} }
func (m *HealthcheckResult) String() string            { return proto.CompactTextString(m) }
func (*HealthcheckResult) ProtoMessage()               {}
func (*HealthcheckResult) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{21} }

func (m *HealthcheckResult) GetStart() string {
	if m != nil {
		return m.Start
	}
	return ""
}

func (m *HealthcheckResult) GetEnd() string {
	if m != nil {
		return m.End
	}
	return ""
}

func (m *HealthcheckResult) GetExitCode() int32 {
	if m != nil {
		return m.ExitCode
	}
	return 0
}

func (m *HealthcheckResult) GetOutput() string {
	if m != nil {
		return m.Output
	}
	return ""
}

// Health stores information about the Container's healthcheck results
// type Health struct
type Health struct {
	// Status string // Status is one of Starting, Healthy or Unhealthy
	Status string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// FailingStreak int // FailingStreak is the number of consecutive failures
	FailingStreak int32 `protobuf:"varint,2,opt,name=failing_streak,json=failingStreak,proto3" json:"failing_streak,omitempty"`
	// Log []*HealthcheckResult // Log contains the last few results (oldest first)
	Log []*HealthcheckResult `protobuf:"bytes,3,rep,name=log" json:"log,omitempty"`
}

func (m *Health) Reset()                    { *m = Health{} }
func (m *Health) String() string            { return proto.CompactTextString(m) }
func (*Health) ProtoMessage()               {}
func (*Health) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{22} }

func (m *Health) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Health) GetFailingStreak() int32 {
	if m != nil {
		return m.FailingStreak
	}
	return 0
}

func (m *Health) GetLog() []*HealthcheckResult {
	if m != nil {
		return m.Log
	}
	return nil
}

// ContainerState stores container's running state
// it's part of ContainerJSONBase and will return by "inspect" command
// type ContainerState struct
type ContainerState struct {
	// Status string // String representation of the container state. Can be one of "created", "running", "paused", "restarting", "removing", "exited", of "dead"
	Status string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// Running bool
	Running bool `protobuf:"varint,2,opt,name=running,proto3" json:"running,omitempty"`
	// Paused bool
	Paused bool `protobuf:"varint,3,opt,name=paused,proto3" json:"paused,omitempty"`
	// Restarting bool
	Restarting bool `protobuf:"varint,4,opt,name=restarting,proto3" json:"restarting,omitempty"`
	// OOMKilled bool
	OomKilled bool `protobuf:"varint,5,opt,name=oom_killed,json=oomKilled,proto3" json:"oom_killed,omitempty"`
	// Dead bool
	Dead bool `protobuf:"varint,6,opt,name=dead,proto3" json:"dead,omitempty"`
	// Pid int
	Pid int32 `protobuf:"varint,7,opt,name=pid,proto3" json:"pid,omitempty"`
	// ExitCode int
	ExitCode int32 `protobuf:"varint,8,opt,name=exit_code,json=exitCode,proto3" json:"exit_code,omitempty"`
	// Error string
	Error string `protobuf:"bytes,9,opt,name=error,proto3" json:"error,omitempty"`
	// StartedAt string
	StartedAt string `protobuf:"bytes,10,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	// FinishedAt string
	FinishedAt string `protobuf:"bytes,11,opt,name=finished_at,json=finishedAt,proto3" json:"finished_at,omitempty"`
	// Health *Health 0x60json:",omitempty"0x60
	Health *Health `protobuf:"bytes,12,opt,name=health" json:"health,omitempty"`
}

func (m *ContainerState) Reset()                    { *m = ContainerState{} }
func (m *ContainerState) String() string            { return proto.CompactTextString(m) }
func (*ContainerState) ProtoMessage()               {}
func (*ContainerState) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{23} }

func (m *ContainerState) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ContainerState) GetRunning() bool {
	if m != nil {
		return m.Running
	}
	return false
}

func (m *ContainerState) GetPaused() bool {
	if m != nil {
		return m.Paused
	}
	return false
}

func (m *ContainerState) GetRestarting() bool {
	if m != nil {
		return m.Restarting
	}
	return false
}

func (m *ContainerState) GetOomKilled() bool {
	if m != nil {
		return m.OomKilled
	}
	return false
}

func (m *ContainerState) GetDead() bool {
	if m != nil {
		return m.Dead
	}
	return false
}

func (m *ContainerState) GetPid() int32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *ContainerState) GetExitCode() int32 {
	if m != nil {
		return m.ExitCode
	}
	return 0
}

func (m *ContainerState) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *ContainerState) GetStartedAt() string {
	if m != nil {
		return m.StartedAt
	}
	return ""
}

func (m *ContainerState) GetFinishedAt() string {
	if m != nil {
		return m.FinishedAt
	}
	return ""
}

func (m *ContainerState) GetHealth() *Health {
	if m != nil {
		return m.Health
	}
	return nil
}

// ContainerNode stores information about the node that a container is running on. It's only available in Docker Swarm
// type ContainerNode struct
type ContainerNode struct {
	// ID string
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// IPAddress string
	IpAddress string `protobuf:"bytes,2,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	// Addr string
	Addr string `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
	// Name string
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// Cpus int
	Cpus int32 `protobuf:"varint,5,opt,name=cpus,proto3" json:"cpus,omitempty"`
	// Memory int64
	Memory int64 `protobuf:"varint,6,opt,name=memory,proto3" json:"memory,omitempty"`
	// Labels map[string]string
	Labels map[string]string `protobuf:"bytes,7,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ContainerNode) Reset()                    { *m = ContainerNode{} }
func (m *ContainerNode) String() string            { return proto.CompactTextString(m) }
func (*ContainerNode) ProtoMessage()               {}
func (*ContainerNode) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{24} }

func (m *ContainerNode) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ContainerNode) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *ContainerNode) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *ContainerNode) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ContainerNode) GetCpus() int32 {
	if m != nil {
		return m.Cpus
	}
	return 0
}

func (m *ContainerNode) GetMemory() int64 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *ContainerNode) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// ContainerJSONBase contains response of Remote API:
// GET "/containers/{name:.*}/json"
// type ContainerJSONBase struct
type ContainerJSONBase struct {
	// ID string 0x60json:"Id"0x60
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Created string
	Created string `protobuf:"bytes,2,opt,name=created,proto3" json:"created,omitempty"`
	// Path string
	Path string `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
	// Args []string
	Args []string `protobuf:"bytes,4,rep,name=args" json:"args,omitempty"`
	// State *ContainerState
	State *ContainerState `protobuf:"bytes,5,opt,name=state" json:"state,omitempty"`
	// Image string
	Image string `protobuf:"bytes,6,opt,name=image,proto3" json:"image,omitempty"`
	// ResolvConfPath string
	ResolvConfPath string `protobuf:"bytes,7,opt,name=resolv_conf_path,json=resolvConfPath,proto3" json:"resolv_conf_path,omitempty"`
	// HostnamePath string
	HostnamePath string `protobuf:"bytes,8,opt,name=hostname_path,json=hostnamePath,proto3" json:"hostname_path,omitempty"`
	// HostsPath string
	HostsPath string `protobuf:"bytes,9,opt,name=hosts_path,json=hostsPath,proto3" json:"hosts_path,omitempty"`
	// LogPath string
	LogPath string `protobuf:"bytes,10,opt,name=log_path,json=logPath,proto3" json:"log_path,omitempty"`
	// Node *ContainerNode 0x60json:",omitempty"0x60
	Node *ContainerNode `protobuf:"bytes,11,opt,name=node" json:"node,omitempty"`
	// Name string
	Name string `protobuf:"bytes,12,opt,name=name,proto3" json:"name,omitempty"`
	// RestartCount int
	RestartCount int32 `protobuf:"varint,13,opt,name=restart_count,json=restartCount,proto3" json:"restart_count,omitempty"`
	// Driver string
	Driver string `protobuf:"bytes,14,opt,name=driver,proto3" json:"driver,omitempty"`
	// MountLabel string
	MountLabel string `protobuf:"bytes,15,opt,name=mount_label,json=mountLabel,proto3" json:"mount_label,omitempty"`
	// ProcessLabel string
	ProcessLabel string `protobuf:"bytes,16,opt,name=process_label,json=processLabel,proto3" json:"process_label,omitempty"`
	// AppArmorProfile string
	AppArmorProfile string `protobuf:"bytes,17,opt,name=app_armor_profile,json=appArmorProfile,proto3" json:"app_armor_profile,omitempty"`
	// ExecIDs []string
	ExecIds []string `protobuf:"bytes,18,rep,name=exec_ids,json=execIds" json:"exec_ids,omitempty"`
	// HostConfig *container.HostConfig
	HostConfig *container.HostConfig `protobuf:"bytes,19,opt,name=host_config,json=hostConfig" json:"host_config,omitempty"`
	// GraphDriver GraphDriverData
	GraphDriver *GraphDriverData `protobuf:"bytes,20,opt,name=graph_driver,json=graphDriver" json:"graph_driver,omitempty"`
	// SizeRw *int64 0x60json:",omitempty"0x60
	SizeRw int64 `protobuf:"varint,21,opt,name=size_rw,json=sizeRw,proto3" json:"size_rw,omitempty"`
	// SizeRootFs *int64 0x60json:",omitempty"0x60
	SizeRootFs int64 `protobuf:"varint,22,opt,name=size_root_fs,json=sizeRootFs,proto3" json:"size_root_fs,omitempty"`
}

func (m *ContainerJSONBase) Reset()                    { *m = ContainerJSONBase{} }
func (m *ContainerJSONBase) String() string            { return proto.CompactTextString(m) }
func (*ContainerJSONBase) ProtoMessage()               {}
func (*ContainerJSONBase) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{25} }

func (m *ContainerJSONBase) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ContainerJSONBase) GetCreated() string {
	if m != nil {
		return m.Created
	}
	return ""
}

func (m *ContainerJSONBase) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *ContainerJSONBase) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *ContainerJSONBase) GetState() *ContainerState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *ContainerJSONBase) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *ContainerJSONBase) GetResolvConfPath() string {
	if m != nil {
		return m.ResolvConfPath
	}
	return ""
}

func (m *ContainerJSONBase) GetHostnamePath() string {
	if m != nil {
		return m.HostnamePath
	}
	return ""
}

func (m *ContainerJSONBase) GetHostsPath() string {
	if m != nil {
		return m.HostsPath
	}
	return ""
}

func (m *ContainerJSONBase) GetLogPath() string {
	if m != nil {
		return m.LogPath
	}
	return ""
}

func (m *ContainerJSONBase) GetNode() *ContainerNode {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *ContainerJSONBase) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ContainerJSONBase) GetRestartCount() int32 {
	if m != nil {
		return m.RestartCount
	}
	return 0
}

func (m *ContainerJSONBase) GetDriver() string {
	if m != nil {
		return m.Driver
	}
	return ""
}

func (m *ContainerJSONBase) GetMountLabel() string {
	if m != nil {
		return m.MountLabel
	}
	return ""
}

func (m *ContainerJSONBase) GetProcessLabel() string {
	if m != nil {
		return m.ProcessLabel
	}
	return ""
}

func (m *ContainerJSONBase) GetAppArmorProfile() string {
	if m != nil {
		return m.AppArmorProfile
	}
	return ""
}

func (m *ContainerJSONBase) GetExecIds() []string {
	if m != nil {
		return m.ExecIds
	}
	return nil
}

func (m *ContainerJSONBase) GetHostConfig() *container.HostConfig {
	if m != nil {
		return m.HostConfig
	}
	return nil
}

func (m *ContainerJSONBase) GetGraphDriver() *GraphDriverData {
	if m != nil {
		return m.GraphDriver
	}
	return nil
}

func (m *ContainerJSONBase) GetSizeRw() int64 {
	if m != nil {
		return m.SizeRw
	}
	return 0
}

func (m *ContainerJSONBase) GetSizeRootFs() int64 {
	if m != nil {
		return m.SizeRootFs
	}
	return 0
}

// ContainerJSON is newly used struct along with MountPoint
// type ContainerJSON struct
type ContainerJSON struct {
	// ContainerJSONBase
	ContainerJsonBase *ContainerJSONBase `protobuf:"bytes,1,opt,name=container_json_base,json=containerJsonBase" json:"container_json_base,omitempty"`
	// Mounts []MountPoint
	Mounts []*MountPoint `protobuf:"bytes,2,rep,name=mounts" json:"mounts,omitempty"`
	// Config *container.Config
	Config *container.Config `protobuf:"bytes,3,opt,name=config" json:"config,omitempty"`
	// NetworkSettings *NetworkSettings
	NetworkSettings *NetworkSettings `protobuf:"bytes,4,opt,name=network_settings,json=networkSettings" json:"network_settings,omitempty"`
}

func (m *ContainerJSON) Reset()                    { *m = ContainerJSON{} }
func (m *ContainerJSON) String() string            { return proto.CompactTextString(m) }
func (*ContainerJSON) ProtoMessage()               {}
func (*ContainerJSON) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{26} }

func (m *ContainerJSON) GetContainerJsonBase() *ContainerJSONBase {
	if m != nil {
		return m.ContainerJsonBase
	}
	return nil
}

func (m *ContainerJSON) GetMounts() []*MountPoint {
	if m != nil {
		return m.Mounts
	}
	return nil
}

func (m *ContainerJSON) GetConfig() *container.Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *ContainerJSON) GetNetworkSettings() *NetworkSettings {
	if m != nil {
		return m.NetworkSettings
	}
	return nil
}

// NetworkSettings exposes the network settings in the api
// type NetworkSettings struct
type NetworkSettings struct {
	// NetworkSettingsBase
	NetworkSettingsBase *NetworkSettingsBase `protobuf:"bytes,1,opt,name=network_settings_base,json=networkSettingsBase" json:"network_settings_base,omitempty"`
	// DefaultNetworkSettings
	DefaultNetworkSettings *DefaultNetworkSettings `protobuf:"bytes,2,opt,name=default_network_settings,json=defaultNetworkSettings" json:"default_network_settings,omitempty"`
	// Networks map[string]*network.EndpointSettings
	Networks map[string]*network.EndpointSettings `protobuf:"bytes,3,rep,name=networks" json:"networks,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *NetworkSettings) Reset()                    { *m = NetworkSettings{} }
func (m *NetworkSettings) String() string            { return proto.CompactTextString(m) }
func (*NetworkSettings) ProtoMessage()               {}
func (*NetworkSettings) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{27} }

func (m *NetworkSettings) GetNetworkSettingsBase() *NetworkSettingsBase {
	if m != nil {
		return m.NetworkSettingsBase
	}
	return nil
}

func (m *NetworkSettings) GetDefaultNetworkSettings() *DefaultNetworkSettings {
	if m != nil {
		return m.DefaultNetworkSettings
	}
	return nil
}

func (m *NetworkSettings) GetNetworks() map[string]*network.EndpointSettings {
	if m != nil {
		return m.Networks
	}
	return nil
}

// SummaryNetworkSettings provides a summary of container's networks
// in /containers/json
// type SummaryNetworkSettings struct
type SummaryNetworkSettings struct {
	// Networks map[string]*network.EndpointSettings
	Networks map[string]*network.EndpointSettings `protobuf:"bytes,1,rep,name=networks" json:"networks,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SummaryNetworkSettings) Reset()                    { *m = SummaryNetworkSettings{} }
func (m *SummaryNetworkSettings) String() string            { return proto.CompactTextString(m) }
func (*SummaryNetworkSettings) ProtoMessage()               {}
func (*SummaryNetworkSettings) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{28} }

func (m *SummaryNetworkSettings) GetNetworks() map[string]*network.EndpointSettings {
	if m != nil {
		return m.Networks
	}
	return nil
}

// NetworkSettingsBase holds basic information about networks
// type NetworkSettingsBase
type NetworkSettingsBase struct {
	// Bridge string // Bridge is the Bridge name the network uses(e.g. 'docker0')
	Bridge string `protobuf:"bytes,1,opt,name=bridge,proto3" json:"bridge,omitempty"`
	// SandboxID string // SandboxID uniquely represents a container's network stack
	SandboxId string `protobuf:"bytes,2,opt,name=sandbox_id,json=sandboxId,proto3" json:"sandbox_id,omitempty"`
	// HairpinMode bool // HairpinMode specifies if hairpin NAT should be enabled on the virtual interface
	HairpinMode bool `protobuf:"varint,3,opt,name=hairpin_mode,json=hairpinMode,proto3" json:"hairpin_mode,omitempty"`
	// LinkLocalIPv6Address string // LinkLocalIPv6Address is an IPv6 unicast address using the link-local prefix
	LinkLocalIpv6Address string `protobuf:"bytes,4,opt,name=link_local_ipv6_address,json=linkLocalIpv6Address,proto3" json:"link_local_ipv6_address,omitempty"`
	// LinkLocalIPv6PrefixLen int // LinkLocalIPv6PrefixLen is the prefix length of an IPv6 unicast address
	LinkLocalIpv6PrefixLen int32 `protobuf:"varint,5,opt,name=link_local_ipv6_prefix_len,json=linkLocalIpv6PrefixLen,proto3" json:"link_local_ipv6_prefix_len,omitempty"`
	// Ports nat.PortMap // Ports is a collection of PortBinding indexed by Port
	Ports *nat.PortMap `protobuf:"bytes,6,opt,name=ports" json:"ports,omitempty"`
	// SandboxKey string //SandboxKey identifies the sandbox
	SandboxKey string `protobuf:"bytes,7,opt,name=sandbox_key,json=sandboxKey,proto3" json:"sandbox_key,omitempty"`
	// SecondaryIPAddresses []network.Address
	SecondaryIpAddresses []*network.Address `protobuf:"bytes,8,rep,name=secondary_ip_addresses,json=secondaryIpAddresses" json:"secondary_ip_addresses,omitempty"`
	// SecondaryIPv6Addresses []network.Address
	SecondaryIpv6Addresses []*network.Address `protobuf:"bytes,9,rep,name=secondary_ipv6_addresses,json=secondaryIpv6Addresses" json:"secondary_ipv6_addresses,omitempty"`
}

func (m *NetworkSettingsBase) Reset()                    { *m = NetworkSettingsBase{} }
func (m *NetworkSettingsBase) String() string            { return proto.CompactTextString(m) }
func (*NetworkSettingsBase) ProtoMessage()               {}
func (*NetworkSettingsBase) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{29} }

func (m *NetworkSettingsBase) GetBridge() string {
	if m != nil {
		return m.Bridge
	}
	return ""
}

func (m *NetworkSettingsBase) GetSandboxId() string {
	if m != nil {
		return m.SandboxId
	}
	return ""
}

func (m *NetworkSettingsBase) GetHairpinMode() bool {
	if m != nil {
		return m.HairpinMode
	}
	return false
}

func (m *NetworkSettingsBase) GetLinkLocalIpv6Address() string {
	if m != nil {
		return m.LinkLocalIpv6Address
	}
	return ""
}

func (m *NetworkSettingsBase) GetLinkLocalIpv6PrefixLen() int32 {
	if m != nil {
		return m.LinkLocalIpv6PrefixLen
	}
	return 0
}

func (m *NetworkSettingsBase) GetPorts() *nat.PortMap {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *NetworkSettingsBase) GetSandboxKey() string {
	if m != nil {
		return m.SandboxKey
	}
	return ""
}

func (m *NetworkSettingsBase) GetSecondaryIpAddresses() []*network.Address {
	if m != nil {
		return m.SecondaryIpAddresses
	}
	return nil
}

func (m *NetworkSettingsBase) GetSecondaryIpv6Addresses() []*network.Address {
	if m != nil {
		return m.SecondaryIpv6Addresses
	}
	return nil
}

// DefaultNetworkSettings holds network information during the 2 release deprecation period.
// It will be removed in Docker 1.11.
// type DefaultNetworkSettings struct
type DefaultNetworkSettings struct {
	// EndpointID string // EndpointID uniquely represents a service endpoint in a sandbox
	EndpointId string `protobuf:"bytes,1,opt,name=endpoint_id,json=endpointId,proto3" json:"endpoint_id,omitempty"`
	// Gateway string // Gateway holds the gateway address for the network
	Gateway string `protobuf:"bytes,2,opt,name=gateway,proto3" json:"gateway,omitempty"`
	// GlobalIPv6Address string // GlobalIPv6Address holds network's global IPv6 address
	GlobalIpv6Address string `protobuf:"bytes,3,opt,name=global_ipv6_address,json=globalIpv6Address,proto3" json:"global_ipv6_address,omitempty"`
	// GlobalIPv6PrefixLen int // GlobalIPv6PrefixLen represents mask length of network's global IPv6 address
	GlobalIpv6PrefixLen int32 `protobuf:"varint,4,opt,name=global_ipv6_prefix_len,json=globalIpv6PrefixLen,proto3" json:"global_ipv6_prefix_len,omitempty"`
	// IPAddress string // IPAddress holds the IPv4 address for the network
	IpAddress string `protobuf:"bytes,5,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	// IPPrefixLen int // IPPrefixLen represents mask length of network's IPv4 address
	IpPrefixLen int32 `protobuf:"varint,6,opt,name=ip_prefix_len,json=ipPrefixLen,proto3" json:"ip_prefix_len,omitempty"`
	// IPv6Gateway string // IPv6Gateway holds gateway address specific for IPv6
	Ipv6Gateway string `protobuf:"bytes,7,opt,name=ipv6_gateway,json=ipv6Gateway,proto3" json:"ipv6_gateway,omitempty"`
	// MacAddress string // MacAddress holds the MAC address for the network
	MacAddress string `protobuf:"bytes,8,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
}

func (m *DefaultNetworkSettings) Reset()                    { *m = DefaultNetworkSettings{} }
func (m *DefaultNetworkSettings) String() string            { return proto.CompactTextString(m) }
func (*DefaultNetworkSettings) ProtoMessage()               {}
func (*DefaultNetworkSettings) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{30} }

func (m *DefaultNetworkSettings) GetEndpointId() string {
	if m != nil {
		return m.EndpointId
	}
	return ""
}

func (m *DefaultNetworkSettings) GetGateway() string {
	if m != nil {
		return m.Gateway
	}
	return ""
}

func (m *DefaultNetworkSettings) GetGlobalIpv6Address() string {
	if m != nil {
		return m.GlobalIpv6Address
	}
	return ""
}

func (m *DefaultNetworkSettings) GetGlobalIpv6PrefixLen() int32 {
	if m != nil {
		return m.GlobalIpv6PrefixLen
	}
	return 0
}

func (m *DefaultNetworkSettings) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *DefaultNetworkSettings) GetIpPrefixLen() int32 {
	if m != nil {
		return m.IpPrefixLen
	}
	return 0
}

func (m *DefaultNetworkSettings) GetIpv6Gateway() string {
	if m != nil {
		return m.Ipv6Gateway
	}
	return ""
}

func (m *DefaultNetworkSettings) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

// MountPoint represents a mount point configuration inside the container.
// This is used for reporting the mountpoints in used by a container.
// type MountPoint struct
type MountPoint struct {
	// Type mount.Type 0x60json:",omitempty"0x60
	// Type represents the type of mount. // type Type string
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Name string 0x60json:",omitempty"0x60
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Source string
	Source string `protobuf:"bytes,3,opt,name=source,proto3" json:"source,omitempty"`
	// Destination string
	Destination string `protobuf:"bytes,4,opt,name=destination,proto3" json:"destination,omitempty"`
	// Driver string 0x60json:",omitempty"0x60
	Driver string `protobuf:"bytes,5,opt,name=driver,proto3" json:"driver,omitempty"`
	// Mode string
	Mode string `protobuf:"bytes,6,opt,name=mode,proto3" json:"mode,omitempty"`
	// RW bool
	Rw bool `protobuf:"varint,7,opt,name=rw,proto3" json:"rw,omitempty"`
	// Propagation mount.Propagation
	// Propagation represents the propagation of a mount. // type Propagation string
	Propagation string `protobuf:"bytes,8,opt,name=propagation,proto3" json:"propagation,omitempty"`
}

func (m *MountPoint) Reset()                    { *m = MountPoint{} }
func (m *MountPoint) String() string            { return proto.CompactTextString(m) }
func (*MountPoint) ProtoMessage()               {}
func (*MountPoint) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{31} }

func (m *MountPoint) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *MountPoint) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MountPoint) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *MountPoint) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *MountPoint) GetDriver() string {
	if m != nil {
		return m.Driver
	}
	return ""
}

func (m *MountPoint) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

func (m *MountPoint) GetRw() bool {
	if m != nil {
		return m.Rw
	}
	return false
}

func (m *MountPoint) GetPropagation() string {
	if m != nil {
		return m.Propagation
	}
	return ""
}

// NetworkResource is the body of the "get network" http response message
// type NetworkResource struct
type NetworkResource struct {
	// Name string // Name is the requested name of the network
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// ID string 0x60json:"Id"0x60 // ID uniquely identifies a network on a single machine
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// Created time.Time // Created is the time the network created
	Created string `protobuf:"bytes,3,opt,name=created,proto3" json:"created,omitempty"`
	// Scope string // Scope describes the level at which the network exists (e.g. 'swarm' for cluster-wide or 'local' for machine level)
	Scope string `protobuf:"bytes,4,opt,name=scope,proto3" json:"scope,omitempty"`
	// Driver string // Driver is the Driver name used to create the network (e.g. 'bridge', 'overlay')
	Driver string `protobuf:"bytes,5,opt,name=driver,proto3" json:"driver,omitempty"`
	// EnableIPv6 bool //EnableIPv6 represents whether to enable IPv6
	EnableIpv6 bool `protobuf:"varint,6,opt,name=enable_ipv6,json=enableIpv6,proto3" json:"enable_ipv6,omitempty"`
	// IPAM network.IPAM // IPAM is the network's IP Address Management
	Ipam *network.IPAM `protobuf:"bytes,7,opt,name=ipam" json:"ipam,omitempty"`
	// Internal bool // Internal represents if the network is used internal only
	Internal bool `protobuf:"varint,8,opt,name=internal,proto3" json:"internal,omitempty"`
	// Attachable bool // Attachable represents if the global scope is manually attachable by regular containers from workers in swarm mode.
	Attachable bool `protobuf:"varint,9,opt,name=attachable,proto3" json:"attachable,omitempty"`
	// Ingress bool // Ingress indicates the network is providing the routing-mesh for the swarm custer.
	Ingress bool `protobuf:"varint,10,opt,name=ingress,proto3" json:"ingress,omitempty"`
	// ConfigFrom network.ConfigReference // ConfigFrom speifies the source which will provide the cconfiguration for this network.
	ConfigFrom *network.ConfigReference `protobuf:"bytes,11,opt,name=config_from,json=configFrom" json:"config_from,omitempty"`
	// ConfigOnly bool // ConfigOnly networks are place-holder networks for network configurations to be used by other network. ConfigOnly networks cannot be used directly to run containers or services.
	ConfigOnly bool `protobuf:"varint,12,opt,name=config_only,json=configOnly,proto3" json:"config_only,omitempty"`
	// Containers map[string]EndpointResource // Containers contains endpoints belonging to the network
	Containers map[string]*EndpointResource `protobuf:"bytes,13,rep,name=containers" json:"containers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Options map[string]string // Options holds the network specific options to use for when creating the network
	Options map[string]string `protobuf:"bytes,14,rep,name=options" json:"options,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Labels map[string]string // Labels holds metadata specific to the network being created
	Labels map[string]string `protobuf:"bytes,15,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Peers []network.PeefInfo 0x60json:",omitempty"0x60 // List of peer nodes for an overlay network
	Peers []*network.PeerInfo `protobuf:"bytes,16,rep,name=peers" json:"peers,omitempty"`
}

func (m *NetworkResource) Reset()                    { *m = NetworkResource{} }
func (m *NetworkResource) String() string            { return proto.CompactTextString(m) }
func (*NetworkResource) ProtoMessage()               {}
func (*NetworkResource) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{32} }

func (m *NetworkResource) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NetworkResource) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NetworkResource) GetCreated() string {
	if m != nil {
		return m.Created
	}
	return ""
}

func (m *NetworkResource) GetScope() string {
	if m != nil {
		return m.Scope
	}
	return ""
}

func (m *NetworkResource) GetDriver() string {
	if m != nil {
		return m.Driver
	}
	return ""
}

func (m *NetworkResource) GetEnableIpv6() bool {
	if m != nil {
		return m.EnableIpv6
	}
	return false
}

func (m *NetworkResource) GetIpam() *network.IPAM {
	if m != nil {
		return m.Ipam
	}
	return nil
}

func (m *NetworkResource) GetInternal() bool {
	if m != nil {
		return m.Internal
	}
	return false
}

func (m *NetworkResource) GetAttachable() bool {
	if m != nil {
		return m.Attachable
	}
	return false
}

func (m *NetworkResource) GetIngress() bool {
	if m != nil {
		return m.Ingress
	}
	return false
}

func (m *NetworkResource) GetConfigFrom() *network.ConfigReference {
	if m != nil {
		return m.ConfigFrom
	}
	return nil
}

func (m *NetworkResource) GetConfigOnly() bool {
	if m != nil {
		return m.ConfigOnly
	}
	return false
}

func (m *NetworkResource) GetContainers() map[string]*EndpointResource {
	if m != nil {
		return m.Containers
	}
	return nil
}

func (m *NetworkResource) GetOptions() map[string]string {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *NetworkResource) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *NetworkResource) GetPeers() []*network.PeerInfo {
	if m != nil {
		return m.Peers
	}
	return nil
}

// EndpointResource contains network resources allocated and used for a container in a network
// type EndpointResource struct
type EndpointResource struct {
	// Name string
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// EndpointID string
	EndpointId string `protobuf:"bytes,2,opt,name=endpoint_id,json=endpointId,proto3" json:"endpoint_id,omitempty"`
	// MacAddress string
	MacAddress string `protobuf:"bytes,3,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	// IPv4Address string
	Ipv4Address string `protobuf:"bytes,4,opt,name=ipv4_address,json=ipv4Address,proto3" json:"ipv4_address,omitempty"`
	// IPv6Address string
	Ipv6Address string `protobuf:"bytes,5,opt,name=ipv6_address,json=ipv6Address,proto3" json:"ipv6_address,omitempty"`
}

func (m *EndpointResource) Reset()                    { *m = EndpointResource{} }
func (m *EndpointResource) String() string            { return proto.CompactTextString(m) }
func (*EndpointResource) ProtoMessage()               {}
func (*EndpointResource) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{33} }

func (m *EndpointResource) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EndpointResource) GetEndpointId() string {
	if m != nil {
		return m.EndpointId
	}
	return ""
}

func (m *EndpointResource) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *EndpointResource) GetIpv4Address() string {
	if m != nil {
		return m.Ipv4Address
	}
	return ""
}

func (m *EndpointResource) GetIpv6Address() string {
	if m != nil {
		return m.Ipv6Address
	}
	return ""
}

// NetworkCreate is the expected body of the "create network" http request message
// type NetworkCreate struct
type NetworkCreate struct {
	// CheckDuplicate bool // Check for networks with duplicate names. Network is primarily keyed based on a random ID and not on the name. Network name is strictly a user-friendly alias to the network which is uniquely identified using IO. And there is no gauranteed way to check for duplicates. Option CheckDuplicate is there to provide a best effort checking of any networks which had the same name but it is not guaranteed to catch all name collisions.
	CheckDuplicate bool `protobuf:"varint,1,opt,name=check_duplicate,json=checkDuplicate,proto3" json:"check_duplicate,omitempty"`
	// Driver string
	Driver string `protobuf:"bytes,2,opt,name=driver,proto3" json:"driver,omitempty"`
	// Scope string
	Scope string `protobuf:"bytes,3,opt,name=scope,proto3" json:"scope,omitempty"`
	// EnableIPv6 bool
	EnableIpv6 bool `protobuf:"varint,4,opt,name=enable_ipv6,json=enableIpv6,proto3" json:"enable_ipv6,omitempty"`
	// IPAM *network.IPAM
	Ipam *network.IPAM `protobuf:"bytes,5,opt,name=ipam" json:"ipam,omitempty"`
	// Internal bool
	Internal bool `protobuf:"varint,6,opt,name=internal,proto3" json:"internal,omitempty"`
	// Attachable bool
	Attachable bool `protobuf:"varint,7,opt,name=attachable,proto3" json:"attachable,omitempty"`
	// Ingress bool
	Ingress bool `protobuf:"varint,8,opt,name=ingress,proto3" json:"ingress,omitempty"`
	// ConfigOnly bool
	ConfigOnly bool `protobuf:"varint,9,opt,name=config_only,json=configOnly,proto3" json:"config_only,omitempty"`
	// ConfigFrom *network.ConfigReference
	ConfigFrom *network.ConfigReference `protobuf:"bytes,10,opt,name=config_from,json=configFrom" json:"config_from,omitempty"`
	// Options map[string]string
	Options map[string]string `protobuf:"bytes,11,rep,name=options" json:"options,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Labels map[string]string
	Labels map[string]string `protobuf:"bytes,12,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *NetworkCreate) Reset()                    { *m = NetworkCreate{} }
func (m *NetworkCreate) String() string            { return proto.CompactTextString(m) }
func (*NetworkCreate) ProtoMessage()               {}
func (*NetworkCreate) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{34} }

func (m *NetworkCreate) GetCheckDuplicate() bool {
	if m != nil {
		return m.CheckDuplicate
	}
	return false
}

func (m *NetworkCreate) GetDriver() string {
	if m != nil {
		return m.Driver
	}
	return ""
}

func (m *NetworkCreate) GetScope() string {
	if m != nil {
		return m.Scope
	}
	return ""
}

func (m *NetworkCreate) GetEnableIpv6() bool {
	if m != nil {
		return m.EnableIpv6
	}
	return false
}

func (m *NetworkCreate) GetIpam() *network.IPAM {
	if m != nil {
		return m.Ipam
	}
	return nil
}

func (m *NetworkCreate) GetInternal() bool {
	if m != nil {
		return m.Internal
	}
	return false
}

func (m *NetworkCreate) GetAttachable() bool {
	if m != nil {
		return m.Attachable
	}
	return false
}

func (m *NetworkCreate) GetIngress() bool {
	if m != nil {
		return m.Ingress
	}
	return false
}

func (m *NetworkCreate) GetConfigOnly() bool {
	if m != nil {
		return m.ConfigOnly
	}
	return false
}

func (m *NetworkCreate) GetConfigFrom() *network.ConfigReference {
	if m != nil {
		return m.ConfigFrom
	}
	return nil
}

func (m *NetworkCreate) GetOptions() map[string]string {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *NetworkCreate) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// NetworkCreateRequest is the request message sent to the server for network create call.
// type NetworkCreateRequest struct
type NetworkCreateRequest struct {
	// NetworkCreate
	NetworkCreate *NetworkCreate `protobuf:"bytes,1,opt,name=network_create,json=networkCreate" json:"network_create,omitempty"`
	// Name string
	Name string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
}

func (m *NetworkCreateRequest) Reset()                    { *m = NetworkCreateRequest{} }
func (m *NetworkCreateRequest) String() string            { return proto.CompactTextString(m) }
func (*NetworkCreateRequest) ProtoMessage()               {}
func (*NetworkCreateRequest) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{35} }

func (m *NetworkCreateRequest) GetNetworkCreate() *NetworkCreate {
	if m != nil {
		return m.NetworkCreate
	}
	return nil
}

func (m *NetworkCreateRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// NetworkCreateResponse is the response message sent by the server for network create call
// type NetworkCreateResponse struct
type NetworkCreateResponse struct {
	// ID string 0x60json:"Id"0x60
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Warning string
	Warning string `protobuf:"bytes,2,opt,name=warning,proto3" json:"warning,omitempty"`
}

func (m *NetworkCreateResponse) Reset()                    { *m = NetworkCreateResponse{} }
func (m *NetworkCreateResponse) String() string            { return proto.CompactTextString(m) }
func (*NetworkCreateResponse) ProtoMessage()               {}
func (*NetworkCreateResponse) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{36} }

func (m *NetworkCreateResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NetworkCreateResponse) GetWarning() string {
	if m != nil {
		return m.Warning
	}
	return ""
}

// NetworkConnect represents the data to be used to connect a container to the network
// type NetworkConnect struct
type NetworkConnect struct {
	// Container string
	Container string `protobuf:"bytes,1,opt,name=container,proto3" json:"container,omitempty"`
	// EndpointConfig *network.EndpointSettings 0x60json:",omitempty"0x60
	EndpointConfig *network.EndpointSettings `protobuf:"bytes,2,opt,name=endpoint_config,json=endpointConfig" json:"endpoint_config,omitempty"`
}

func (m *NetworkConnect) Reset()                    { *m = NetworkConnect{} }
func (m *NetworkConnect) String() string            { return proto.CompactTextString(m) }
func (*NetworkConnect) ProtoMessage()               {}
func (*NetworkConnect) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{37} }

func (m *NetworkConnect) GetContainer() string {
	if m != nil {
		return m.Container
	}
	return ""
}

func (m *NetworkConnect) GetEndpointConfig() *network.EndpointSettings {
	if m != nil {
		return m.EndpointConfig
	}
	return nil
}

// NetworkDisconnect represents the data to be used to disconnect a container from the network
// type NetworkDisconnect struct
type NetworkDisconnect struct {
	// Container string
	Container string `protobuf:"bytes,1,opt,name=container,proto3" json:"container,omitempty"`
	// Force bool
	Force bool `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
}

func (m *NetworkDisconnect) Reset()                    { *m = NetworkDisconnect{} }
func (m *NetworkDisconnect) String() string            { return proto.CompactTextString(m) }
func (*NetworkDisconnect) ProtoMessage()               {}
func (*NetworkDisconnect) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{38} }

func (m *NetworkDisconnect) GetContainer() string {
	if m != nil {
		return m.Container
	}
	return ""
}

func (m *NetworkDisconnect) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

// NetworkInspectOptions holds parameters to inspect network
// type NetworkInspectOptions struct
type NetworkInspectOptions struct {
	// Scope string
	Scope string `protobuf:"bytes,1,opt,name=scope,proto3" json:"scope,omitempty"`
	// Verbose bool
	Verbose bool `protobuf:"varint,2,opt,name=verbose,proto3" json:"verbose,omitempty"`
}

func (m *NetworkInspectOptions) Reset()                    { *m = NetworkInspectOptions{} }
func (m *NetworkInspectOptions) String() string            { return proto.CompactTextString(m) }
func (*NetworkInspectOptions) ProtoMessage()               {}
func (*NetworkInspectOptions) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{39} }

func (m *NetworkInspectOptions) GetScope() string {
	if m != nil {
		return m.Scope
	}
	return ""
}

func (m *NetworkInspectOptions) GetVerbose() bool {
	if m != nil {
		return m.Verbose
	}
	return false
}

// Image contains response of Remote API:
// GET "/images/json"
type Image struct {
	Id          string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	ParentId    string            `protobuf:"bytes,2,opt,name=parent_id,json=parentId,proto3" json:"parent_id,omitempty"`
	RepoTags    []string          `protobuf:"bytes,3,rep,name=repo_tags,json=repoTags" json:"repo_tags,omitempty"`
	RepoDigests []string          `protobuf:"bytes,4,rep,name=repo_digests,json=repoDigests" json:"repo_digests,omitempty"`
	Created     int64             `protobuf:"varint,5,opt,name=created,proto3" json:"created,omitempty"`
	Size_       int64             `protobuf:"varint,6,opt,name=size,proto3" json:"size,omitempty"`
	VirtualSize int64             `protobuf:"varint,7,opt,name=virtual_size,json=virtualSize,proto3" json:"virtual_size,omitempty"`
	Labels      map[string]string `protobuf:"bytes,8,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Image) Reset()                    { *m = Image{} }
func (m *Image) String() string            { return proto.CompactTextString(m) }
func (*Image) ProtoMessage()               {}
func (*Image) Descriptor() ([]byte, []int) { return fileDescriptorMoby, []int{40} }

func (m *Image) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Image) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *Image) GetRepoTags() []string {
	if m != nil {
		return m.RepoTags
	}
	return nil
}

func (m *Image) GetRepoDigests() []string {
	if m != nil {
		return m.RepoDigests
	}
	return nil
}

func (m *Image) GetCreated() int64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *Image) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *Image) GetVirtualSize() int64 {
	if m != nil {
		return m.VirtualSize
	}
	return 0
}

func (m *Image) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func init() {
	proto.RegisterType((*AuthConfig)(nil), "moby.AuthConfig")
	proto.RegisterType((*ContainerListOptions)(nil), "moby.ContainerListOptions")
	proto.RegisterType((*NetworkListOptions)(nil), "moby.NetworkListOptions")
	proto.RegisterType((*ImageBuildOptions)(nil), "moby.ImageBuildOptions")
	proto.RegisterType((*ImageBuildResponse)(nil), "moby.ImageBuildResponse")
	proto.RegisterType((*ImageCreateOptions)(nil), "moby.ImageCreateOptions")
	proto.RegisterType((*ImageImportSource)(nil), "moby.ImageImportSource")
	proto.RegisterType((*ImageImportOptions)(nil), "moby.ImageImportOptions")
	proto.RegisterType((*ImageListOptions)(nil), "moby.ImageListOptions")
	proto.RegisterType((*ImageLoadResponse)(nil), "moby.ImageLoadResponse")
	proto.RegisterType((*ImagePullOptions)(nil), "moby.ImagePullOptions")
	proto.RegisterType((*ImagePushOptions)(nil), "moby.ImagePushOptions")
	proto.RegisterType((*ImageRemoveOptions)(nil), "moby.ImageRemoveOptions")
	proto.RegisterType((*ImageSearchOptions)(nil), "moby.ImageSearchOptions")
	proto.RegisterType((*GraphDriverData)(nil), "moby.GraphDriverData")
	proto.RegisterType((*ImageSummary)(nil), "moby.ImageSummary")
	proto.RegisterType((*Port)(nil), "moby.Port")
	proto.RegisterType((*RootFS)(nil), "moby.RootFS")
	proto.RegisterType((*ImageInspect)(nil), "moby.ImageInspect")
	proto.RegisterType((*ImageMetadata)(nil), "moby.ImageMetadata")
	proto.RegisterType((*Container)(nil), "moby.Container")
	proto.RegisterType((*Container_HostConfig)(nil), "moby.Container.HostConfig")
	proto.RegisterType((*HealthcheckResult)(nil), "moby.HealthcheckResult")
	proto.RegisterType((*Health)(nil), "moby.Health")
	proto.RegisterType((*ContainerState)(nil), "moby.ContainerState")
	proto.RegisterType((*ContainerNode)(nil), "moby.ContainerNode")
	proto.RegisterType((*ContainerJSONBase)(nil), "moby.ContainerJSONBase")
	proto.RegisterType((*ContainerJSON)(nil), "moby.ContainerJSON")
	proto.RegisterType((*NetworkSettings)(nil), "moby.NetworkSettings")
	proto.RegisterType((*SummaryNetworkSettings)(nil), "moby.SummaryNetworkSettings")
	proto.RegisterType((*NetworkSettingsBase)(nil), "moby.NetworkSettingsBase")
	proto.RegisterType((*DefaultNetworkSettings)(nil), "moby.DefaultNetworkSettings")
	proto.RegisterType((*MountPoint)(nil), "moby.MountPoint")
	proto.RegisterType((*NetworkResource)(nil), "moby.NetworkResource")
	proto.RegisterType((*EndpointResource)(nil), "moby.EndpointResource")
	proto.RegisterType((*NetworkCreate)(nil), "moby.NetworkCreate")
	proto.RegisterType((*NetworkCreateRequest)(nil), "moby.NetworkCreateRequest")
	proto.RegisterType((*NetworkCreateResponse)(nil), "moby.NetworkCreateResponse")
	proto.RegisterType((*NetworkConnect)(nil), "moby.NetworkConnect")
	proto.RegisterType((*NetworkDisconnect)(nil), "moby.NetworkDisconnect")
	proto.RegisterType((*NetworkInspectOptions)(nil), "moby.NetworkInspectOptions")
	proto.RegisterType((*Image)(nil), "moby.Image")
}
func (m *AuthConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if len(m.Auth) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Auth)))
		i += copy(dAtA[i:], m.Auth)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.Serveraddress) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Serveraddress)))
		i += copy(dAtA[i:], m.Serveraddress)
	}
	if len(m.Identitytoken) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Identitytoken)))
		i += copy(dAtA[i:], m.Identitytoken)
	}
	if len(m.Registrytoken) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Registrytoken)))
		i += copy(dAtA[i:], m.Registrytoken)
	}
	return i, nil
}

func (m *ContainerListOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerListOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Quiet {
		dAtA[i] = 0x8
		i++
		if m.Quiet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Size_ {
		dAtA[i] = 0x10
		i++
		if m.Size_ {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.All {
		dAtA[i] = 0x18
		i++
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Latest {
		dAtA[i] = 0x20
		i++
		if m.Latest {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Since) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Since)))
		i += copy(dAtA[i:], m.Since)
	}
	if len(m.Before) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Before)))
		i += copy(dAtA[i:], m.Before)
	}
	if m.Limit != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Limit))
	}
	if m.Filters != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Filters.Size()))
		n1, err := m.Filters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *NetworkListOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkListOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Filters != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Filters.Size()))
		n2, err := m.Filters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *ImageBuildOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageBuildOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.SuppressOutput {
		dAtA[i] = 0x10
		i++
		if m.SuppressOutput {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.RemoteContext) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.RemoteContext)))
		i += copy(dAtA[i:], m.RemoteContext)
	}
	if m.NoCache {
		dAtA[i] = 0x20
		i++
		if m.NoCache {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Remove {
		dAtA[i] = 0x28
		i++
		if m.Remove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ForceRemove {
		dAtA[i] = 0x30
		i++
		if m.ForceRemove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PullParent {
		dAtA[i] = 0x38
		i++
		if m.PullParent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Isolation) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Isolation)))
		i += copy(dAtA[i:], m.Isolation)
	}
	if len(m.CpuSetCpus) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.CpuSetCpus)))
		i += copy(dAtA[i:], m.CpuSetCpus)
	}
	if len(m.CpuSetMems) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.CpuSetMems)))
		i += copy(dAtA[i:], m.CpuSetMems)
	}
	if m.CpuShares != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.CpuShares))
	}
	if m.CpuQuota != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.CpuQuota))
	}
	if m.CpuPeriod != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.CpuPeriod))
	}
	if m.Memory != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Memory))
	}
	if m.MemorySwap != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.MemorySwap))
	}
	if len(m.CgroupParent) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.CgroupParent)))
		i += copy(dAtA[i:], m.CgroupParent)
	}
	if len(m.NetworkMode) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.NetworkMode)))
		i += copy(dAtA[i:], m.NetworkMode)
	}
	if m.ShmSize != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.ShmSize))
	}
	if len(m.Dockerfile) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Dockerfile)))
		i += copy(dAtA[i:], m.Dockerfile)
	}
	if len(m.Ulimits) > 0 {
		for _, msg := range m.Ulimits {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMoby(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BuildArgs) > 0 {
		for k, _ := range m.BuildArgs {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			v := m.BuildArgs[k]
			byteSize := 0
			if len(v) > 0 {
				byteSize = 1 + len(v) + sovMoby(uint64(len(v)))
			}
			mapSize := 1 + len(k) + sovMoby(uint64(len(k))) + byteSize
			i = encodeVarintMoby(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if len(v) > 0 {
				dAtA[i] = 0x12
				i++
				i = encodeVarintMoby(dAtA, i, uint64(len(v)))
				i += copy(dAtA[i:], v)
			}
		}
	}
	if len(m.AuthConfigs) > 0 {
		for k, _ := range m.AuthConfigs {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			v := m.AuthConfigs[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovMoby(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovMoby(uint64(len(k))) + msgSize
			i = encodeVarintMoby(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintMoby(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	if len(m.Context) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Context)))
		i += copy(dAtA[i:], m.Context)
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovMoby(uint64(len(k))) + 1 + len(v) + sovMoby(uint64(len(v)))
			i = encodeVarintMoby(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Squash {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		if m.Squash {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.CacheFrom) > 0 {
		for _, s := range m.CacheFrom {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.SecurityOpt) > 0 {
		for _, s := range m.SecurityOpt {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.EextraHosts) > 0 {
		for _, s := range m.EextraHosts {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Target) > 0 {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Target)))
		i += copy(dAtA[i:], m.Target)
	}
	if len(m.SessionId) > 0 {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.SessionId)))
		i += copy(dAtA[i:], m.SessionId)
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	if len(m.BuildVersion) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.BuildVersion)))
		i += copy(dAtA[i:], m.BuildVersion)
	}
	if len(m.BuildId) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.BuildId)))
		i += copy(dAtA[i:], m.BuildId)
	}
	return i, nil
}

func (m *ImageBuildResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageBuildResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Body) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if len(m.OsType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.OsType)))
		i += copy(dAtA[i:], m.OsType)
	}
	return i, nil
}

func (m *ImageCreateOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageCreateOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RegistryAuth) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.RegistryAuth)))
		i += copy(dAtA[i:], m.RegistryAuth)
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	return i, nil
}

func (m *ImageImportSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageImportSource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.SourceName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.SourceName)))
		i += copy(dAtA[i:], m.SourceName)
	}
	return i, nil
}

func (m *ImageImportOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageImportOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tag) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Tag)))
		i += copy(dAtA[i:], m.Tag)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.Changes) > 0 {
		for _, s := range m.Changes {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	return i, nil
}

func (m *ImageListOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageListOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.All {
		dAtA[i] = 0x8
		i++
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Filters != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Filters.Size()))
		n4, err := m.Filters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *ImageLoadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageLoadResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Body) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if m.Json {
		dAtA[i] = 0x10
		i++
		if m.Json {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ImagePullOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImagePullOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.All {
		dAtA[i] = 0x8
		i++
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.RegistryAuth) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.RegistryAuth)))
		i += copy(dAtA[i:], m.RegistryAuth)
	}
	if len(m.PrivilegeFunc) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.PrivilegeFunc)))
		i += copy(dAtA[i:], m.PrivilegeFunc)
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	return i, nil
}

func (m *ImagePushOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImagePushOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.All {
		dAtA[i] = 0x8
		i++
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.RegistryAuth) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.RegistryAuth)))
		i += copy(dAtA[i:], m.RegistryAuth)
	}
	if len(m.PrivilegeFunc) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.PrivilegeFunc)))
		i += copy(dAtA[i:], m.PrivilegeFunc)
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	return i, nil
}

func (m *ImageRemoveOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageRemoveOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Force {
		dAtA[i] = 0x8
		i++
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PruneChildren {
		dAtA[i] = 0x10
		i++
		if m.PruneChildren {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ImageSearchOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageSearchOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RegistryAuth) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.RegistryAuth)))
		i += copy(dAtA[i:], m.RegistryAuth)
	}
	if len(m.PrivilegeFunc) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.PrivilegeFunc)))
		i += copy(dAtA[i:], m.PrivilegeFunc)
	}
	if m.Filters != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Filters.Size()))
		n5, err := m.Filters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Limit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Limit))
	}
	return i, nil
}

func (m *GraphDriverData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphDriverData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, _ := range m.Data {
			dAtA[i] = 0xa
			i++
			v := m.Data[k]
			mapSize := 1 + len(k) + sovMoby(uint64(len(k))) + 1 + len(v) + sovMoby(uint64(len(v)))
			i = encodeVarintMoby(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *ImageSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageSummary) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Containers != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Containers))
	}
	if m.Created != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Created))
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0x22
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovMoby(uint64(len(k))) + 1 + len(v) + sovMoby(uint64(len(v)))
			i = encodeVarintMoby(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.ParentId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.ParentId)))
		i += copy(dAtA[i:], m.ParentId)
	}
	if len(m.RepoDigests) > 0 {
		for _, s := range m.RepoDigests {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.RepoTags) > 0 {
		for _, s := range m.RepoTags {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.SharedSize != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.SharedSize))
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Size_))
	}
	if m.VirtualSize != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.VirtualSize))
	}
	return i, nil
}

func (m *Port) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Port) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ip) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Ip)))
		i += copy(dAtA[i:], m.Ip)
	}
	if m.PrivatePort != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.PrivatePort))
	}
	if m.PublicPort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.PublicPort))
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	return i, nil
}

func (m *RootFS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RootFS) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Layers) > 0 {
		for _, s := range m.Layers {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.BaseLayer) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.BaseLayer)))
		i += copy(dAtA[i:], m.BaseLayer)
	}
	return i, nil
}

func (m *ImageInspect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageInspect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.RepoTags) > 0 {
		for _, s := range m.RepoTags {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.RepoDigests) > 0 {
		for _, s := range m.RepoDigests {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Parent) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Parent)))
		i += copy(dAtA[i:], m.Parent)
	}
	if len(m.Comment) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if len(m.Created) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Created)))
		i += copy(dAtA[i:], m.Created)
	}
	if len(m.Container) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Container)))
		i += copy(dAtA[i:], m.Container)
	}
	if m.ContainerConfig != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.ContainerConfig.Size()))
		n6, err := m.ContainerConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.DockerVersion) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.DockerVersion)))
		i += copy(dAtA[i:], m.DockerVersion)
	}
	if len(m.Author) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Author)))
		i += copy(dAtA[i:], m.Author)
	}
	if m.Config != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Config.Size()))
		n7, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Architecture) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Architecture)))
		i += copy(dAtA[i:], m.Architecture)
	}
	if len(m.Os) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Os)))
		i += copy(dAtA[i:], m.Os)
	}
	if len(m.OsVersion) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.OsVersion)))
		i += copy(dAtA[i:], m.OsVersion)
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Size_))
	}
	if m.VirtualSize != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.VirtualSize))
	}
	if m.GraphDriver != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.GraphDriver.Size()))
		n8, err := m.GraphDriver.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.RootFs != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.RootFs.Size()))
		n9, err := m.RootFs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Metadata != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Metadata.Size()))
		n10, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *ImageMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LastTagTime) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.LastTagTime)))
		i += copy(dAtA[i:], m.LastTagTime)
	}
	return i, nil
}

func (m *Container) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Container) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.ImageId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.ImageId)))
		i += copy(dAtA[i:], m.ImageId)
	}
	if len(m.Command) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Command)))
		i += copy(dAtA[i:], m.Command)
	}
	if m.Created != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Created))
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintMoby(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SizeRw != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.SizeRw))
	}
	if m.SizeRootFs != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.SizeRootFs))
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0x52
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovMoby(uint64(len(k))) + 1 + len(v) + sovMoby(uint64(len(v)))
			i = encodeVarintMoby(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.State) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if m.HostConfig != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.HostConfig.Size()))
		n11, err := m.HostConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.NetworkSettings != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.NetworkSettings.Size()))
		n12, err := m.NetworkSettings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.Mounts) > 0 {
		for _, msg := range m.Mounts {
			dAtA[i] = 0x7a
			i++
			i = encodeVarintMoby(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Container_HostConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Container_HostConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NetworkMode) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.NetworkMode)))
		i += copy(dAtA[i:], m.NetworkMode)
	}
	return i, nil
}

func (m *HealthcheckResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthcheckResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Start) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Start)))
		i += copy(dAtA[i:], m.Start)
	}
	if len(m.End) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.End)))
		i += copy(dAtA[i:], m.End)
	}
	if m.ExitCode != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.ExitCode))
	}
	if len(m.Output) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Output)))
		i += copy(dAtA[i:], m.Output)
	}
	return i, nil
}

func (m *Health) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Health) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if m.FailingStreak != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.FailingStreak))
	}
	if len(m.Log) > 0 {
		for _, msg := range m.Log {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMoby(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ContainerState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if m.Running {
		dAtA[i] = 0x10
		i++
		if m.Running {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Paused {
		dAtA[i] = 0x18
		i++
		if m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Restarting {
		dAtA[i] = 0x20
		i++
		if m.Restarting {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OomKilled {
		dAtA[i] = 0x28
		i++
		if m.OomKilled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Dead {
		dAtA[i] = 0x30
		i++
		if m.Dead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Pid != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Pid))
	}
	if m.ExitCode != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.ExitCode))
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if len(m.StartedAt) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.StartedAt)))
		i += copy(dAtA[i:], m.StartedAt)
	}
	if len(m.FinishedAt) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.FinishedAt)))
		i += copy(dAtA[i:], m.FinishedAt)
	}
	if m.Health != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Health.Size()))
		n13, err := m.Health.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *ContainerNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.IpAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.IpAddress)))
		i += copy(dAtA[i:], m.IpAddress)
	}
	if len(m.Addr) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Addr)))
		i += copy(dAtA[i:], m.Addr)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Cpus != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Cpus))
	}
	if m.Memory != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Memory))
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0x3a
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovMoby(uint64(len(k))) + 1 + len(v) + sovMoby(uint64(len(v)))
			i = encodeVarintMoby(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *ContainerJSONBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerJSONBase) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Created) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Created)))
		i += copy(dAtA[i:], m.Created)
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.State != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.State.Size()))
		n14, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.ResolvConfPath) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.ResolvConfPath)))
		i += copy(dAtA[i:], m.ResolvConfPath)
	}
	if len(m.HostnamePath) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.HostnamePath)))
		i += copy(dAtA[i:], m.HostnamePath)
	}
	if len(m.HostsPath) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.HostsPath)))
		i += copy(dAtA[i:], m.HostsPath)
	}
	if len(m.LogPath) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.LogPath)))
		i += copy(dAtA[i:], m.LogPath)
	}
	if m.Node != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Node.Size()))
		n15, err := m.Node.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.RestartCount != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.RestartCount))
	}
	if len(m.Driver) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Driver)))
		i += copy(dAtA[i:], m.Driver)
	}
	if len(m.MountLabel) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.MountLabel)))
		i += copy(dAtA[i:], m.MountLabel)
	}
	if len(m.ProcessLabel) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.ProcessLabel)))
		i += copy(dAtA[i:], m.ProcessLabel)
	}
	if len(m.AppArmorProfile) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.AppArmorProfile)))
		i += copy(dAtA[i:], m.AppArmorProfile)
	}
	if len(m.ExecIds) > 0 {
		for _, s := range m.ExecIds {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.HostConfig != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.HostConfig.Size()))
		n16, err := m.HostConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.GraphDriver != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.GraphDriver.Size()))
		n17, err := m.GraphDriver.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.SizeRw != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.SizeRw))
	}
	if m.SizeRootFs != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.SizeRootFs))
	}
	return i, nil
}

func (m *ContainerJSON) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerJSON) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ContainerJsonBase != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.ContainerJsonBase.Size()))
		n18, err := m.ContainerJsonBase.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if len(m.Mounts) > 0 {
		for _, msg := range m.Mounts {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMoby(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Config != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Config.Size()))
		n19, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.NetworkSettings != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.NetworkSettings.Size()))
		n20, err := m.NetworkSettings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *NetworkSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkSettings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NetworkSettingsBase != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.NetworkSettingsBase.Size()))
		n21, err := m.NetworkSettingsBase.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.DefaultNetworkSettings != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.DefaultNetworkSettings.Size()))
		n22, err := m.DefaultNetworkSettings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if len(m.Networks) > 0 {
		for k, _ := range m.Networks {
			dAtA[i] = 0x1a
			i++
			v := m.Networks[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovMoby(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovMoby(uint64(len(k))) + msgSize
			i = encodeVarintMoby(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintMoby(dAtA, i, uint64(v.Size()))
				n23, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n23
			}
		}
	}
	return i, nil
}

func (m *SummaryNetworkSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SummaryNetworkSettings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Networks) > 0 {
		for k, _ := range m.Networks {
			dAtA[i] = 0xa
			i++
			v := m.Networks[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovMoby(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovMoby(uint64(len(k))) + msgSize
			i = encodeVarintMoby(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintMoby(dAtA, i, uint64(v.Size()))
				n24, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n24
			}
		}
	}
	return i, nil
}

func (m *NetworkSettingsBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkSettingsBase) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Bridge) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Bridge)))
		i += copy(dAtA[i:], m.Bridge)
	}
	if len(m.SandboxId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.SandboxId)))
		i += copy(dAtA[i:], m.SandboxId)
	}
	if m.HairpinMode {
		dAtA[i] = 0x18
		i++
		if m.HairpinMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.LinkLocalIpv6Address) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.LinkLocalIpv6Address)))
		i += copy(dAtA[i:], m.LinkLocalIpv6Address)
	}
	if m.LinkLocalIpv6PrefixLen != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.LinkLocalIpv6PrefixLen))
	}
	if m.Ports != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Ports.Size()))
		n25, err := m.Ports.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if len(m.SandboxKey) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.SandboxKey)))
		i += copy(dAtA[i:], m.SandboxKey)
	}
	if len(m.SecondaryIpAddresses) > 0 {
		for _, msg := range m.SecondaryIpAddresses {
			dAtA[i] = 0x42
			i++
			i = encodeVarintMoby(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SecondaryIpv6Addresses) > 0 {
		for _, msg := range m.SecondaryIpv6Addresses {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintMoby(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DefaultNetworkSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefaultNetworkSettings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EndpointId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.EndpointId)))
		i += copy(dAtA[i:], m.EndpointId)
	}
	if len(m.Gateway) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Gateway)))
		i += copy(dAtA[i:], m.Gateway)
	}
	if len(m.GlobalIpv6Address) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.GlobalIpv6Address)))
		i += copy(dAtA[i:], m.GlobalIpv6Address)
	}
	if m.GlobalIpv6PrefixLen != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.GlobalIpv6PrefixLen))
	}
	if len(m.IpAddress) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.IpAddress)))
		i += copy(dAtA[i:], m.IpAddress)
	}
	if m.IpPrefixLen != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.IpPrefixLen))
	}
	if len(m.Ipv6Gateway) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Ipv6Gateway)))
		i += copy(dAtA[i:], m.Ipv6Gateway)
	}
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	return i, nil
}

func (m *MountPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MountPoint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Source) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Destination) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Destination)))
		i += copy(dAtA[i:], m.Destination)
	}
	if len(m.Driver) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Driver)))
		i += copy(dAtA[i:], m.Driver)
	}
	if len(m.Mode) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Mode)))
		i += copy(dAtA[i:], m.Mode)
	}
	if m.Rw {
		dAtA[i] = 0x38
		i++
		if m.Rw {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Propagation) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Propagation)))
		i += copy(dAtA[i:], m.Propagation)
	}
	return i, nil
}

func (m *NetworkResource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkResource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Created) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Created)))
		i += copy(dAtA[i:], m.Created)
	}
	if len(m.Scope) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Scope)))
		i += copy(dAtA[i:], m.Scope)
	}
	if len(m.Driver) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Driver)))
		i += copy(dAtA[i:], m.Driver)
	}
	if m.EnableIpv6 {
		dAtA[i] = 0x30
		i++
		if m.EnableIpv6 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Ipam != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Ipam.Size()))
		n26, err := m.Ipam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.Internal {
		dAtA[i] = 0x40
		i++
		if m.Internal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Attachable {
		dAtA[i] = 0x48
		i++
		if m.Attachable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Ingress {
		dAtA[i] = 0x50
		i++
		if m.Ingress {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ConfigFrom != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.ConfigFrom.Size()))
		n27, err := m.ConfigFrom.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.ConfigOnly {
		dAtA[i] = 0x60
		i++
		if m.ConfigOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Containers) > 0 {
		for k, _ := range m.Containers {
			dAtA[i] = 0x6a
			i++
			v := m.Containers[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovMoby(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovMoby(uint64(len(k))) + msgSize
			i = encodeVarintMoby(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintMoby(dAtA, i, uint64(v.Size()))
				n28, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n28
			}
		}
	}
	if len(m.Options) > 0 {
		for k, _ := range m.Options {
			dAtA[i] = 0x72
			i++
			v := m.Options[k]
			mapSize := 1 + len(k) + sovMoby(uint64(len(k))) + 1 + len(v) + sovMoby(uint64(len(v)))
			i = encodeVarintMoby(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0x7a
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovMoby(uint64(len(k))) + 1 + len(v) + sovMoby(uint64(len(v)))
			i = encodeVarintMoby(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Peers) > 0 {
		for _, msg := range m.Peers {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMoby(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EndpointResource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointResource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.EndpointId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.EndpointId)))
		i += copy(dAtA[i:], m.EndpointId)
	}
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	if len(m.Ipv4Address) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Ipv4Address)))
		i += copy(dAtA[i:], m.Ipv4Address)
	}
	if len(m.Ipv6Address) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Ipv6Address)))
		i += copy(dAtA[i:], m.Ipv6Address)
	}
	return i, nil
}

func (m *NetworkCreate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkCreate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CheckDuplicate {
		dAtA[i] = 0x8
		i++
		if m.CheckDuplicate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Driver) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Driver)))
		i += copy(dAtA[i:], m.Driver)
	}
	if len(m.Scope) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Scope)))
		i += copy(dAtA[i:], m.Scope)
	}
	if m.EnableIpv6 {
		dAtA[i] = 0x20
		i++
		if m.EnableIpv6 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Ipam != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Ipam.Size()))
		n29, err := m.Ipam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.Internal {
		dAtA[i] = 0x30
		i++
		if m.Internal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Attachable {
		dAtA[i] = 0x38
		i++
		if m.Attachable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Ingress {
		dAtA[i] = 0x40
		i++
		if m.Ingress {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ConfigOnly {
		dAtA[i] = 0x48
		i++
		if m.ConfigOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ConfigFrom != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.ConfigFrom.Size()))
		n30, err := m.ConfigFrom.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if len(m.Options) > 0 {
		for k, _ := range m.Options {
			dAtA[i] = 0x5a
			i++
			v := m.Options[k]
			mapSize := 1 + len(k) + sovMoby(uint64(len(k))) + 1 + len(v) + sovMoby(uint64(len(v)))
			i = encodeVarintMoby(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0x62
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovMoby(uint64(len(k))) + 1 + len(v) + sovMoby(uint64(len(v)))
			i = encodeVarintMoby(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *NetworkCreateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkCreateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NetworkCreate != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.NetworkCreate.Size()))
		n31, err := m.NetworkCreate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *NetworkCreateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkCreateResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Warning) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Warning)))
		i += copy(dAtA[i:], m.Warning)
	}
	return i, nil
}

func (m *NetworkConnect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkConnect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Container) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Container)))
		i += copy(dAtA[i:], m.Container)
	}
	if m.EndpointConfig != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.EndpointConfig.Size()))
		n32, err := m.EndpointConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *NetworkDisconnect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkDisconnect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Container) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Container)))
		i += copy(dAtA[i:], m.Container)
	}
	if m.Force {
		dAtA[i] = 0x10
		i++
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *NetworkInspectOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkInspectOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Scope) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Scope)))
		i += copy(dAtA[i:], m.Scope)
	}
	if m.Verbose {
		dAtA[i] = 0x10
		i++
		if m.Verbose {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Image) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Image) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.ParentId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMoby(dAtA, i, uint64(len(m.ParentId)))
		i += copy(dAtA[i:], m.ParentId)
	}
	if len(m.RepoTags) > 0 {
		for _, s := range m.RepoTags {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.RepoDigests) > 0 {
		for _, s := range m.RepoDigests {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Created != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Created))
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.Size_))
	}
	if m.VirtualSize != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMoby(dAtA, i, uint64(m.VirtualSize))
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0x42
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovMoby(uint64(len(k))) + 1 + len(v) + sovMoby(uint64(len(v)))
			i = encodeVarintMoby(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintMoby(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func encodeVarintMoby(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AuthConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Auth)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Serveraddress)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Identitytoken)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Registrytoken)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *ContainerListOptions) Size() (n int) {
	var l int
	_ = l
	if m.Quiet {
		n += 2
	}
	if m.Size_ {
		n += 2
	}
	if m.All {
		n += 2
	}
	if m.Latest {
		n += 2
	}
	l = len(m.Since)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Before)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovMoby(uint64(m.Limit))
	}
	if m.Filters != nil {
		l = m.Filters.Size()
		n += 1 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *NetworkListOptions) Size() (n int) {
	var l int
	_ = l
	if m.Filters != nil {
		l = m.Filters.Size()
		n += 1 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *ImageBuildOptions) Size() (n int) {
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovMoby(uint64(l))
		}
	}
	if m.SuppressOutput {
		n += 2
	}
	l = len(m.RemoteContext)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.NoCache {
		n += 2
	}
	if m.Remove {
		n += 2
	}
	if m.ForceRemove {
		n += 2
	}
	if m.PullParent {
		n += 2
	}
	l = len(m.Isolation)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.CpuSetCpus)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.CpuSetMems)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.CpuShares != 0 {
		n += 1 + sovMoby(uint64(m.CpuShares))
	}
	if m.CpuQuota != 0 {
		n += 1 + sovMoby(uint64(m.CpuQuota))
	}
	if m.CpuPeriod != 0 {
		n += 1 + sovMoby(uint64(m.CpuPeriod))
	}
	if m.Memory != 0 {
		n += 1 + sovMoby(uint64(m.Memory))
	}
	if m.MemorySwap != 0 {
		n += 1 + sovMoby(uint64(m.MemorySwap))
	}
	l = len(m.CgroupParent)
	if l > 0 {
		n += 2 + l + sovMoby(uint64(l))
	}
	l = len(m.NetworkMode)
	if l > 0 {
		n += 2 + l + sovMoby(uint64(l))
	}
	if m.ShmSize != 0 {
		n += 2 + sovMoby(uint64(m.ShmSize))
	}
	l = len(m.Dockerfile)
	if l > 0 {
		n += 2 + l + sovMoby(uint64(l))
	}
	if len(m.Ulimits) > 0 {
		for _, e := range m.Ulimits {
			l = e.Size()
			n += 2 + l + sovMoby(uint64(l))
		}
	}
	if len(m.BuildArgs) > 0 {
		for k, v := range m.BuildArgs {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovMoby(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovMoby(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovMoby(uint64(mapEntrySize))
		}
	}
	if len(m.AuthConfigs) > 0 {
		for k, v := range m.AuthConfigs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMoby(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMoby(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovMoby(uint64(mapEntrySize))
		}
	}
	l = len(m.Context)
	if l > 0 {
		n += 2 + l + sovMoby(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMoby(uint64(len(k))) + 1 + len(v) + sovMoby(uint64(len(v)))
			n += mapEntrySize + 2 + sovMoby(uint64(mapEntrySize))
		}
	}
	if m.Squash {
		n += 3
	}
	if len(m.CacheFrom) > 0 {
		for _, s := range m.CacheFrom {
			l = len(s)
			n += 2 + l + sovMoby(uint64(l))
		}
	}
	if len(m.SecurityOpt) > 0 {
		for _, s := range m.SecurityOpt {
			l = len(s)
			n += 2 + l + sovMoby(uint64(l))
		}
	}
	if len(m.EextraHosts) > 0 {
		for _, s := range m.EextraHosts {
			l = len(s)
			n += 2 + l + sovMoby(uint64(l))
		}
	}
	l = len(m.Target)
	if l > 0 {
		n += 2 + l + sovMoby(uint64(l))
	}
	l = len(m.SessionId)
	if l > 0 {
		n += 2 + l + sovMoby(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 2 + l + sovMoby(uint64(l))
	}
	l = len(m.BuildVersion)
	if l > 0 {
		n += 2 + l + sovMoby(uint64(l))
	}
	l = len(m.BuildId)
	if l > 0 {
		n += 2 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *ImageBuildResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.OsType)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *ImageCreateOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.RegistryAuth)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *ImageImportSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.SourceName)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *ImageImportOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if len(m.Changes) > 0 {
		for _, s := range m.Changes {
			l = len(s)
			n += 1 + l + sovMoby(uint64(l))
		}
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *ImageListOptions) Size() (n int) {
	var l int
	_ = l
	if m.All {
		n += 2
	}
	if m.Filters != nil {
		l = m.Filters.Size()
		n += 1 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *ImageLoadResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.Json {
		n += 2
	}
	return n
}

func (m *ImagePullOptions) Size() (n int) {
	var l int
	_ = l
	if m.All {
		n += 2
	}
	l = len(m.RegistryAuth)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.PrivilegeFunc)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *ImagePushOptions) Size() (n int) {
	var l int
	_ = l
	if m.All {
		n += 2
	}
	l = len(m.RegistryAuth)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.PrivilegeFunc)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *ImageRemoveOptions) Size() (n int) {
	var l int
	_ = l
	if m.Force {
		n += 2
	}
	if m.PruneChildren {
		n += 2
	}
	return n
}

func (m *ImageSearchOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.RegistryAuth)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.PrivilegeFunc)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.Filters != nil {
		l = m.Filters.Size()
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovMoby(uint64(m.Limit))
	}
	return n
}

func (m *GraphDriverData) Size() (n int) {
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMoby(uint64(len(k))) + 1 + len(v) + sovMoby(uint64(len(v)))
			n += mapEntrySize + 1 + sovMoby(uint64(mapEntrySize))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *ImageSummary) Size() (n int) {
	var l int
	_ = l
	if m.Containers != 0 {
		n += 1 + sovMoby(uint64(m.Containers))
	}
	if m.Created != 0 {
		n += 1 + sovMoby(uint64(m.Created))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMoby(uint64(len(k))) + 1 + len(v) + sovMoby(uint64(len(v)))
			n += mapEntrySize + 1 + sovMoby(uint64(mapEntrySize))
		}
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if len(m.RepoDigests) > 0 {
		for _, s := range m.RepoDigests {
			l = len(s)
			n += 1 + l + sovMoby(uint64(l))
		}
	}
	if len(m.RepoTags) > 0 {
		for _, s := range m.RepoTags {
			l = len(s)
			n += 1 + l + sovMoby(uint64(l))
		}
	}
	if m.SharedSize != 0 {
		n += 1 + sovMoby(uint64(m.SharedSize))
	}
	if m.Size_ != 0 {
		n += 1 + sovMoby(uint64(m.Size_))
	}
	if m.VirtualSize != 0 {
		n += 1 + sovMoby(uint64(m.VirtualSize))
	}
	return n
}

func (m *Port) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.PrivatePort != 0 {
		n += 1 + sovMoby(uint64(m.PrivatePort))
	}
	if m.PublicPort != 0 {
		n += 1 + sovMoby(uint64(m.PublicPort))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *RootFS) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if len(m.Layers) > 0 {
		for _, s := range m.Layers {
			l = len(s)
			n += 1 + l + sovMoby(uint64(l))
		}
	}
	l = len(m.BaseLayer)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *ImageInspect) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if len(m.RepoTags) > 0 {
		for _, s := range m.RepoTags {
			l = len(s)
			n += 1 + l + sovMoby(uint64(l))
		}
	}
	if len(m.RepoDigests) > 0 {
		for _, s := range m.RepoDigests {
			l = len(s)
			n += 1 + l + sovMoby(uint64(l))
		}
	}
	l = len(m.Parent)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Created)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Container)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.ContainerConfig != nil {
		l = m.ContainerConfig.Size()
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.DockerVersion)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Architecture)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Os)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.OsVersion)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovMoby(uint64(m.Size_))
	}
	if m.VirtualSize != 0 {
		n += 2 + sovMoby(uint64(m.VirtualSize))
	}
	if m.GraphDriver != nil {
		l = m.GraphDriver.Size()
		n += 2 + l + sovMoby(uint64(l))
	}
	if m.RootFs != nil {
		l = m.RootFs.Size()
		n += 2 + l + sovMoby(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 2 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *ImageMetadata) Size() (n int) {
	var l int
	_ = l
	l = len(m.LastTagTime)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *Container) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovMoby(uint64(l))
		}
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.ImageId)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Command)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.Created != 0 {
		n += 1 + sovMoby(uint64(m.Created))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovMoby(uint64(l))
		}
	}
	if m.SizeRw != 0 {
		n += 1 + sovMoby(uint64(m.SizeRw))
	}
	if m.SizeRootFs != 0 {
		n += 1 + sovMoby(uint64(m.SizeRootFs))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMoby(uint64(len(k))) + 1 + len(v) + sovMoby(uint64(len(v)))
			n += mapEntrySize + 1 + sovMoby(uint64(mapEntrySize))
		}
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.HostConfig != nil {
		l = m.HostConfig.Size()
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.NetworkSettings != nil {
		l = m.NetworkSettings.Size()
		n += 1 + l + sovMoby(uint64(l))
	}
	if len(m.Mounts) > 0 {
		for _, e := range m.Mounts {
			l = e.Size()
			n += 1 + l + sovMoby(uint64(l))
		}
	}
	return n
}

func (m *Container_HostConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.NetworkMode)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *HealthcheckResult) Size() (n int) {
	var l int
	_ = l
	l = len(m.Start)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.End)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.ExitCode != 0 {
		n += 1 + sovMoby(uint64(m.ExitCode))
	}
	l = len(m.Output)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *Health) Size() (n int) {
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.FailingStreak != 0 {
		n += 1 + sovMoby(uint64(m.FailingStreak))
	}
	if len(m.Log) > 0 {
		for _, e := range m.Log {
			l = e.Size()
			n += 1 + l + sovMoby(uint64(l))
		}
	}
	return n
}

func (m *ContainerState) Size() (n int) {
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.Running {
		n += 2
	}
	if m.Paused {
		n += 2
	}
	if m.Restarting {
		n += 2
	}
	if m.OomKilled {
		n += 2
	}
	if m.Dead {
		n += 2
	}
	if m.Pid != 0 {
		n += 1 + sovMoby(uint64(m.Pid))
	}
	if m.ExitCode != 0 {
		n += 1 + sovMoby(uint64(m.ExitCode))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.StartedAt)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.FinishedAt)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.Health != nil {
		l = m.Health.Size()
		n += 1 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *ContainerNode) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.Cpus != 0 {
		n += 1 + sovMoby(uint64(m.Cpus))
	}
	if m.Memory != 0 {
		n += 1 + sovMoby(uint64(m.Memory))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMoby(uint64(len(k))) + 1 + len(v) + sovMoby(uint64(len(v)))
			n += mapEntrySize + 1 + sovMoby(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ContainerJSONBase) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Created)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovMoby(uint64(l))
		}
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.ResolvConfPath)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.HostnamePath)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.HostsPath)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.LogPath)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.RestartCount != 0 {
		n += 1 + sovMoby(uint64(m.RestartCount))
	}
	l = len(m.Driver)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.MountLabel)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.ProcessLabel)
	if l > 0 {
		n += 2 + l + sovMoby(uint64(l))
	}
	l = len(m.AppArmorProfile)
	if l > 0 {
		n += 2 + l + sovMoby(uint64(l))
	}
	if len(m.ExecIds) > 0 {
		for _, s := range m.ExecIds {
			l = len(s)
			n += 2 + l + sovMoby(uint64(l))
		}
	}
	if m.HostConfig != nil {
		l = m.HostConfig.Size()
		n += 2 + l + sovMoby(uint64(l))
	}
	if m.GraphDriver != nil {
		l = m.GraphDriver.Size()
		n += 2 + l + sovMoby(uint64(l))
	}
	if m.SizeRw != 0 {
		n += 2 + sovMoby(uint64(m.SizeRw))
	}
	if m.SizeRootFs != 0 {
		n += 2 + sovMoby(uint64(m.SizeRootFs))
	}
	return n
}

func (m *ContainerJSON) Size() (n int) {
	var l int
	_ = l
	if m.ContainerJsonBase != nil {
		l = m.ContainerJsonBase.Size()
		n += 1 + l + sovMoby(uint64(l))
	}
	if len(m.Mounts) > 0 {
		for _, e := range m.Mounts {
			l = e.Size()
			n += 1 + l + sovMoby(uint64(l))
		}
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.NetworkSettings != nil {
		l = m.NetworkSettings.Size()
		n += 1 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *NetworkSettings) Size() (n int) {
	var l int
	_ = l
	if m.NetworkSettingsBase != nil {
		l = m.NetworkSettingsBase.Size()
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.DefaultNetworkSettings != nil {
		l = m.DefaultNetworkSettings.Size()
		n += 1 + l + sovMoby(uint64(l))
	}
	if len(m.Networks) > 0 {
		for k, v := range m.Networks {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMoby(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMoby(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMoby(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SummaryNetworkSettings) Size() (n int) {
	var l int
	_ = l
	if len(m.Networks) > 0 {
		for k, v := range m.Networks {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMoby(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMoby(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMoby(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *NetworkSettingsBase) Size() (n int) {
	var l int
	_ = l
	l = len(m.Bridge)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.SandboxId)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.HairpinMode {
		n += 2
	}
	l = len(m.LinkLocalIpv6Address)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.LinkLocalIpv6PrefixLen != 0 {
		n += 1 + sovMoby(uint64(m.LinkLocalIpv6PrefixLen))
	}
	if m.Ports != nil {
		l = m.Ports.Size()
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.SandboxKey)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if len(m.SecondaryIpAddresses) > 0 {
		for _, e := range m.SecondaryIpAddresses {
			l = e.Size()
			n += 1 + l + sovMoby(uint64(l))
		}
	}
	if len(m.SecondaryIpv6Addresses) > 0 {
		for _, e := range m.SecondaryIpv6Addresses {
			l = e.Size()
			n += 1 + l + sovMoby(uint64(l))
		}
	}
	return n
}

func (m *DefaultNetworkSettings) Size() (n int) {
	var l int
	_ = l
	l = len(m.EndpointId)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Gateway)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.GlobalIpv6Address)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.GlobalIpv6PrefixLen != 0 {
		n += 1 + sovMoby(uint64(m.GlobalIpv6PrefixLen))
	}
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.IpPrefixLen != 0 {
		n += 1 + sovMoby(uint64(m.IpPrefixLen))
	}
	l = len(m.Ipv6Gateway)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *MountPoint) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Driver)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.Rw {
		n += 2
	}
	l = len(m.Propagation)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *NetworkResource) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Created)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Scope)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Driver)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.EnableIpv6 {
		n += 2
	}
	if m.Ipam != nil {
		l = m.Ipam.Size()
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.Internal {
		n += 2
	}
	if m.Attachable {
		n += 2
	}
	if m.Ingress {
		n += 2
	}
	if m.ConfigFrom != nil {
		l = m.ConfigFrom.Size()
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.ConfigOnly {
		n += 2
	}
	if len(m.Containers) > 0 {
		for k, v := range m.Containers {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMoby(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMoby(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMoby(uint64(mapEntrySize))
		}
	}
	if len(m.Options) > 0 {
		for k, v := range m.Options {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMoby(uint64(len(k))) + 1 + len(v) + sovMoby(uint64(len(v)))
			n += mapEntrySize + 1 + sovMoby(uint64(mapEntrySize))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMoby(uint64(len(k))) + 1 + len(v) + sovMoby(uint64(len(v)))
			n += mapEntrySize + 1 + sovMoby(uint64(mapEntrySize))
		}
	}
	if len(m.Peers) > 0 {
		for _, e := range m.Peers {
			l = e.Size()
			n += 2 + l + sovMoby(uint64(l))
		}
	}
	return n
}

func (m *EndpointResource) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.EndpointId)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Ipv4Address)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Ipv6Address)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *NetworkCreate) Size() (n int) {
	var l int
	_ = l
	if m.CheckDuplicate {
		n += 2
	}
	l = len(m.Driver)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Scope)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.EnableIpv6 {
		n += 2
	}
	if m.Ipam != nil {
		l = m.Ipam.Size()
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.Internal {
		n += 2
	}
	if m.Attachable {
		n += 2
	}
	if m.Ingress {
		n += 2
	}
	if m.ConfigOnly {
		n += 2
	}
	if m.ConfigFrom != nil {
		l = m.ConfigFrom.Size()
		n += 1 + l + sovMoby(uint64(l))
	}
	if len(m.Options) > 0 {
		for k, v := range m.Options {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMoby(uint64(len(k))) + 1 + len(v) + sovMoby(uint64(len(v)))
			n += mapEntrySize + 1 + sovMoby(uint64(mapEntrySize))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMoby(uint64(len(k))) + 1 + len(v) + sovMoby(uint64(len(v)))
			n += mapEntrySize + 1 + sovMoby(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *NetworkCreateRequest) Size() (n int) {
	var l int
	_ = l
	if m.NetworkCreate != nil {
		l = m.NetworkCreate.Size()
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *NetworkCreateResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.Warning)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *NetworkConnect) Size() (n int) {
	var l int
	_ = l
	l = len(m.Container)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.EndpointConfig != nil {
		l = m.EndpointConfig.Size()
		n += 1 + l + sovMoby(uint64(l))
	}
	return n
}

func (m *NetworkDisconnect) Size() (n int) {
	var l int
	_ = l
	l = len(m.Container)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.Force {
		n += 2
	}
	return n
}

func (m *NetworkInspectOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.Scope)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if m.Verbose {
		n += 2
	}
	return n
}

func (m *Image) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovMoby(uint64(l))
	}
	if len(m.RepoTags) > 0 {
		for _, s := range m.RepoTags {
			l = len(s)
			n += 1 + l + sovMoby(uint64(l))
		}
	}
	if len(m.RepoDigests) > 0 {
		for _, s := range m.RepoDigests {
			l = len(s)
			n += 1 + l + sovMoby(uint64(l))
		}
	}
	if m.Created != 0 {
		n += 1 + sovMoby(uint64(m.Created))
	}
	if m.Size_ != 0 {
		n += 1 + sovMoby(uint64(m.Size_))
	}
	if m.VirtualSize != 0 {
		n += 1 + sovMoby(uint64(m.VirtualSize))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMoby(uint64(len(k))) + 1 + len(v) + sovMoby(uint64(len(v)))
			n += mapEntrySize + 1 + sovMoby(uint64(mapEntrySize))
		}
	}
	return n
}

func sovMoby(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMoby(x uint64) (n int) {
	return sovMoby(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AuthConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Auth = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Serveraddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Serveraddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identitytoken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identitytoken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Registrytoken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Registrytoken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerListOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quiet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Quiet = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Size_ = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Latest = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Since", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Since = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Before = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filters == nil {
				m.Filters = &filters.Args{}
			}
			if err := m.Filters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkListOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filters == nil {
				m.Filters = &filters.Args{}
			}
			if err := m.Filters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageBuildOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageBuildOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageBuildOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuppressOutput", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SuppressOutput = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteContext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteContext = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoCache", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoCache = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Remove = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceRemove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceRemove = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PullParent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PullParent = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isolation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Isolation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSetCpus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuSetCpus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSetMems", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuSetMems = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuShares", wireType)
			}
			m.CpuShares = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuShares |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuQuota", wireType)
			}
			m.CpuQuota = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuQuota |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuPeriod", wireType)
			}
			m.CpuPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuPeriod |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemorySwap", wireType)
			}
			m.MemorySwap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemorySwap |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CgroupParent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CgroupParent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShmSize", wireType)
			}
			m.ShmSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShmSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dockerfile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dockerfile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ulimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ulimits = append(m.Ulimits, &units.Ulimit{})
			if err := m.Ulimits[len(m.Ulimits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildArgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BuildArgs == nil {
				m.BuildArgs = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoby
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthMoby
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMoby(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMoby
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BuildArgs[mapkey] = mapvalue
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthConfigs == nil {
				m.AuthConfigs = make(map[string]*AuthConfig)
			}
			var mapkey string
			var mapvalue *AuthConfig
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoby
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMoby
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthMoby
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AuthConfig{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMoby(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMoby
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AuthConfigs[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = append(m.Context[:0], dAtA[iNdEx:postIndex]...)
			if m.Context == nil {
				m.Context = []byte{}
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoby
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMoby(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMoby
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Squash", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Squash = bool(v != 0)
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheFrom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheFrom = append(m.CacheFrom, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityOpt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityOpt = append(m.SecurityOpt, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EextraHosts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EextraHosts = append(m.EextraHosts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageBuildResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageBuildResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageBuildResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OsType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageCreateOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageCreateOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageCreateOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistryAuth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegistryAuth = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageImportSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageImportSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageImportSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = append(m.Source[:0], dAtA[iNdEx:postIndex]...)
			if m.Source == nil {
				m.Source = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageImportOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageImportOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageImportOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageListOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filters == nil {
				m.Filters = &filters.Args{}
			}
			if err := m.Filters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageLoadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageLoadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageLoadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Json", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Json = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImagePullOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImagePullOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImagePullOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistryAuth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegistryAuth = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivilegeFunc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivilegeFunc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImagePushOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImagePushOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImagePushOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistryAuth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegistryAuth = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivilegeFunc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivilegeFunc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageRemoveOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageRemoveOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageRemoveOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PruneChildren", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PruneChildren = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageSearchOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageSearchOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageSearchOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistryAuth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegistryAuth = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivilegeFunc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivilegeFunc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filters == nil {
				m.Filters = &filters.Args{}
			}
			if err := m.Filters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GraphDriverData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphDriverData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphDriverData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoby
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMoby(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMoby
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Data[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			m.Containers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Containers |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Created |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoby
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMoby(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMoby
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoDigests", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoDigests = append(m.RepoDigests, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoTags = append(m.RepoTags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharedSize", wireType)
			}
			m.SharedSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SharedSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualSize", wireType)
			}
			m.VirtualSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VirtualSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Port) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Port: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Port: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivatePort", wireType)
			}
			m.PrivatePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrivatePort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicPort", wireType)
			}
			m.PublicPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PublicPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RootFS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RootFS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RootFS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Layers = append(m.Layers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseLayer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseLayer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageInspect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageInspect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageInspect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoTags = append(m.RepoTags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoDigests", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoDigests = append(m.RepoDigests, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Created = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Container = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerConfig == nil {
				m.ContainerConfig = &container.Config{}
			}
			if err := m.ContainerConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DockerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DockerVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &container.Config{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Architecture", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Architecture = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Os = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OsVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualSize", wireType)
			}
			m.VirtualSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VirtualSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphDriver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GraphDriver == nil {
				m.GraphDriver = &GraphDriverData{}
			}
			if err := m.GraphDriver.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootFs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RootFs == nil {
				m.RootFs = &RootFS{}
			}
			if err := m.RootFs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &ImageMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTagTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastTagTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Container) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Container: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Container: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Created |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &Port{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeRw", wireType)
			}
			m.SizeRw = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeRw |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeRootFs", wireType)
			}
			m.SizeRootFs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeRootFs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoby
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMoby(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMoby
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HostConfig == nil {
				m.HostConfig = &Container_HostConfig{}
			}
			if err := m.HostConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkSettings == nil {
				m.NetworkSettings = &SummaryNetworkSettings{}
			}
			if err := m.NetworkSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mounts = append(m.Mounts, &MountPoint{})
			if err := m.Mounts[len(m.Mounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Container_HostConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthcheckResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthcheckResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthcheckResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Start = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitCode", wireType)
			}
			m.ExitCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExitCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Output = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Health) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Health: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Health: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailingStreak", wireType)
			}
			m.FailingStreak = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FailingStreak |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Log = append(m.Log, &HealthcheckResult{})
			if err := m.Log[len(m.Log)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Running", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Running = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paused = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Restarting", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Restarting = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OomKilled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OomKilled = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dead = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitCode", wireType)
			}
			m.ExitCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExitCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FinishedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Health", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Health == nil {
				m.Health = &Health{}
			}
			if err := m.Health.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpus", wireType)
			}
			m.Cpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cpus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoby
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMoby(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMoby
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerJSONBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerJSONBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerJSONBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Created = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &ContainerState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvConfPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResolvConfPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostnamePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostnamePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostsPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostsPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &ContainerNode{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestartCount", wireType)
			}
			m.RestartCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RestartCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Driver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcessLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppArmorProfile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppArmorProfile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecIds = append(m.ExecIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HostConfig == nil {
				m.HostConfig = &container.HostConfig{}
			}
			if err := m.HostConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphDriver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GraphDriver == nil {
				m.GraphDriver = &GraphDriverData{}
			}
			if err := m.GraphDriver.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeRw", wireType)
			}
			m.SizeRw = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeRw |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeRootFs", wireType)
			}
			m.SizeRootFs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeRootFs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerJSON) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerJSON: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerJSON: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerJsonBase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerJsonBase == nil {
				m.ContainerJsonBase = &ContainerJSONBase{}
			}
			if err := m.ContainerJsonBase.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mounts = append(m.Mounts, &MountPoint{})
			if err := m.Mounts[len(m.Mounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &container.Config{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkSettings == nil {
				m.NetworkSettings = &NetworkSettings{}
			}
			if err := m.NetworkSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkSettingsBase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkSettingsBase == nil {
				m.NetworkSettingsBase = &NetworkSettingsBase{}
			}
			if err := m.NetworkSettingsBase.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultNetworkSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultNetworkSettings == nil {
				m.DefaultNetworkSettings = &DefaultNetworkSettings{}
			}
			if err := m.DefaultNetworkSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Networks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Networks == nil {
				m.Networks = make(map[string]*network.EndpointSettings)
			}
			var mapkey string
			var mapvalue *network.EndpointSettings
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoby
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMoby
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthMoby
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &network.EndpointSettings{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMoby(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMoby
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Networks[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SummaryNetworkSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SummaryNetworkSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SummaryNetworkSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Networks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Networks == nil {
				m.Networks = make(map[string]*network.EndpointSettings)
			}
			var mapkey string
			var mapvalue *network.EndpointSettings
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoby
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMoby
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthMoby
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &network.EndpointSettings{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMoby(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMoby
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Networks[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkSettingsBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkSettingsBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkSettingsBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bridge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bridge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SandboxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SandboxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HairpinMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HairpinMode = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkLocalIpv6Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkLocalIpv6Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkLocalIpv6PrefixLen", wireType)
			}
			m.LinkLocalIpv6PrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkLocalIpv6PrefixLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ports == nil {
				m.Ports = &nat.PortMap{}
			}
			if err := m.Ports.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SandboxKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SandboxKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryIpAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecondaryIpAddresses = append(m.SecondaryIpAddresses, &network.Address{})
			if err := m.SecondaryIpAddresses[len(m.SecondaryIpAddresses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryIpv6Addresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecondaryIpv6Addresses = append(m.SecondaryIpv6Addresses, &network.Address{})
			if err := m.SecondaryIpv6Addresses[len(m.SecondaryIpv6Addresses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefaultNetworkSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefaultNetworkSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefaultNetworkSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalIpv6Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GlobalIpv6Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalIpv6PrefixLen", wireType)
			}
			m.GlobalIpv6PrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalIpv6PrefixLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixLen", wireType)
			}
			m.IpPrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpPrefixLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6Gateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv6Gateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MountPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MountPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MountPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Driver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rw", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rw = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Propagation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Propagation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkResource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkResource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkResource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Created = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scope = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Driver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableIpv6", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableIpv6 = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ipam == nil {
				m.Ipam = &network.IPAM{}
			}
			if err := m.Ipam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Internal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Internal = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attachable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Attachable = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingress", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ingress = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigFrom == nil {
				m.ConfigFrom = &network.ConfigReference{}
			}
			if err := m.ConfigFrom.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConfigOnly = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Containers == nil {
				m.Containers = make(map[string]*EndpointResource)
			}
			var mapkey string
			var mapvalue *EndpointResource
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoby
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMoby
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthMoby
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &EndpointResource{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMoby(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMoby
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Containers[mapkey] = mapvalue
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoby
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMoby(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMoby
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Options[mapkey] = mapvalue
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoby
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMoby(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMoby
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peers = append(m.Peers, &network.PeerInfo{})
			if err := m.Peers[len(m.Peers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointResource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointResource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointResource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv6Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkCreate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkCreate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkCreate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckDuplicate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CheckDuplicate = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Driver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scope = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableIpv6", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableIpv6 = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ipam == nil {
				m.Ipam = &network.IPAM{}
			}
			if err := m.Ipam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Internal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Internal = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attachable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Attachable = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingress", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ingress = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConfigOnly = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigFrom == nil {
				m.ConfigFrom = &network.ConfigReference{}
			}
			if err := m.ConfigFrom.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoby
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMoby(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMoby
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Options[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoby
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMoby(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMoby
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkCreateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkCreateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkCreateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkCreate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkCreate == nil {
				m.NetworkCreate = &NetworkCreate{}
			}
			if err := m.NetworkCreate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkCreateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkCreateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkCreateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Warning", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Warning = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkConnect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkConnect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkConnect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Container = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndpointConfig == nil {
				m.EndpointConfig = &network.EndpointSettings{}
			}
			if err := m.EndpointConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkDisconnect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkDisconnect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkDisconnect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Container = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkInspectOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkInspectOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkInspectOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scope = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verbose", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Verbose = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Image) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Image: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Image: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoTags = append(m.RepoTags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoDigests", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoDigests = append(m.RepoDigests, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Created |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualSize", wireType)
			}
			m.VirtualSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VirtualSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMoby
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMoby
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMoby
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMoby
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMoby(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMoby
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMoby(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMoby
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMoby(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMoby
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMoby
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMoby
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMoby
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMoby(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMoby = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMoby   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("pb/moby/moby.proto", fileDescriptorMoby) }

var fileDescriptorMoby = []byte{
	// 3772 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x3a, 0x3b, 0x73, 0x1c, 0x47,
	0x7a, 0xde, 0xf7, 0xee, 0xb7, 0xbb, 0x78, 0x0c, 0x40, 0x70, 0x08, 0x89, 0x14, 0xb8, 0x3c, 0x1e,
	0x79, 0x2a, 0x17, 0x59, 0x45, 0x9e, 0x79, 0x27, 0x4a, 0x2e, 0x1b, 0x02, 0x45, 0x1e, 0x24, 0x3e,
	0x70, 0x03, 0x49, 0xe9, 0x54, 0x63, 0xa7, 0x77, 0x77, 0x8e, 0xb3, 0xd3, 0xa3, 0xee, 0x1e, 0x80,
	0x70, 0xe4, 0xc8, 0xd1, 0x65, 0x4e, 0x9c, 0x39, 0x77, 0xe0, 0x2a, 0x67, 0xae, 0x72, 0xe0, 0xf4,
	0x02, 0x07, 0x76, 0x62, 0x3b, 0xbc, 0x92, 0x9d, 0xbb, 0xca, 0xbf, 0xc0, 0xf5, 0x7d, 0xdd, 0x3d,
	0x3b, 0xb3, 0x58, 0x82, 0x52, 0xc9, 0x75, 0x0a, 0xb8, 0x98, 0xef, 0xd1, 0xaf, 0xef, 0xdd, 0x5f,
	0x13, 0xbc, 0xec, 0xe4, 0xfe, 0x5c, 0x9c, 0x9c, 0xd3, 0xcf, 0xbd, 0x4c, 0x0a, 0x2d, 0xbc, 0x26,
	0x7e, 0xef, 0xde, 0x74, 0x94, 0xb1, 0x48, 0x35, 0x8b, 0x53, 0x2e, 0x17, 0x5f, 0x86, 0x71, 0xf7,
	0xba, 0x63, 0x49, 0xb9, 0x3e, 0x13, 0xf2, 0xb5, 0xfb, 0x6b, 0xc9, 0xd7, 0x1c, 0x39, 0x4f, 0x63,
	0xad, 0xcc, 0xef, 0xf2, 0xc8, 0x49, 0x9c, 0x68, 0x2e, 0x95, 0xfb, 0x6b, 0xc9, 0x57, 0x8a, 0x89,
	0x99, 0xc6, 0x7f, 0x06, 0x3d, 0xfa, 0x7d, 0x0d, 0x60, 0x3f, 0xd7, 0xb3, 0x03, 0x91, 0x4e, 0xe2,
	0xa9, 0xb7, 0x0b, 0xdd, 0x5c, 0x71, 0x99, 0xb2, 0x39, 0xf7, 0x6b, 0x7b, 0xb5, 0xbb, 0xbd, 0xa0,
	0x80, 0x91, 0x96, 0x31, 0xa5, 0xce, 0x84, 0x8c, 0xfc, 0xba, 0xa1, 0x39, 0xd8, 0xf3, 0xa0, 0xc9,
	0x72, 0x3d, 0xf3, 0x1b, 0x84, 0xa7, 0x6f, 0x6f, 0x1b, 0x5a, 0x7c, 0xce, 0xe2, 0xc4, 0x6f, 0x12,
	0xd2, 0x00, 0xde, 0x4f, 0x60, 0xa8, 0xb8, 0x3c, 0xe5, 0x92, 0x45, 0x91, 0xe4, 0x4a, 0xf9, 0x2d,
	0xa2, 0x56, 0x91, 0xc8, 0x15, 0x47, 0x3c, 0xd5, 0xb1, 0x3e, 0xd7, 0xe2, 0x35, 0x4f, 0xfd, 0xb6,
	0xe1, 0xaa, 0x20, 0x91, 0x4b, 0xf2, 0x69, 0xac, 0xb4, 0xb4, 0x5c, 0x1d, 0xc3, 0x55, 0x41, 0x8e,
	0xfe, 0xa3, 0x06, 0xdb, 0x07, 0x4e, 0xcc, 0xcf, 0x63, 0xa5, 0x5f, 0x65, 0x3a, 0x16, 0xa9, 0xc2,
	0x0d, 0x7e, 0x93, 0xc7, 0x5c, 0xd3, 0x49, 0xbb, 0x81, 0x01, 0xf0, 0x28, 0x2a, 0xfe, 0x0b, 0x4e,
	0x47, 0xec, 0x06, 0xf4, 0xed, 0x6d, 0x40, 0x83, 0x25, 0x09, 0x9d, 0xae, 0x1b, 0xe0, 0xa7, 0xb7,
	0x03, 0xed, 0x84, 0x69, 0xae, 0x34, 0x9d, 0xae, 0x1b, 0x58, 0x08, 0xe7, 0x54, 0x71, 0x3a, 0xe6,
	0xf6, 0x58, 0x06, 0x40, 0xee, 0x13, 0x3e, 0x11, 0x92, 0xdb, 0x73, 0x58, 0x08, 0xb9, 0x93, 0x78,
	0x1e, 0x6b, 0xda, 0x78, 0x2b, 0x30, 0x80, 0x77, 0x07, 0x3a, 0x56, 0x77, 0x7e, 0x77, 0xaf, 0x76,
	0xb7, 0xff, 0x60, 0x78, 0xcf, 0xe9, 0x72, 0x5f, 0x4e, 0x55, 0xe0, 0xa8, 0xa3, 0x3f, 0x05, 0xef,
	0xa5, 0x31, 0x8f, 0xf2, 0xb1, 0x4a, 0xc3, 0x6b, 0x97, 0x0e, 0xff, 0x77, 0x80, 0xcd, 0xc3, 0x39,
	0x9b, 0xf2, 0x4f, 0xf3, 0x38, 0x89, 0xdc, 0x70, 0x0f, 0x9a, 0x9a, 0x4d, 0x71, 0x6c, 0x03, 0x55,
	0x89, 0xdf, 0xde, 0x1d, 0x58, 0x57, 0x79, 0x96, 0xa1, 0x6a, 0x42, 0x91, 0xeb, 0x2c, 0xd7, 0x56,
	0x3c, 0x6b, 0x0e, 0xfd, 0x8a, 0xb0, 0xde, 0x6d, 0x58, 0x93, 0x7c, 0x2e, 0x34, 0x0f, 0xd1, 0xb0,
	0xf9, 0x1b, 0x6d, 0x2d, 0x62, 0x68, 0xb0, 0x07, 0x06, 0xe9, 0x5d, 0x83, 0x6e, 0x2a, 0xc2, 0x31,
	0x1b, 0xcf, 0xb8, 0x95, 0x5f, 0x27, 0x15, 0x07, 0x08, 0xa2, 0xa8, 0x90, 0xf7, 0xd4, 0x48, 0xb0,
	0x1b, 0x58, 0xc8, 0xbb, 0x09, 0x83, 0x89, 0x90, 0x63, 0x1e, 0x5a, 0x6a, 0x9b, 0xa8, 0x7d, 0xc2,
	0x05, 0x86, 0xe5, 0x03, 0xe8, 0x67, 0x79, 0x92, 0x84, 0x19, 0x93, 0x3c, 0x35, 0x32, 0xed, 0x06,
	0x80, 0xa8, 0x23, 0xc2, 0x78, 0xef, 0x43, 0x2f, 0x56, 0x22, 0x61, 0x78, 0x50, 0x12, 0x6d, 0x2f,
	0x58, 0x20, 0xbc, 0x3d, 0x18, 0x8c, 0xb3, 0x3c, 0x54, 0x5c, 0x87, 0xe3, 0x2c, 0x57, 0x7e, 0x8f,
	0x18, 0x60, 0x9c, 0xe5, 0xc7, 0x5c, 0x1f, 0x64, 0xb9, 0x2a, 0x73, 0xcc, 0xf9, 0x5c, 0xf9, 0x50,
	0xe6, 0x78, 0xc1, 0xe7, 0xca, 0xbb, 0x0e, 0x40, 0x1c, 0x33, 0x26, 0xb9, 0xf2, 0xfb, 0x7b, 0xb5,
	0xbb, 0x8d, 0xa0, 0x87, 0x74, 0x42, 0x78, 0xef, 0x01, 0x02, 0xe1, 0x37, 0xb9, 0xd0, 0xcc, 0x1f,
	0x10, 0xb5, 0x3b, 0xce, 0xf2, 0x5f, 0x23, 0xec, 0xc6, 0x66, 0x5c, 0xc6, 0x22, 0xf2, 0x87, 0xc5,
	0xd8, 0x23, 0x42, 0xa0, 0x60, 0xe6, 0x7c, 0x2e, 0xe4, 0xb9, 0xbf, 0x46, 0x24, 0x0b, 0xe1, 0xa9,
	0xcd, 0x57, 0xa8, 0xce, 0x58, 0xe6, 0xaf, 0x13, 0x11, 0x0c, 0xea, 0xf8, 0x8c, 0x65, 0xde, 0x2d,
	0x18, 0x8e, 0xa7, 0x52, 0xe4, 0x99, 0x13, 0xcc, 0x06, 0x6d, 0x7b, 0x60, 0x90, 0x56, 0x34, 0x37,
	0x61, 0x60, 0x23, 0x4d, 0x38, 0x17, 0x11, 0xf7, 0x37, 0x89, 0xa7, 0x6f, 0x71, 0x2f, 0x44, 0xc4,
	0x51, 0x69, 0x6a, 0x36, 0x0f, 0xc9, 0x39, 0x3c, 0x5a, 0xa5, 0xa3, 0x66, 0xf3, 0x63, 0xf4, 0x8f,
	0x1b, 0x00, 0x91, 0x18, 0xbf, 0xe6, 0x72, 0x12, 0x27, 0xdc, 0xdf, 0x32, 0x62, 0x59, 0x60, 0xd0,
	0x24, 0x73, 0xb2, 0x6d, 0xe5, 0x6f, 0xef, 0x35, 0xc8, 0x24, 0x4d, 0xe8, 0xfa, 0x8a, 0xb0, 0x81,
	0xa3, 0x7a, 0x9f, 0x01, 0x9c, 0xa0, 0x31, 0x86, 0x4c, 0x4e, 0x95, 0x7f, 0x85, 0x78, 0x7f, 0x7a,
	0x8f, 0x02, 0xe9, 0x05, 0x4b, 0xbd, 0x47, 0x00, 0x9a, 0xf4, 0x67, 0xa9, 0x96, 0xe7, 0x41, 0xef,
	0xc4, 0xc1, 0xde, 0x17, 0x30, 0xc0, 0x10, 0x84, 0x46, 0x38, 0x89, 0xa7, 0xca, 0xdf, 0xa1, 0x89,
	0xee, 0xbe, 0x6d, 0xa2, 0x45, 0x00, 0xb4, 0x53, 0xf5, 0xd9, 0x02, 0xe3, 0xf9, 0xd0, 0x71, 0xc6,
	0x7c, 0x75, 0xaf, 0x76, 0x77, 0x10, 0x38, 0xd0, 0xfb, 0x18, 0x83, 0xc0, 0x09, 0x4f, 0x94, 0xef,
	0xd3, 0x02, 0xb7, 0xde, 0xb6, 0xc0, 0x73, 0xe2, 0x32, 0x73, 0xdb, 0x21, 0xa8, 0x4f, 0xf5, 0x4d,
	0xce, 0xd4, 0xcc, 0xbf, 0x66, 0x0c, 0xdd, 0x40, 0x64, 0x06, 0xe8, 0x09, 0xe1, 0x44, 0x8a, 0xb9,
	0xbf, 0x4b, 0x5e, 0xd8, 0x23, 0xcc, 0x53, 0x29, 0xe6, 0xa8, 0x28, 0xc5, 0xc7, 0xb9, 0x8c, 0xf5,
	0x79, 0x28, 0x32, 0xed, 0xbf, 0x47, 0x0c, 0x7d, 0x87, 0x7b, 0x95, 0x91, 0x2e, 0x39, 0x7f, 0xa3,
	0x25, 0x0b, 0x67, 0x42, 0x69, 0xe5, 0xbf, 0x6f, 0x58, 0x0c, 0xee, 0x57, 0x88, 0xc2, 0xc5, 0x35,
	0x93, 0x53, 0xae, 0xfd, 0xeb, 0x26, 0x20, 0x19, 0x08, 0x17, 0x57, 0x5c, 0xa9, 0x58, 0xa4, 0x61,
	0x1c, 0xf9, 0x37, 0x8c, 0x8b, 0x58, 0xcc, 0x61, 0x44, 0x29, 0x20, 0x61, 0x7a, 0x22, 0xe4, 0xdc,
	0xff, 0xc0, 0xa6, 0x00, 0x0b, 0xa3, 0x99, 0x19, 0xd5, 0x9d, 0x72, 0x89, 0xec, 0xfe, 0x9e, 0x31,
	0x33, 0x42, 0x7e, 0x6d, 0x70, 0x68, 0x43, 0x86, 0x29, 0x8e, 0xfc, 0x9b, 0x44, 0xef, 0x10, 0x7c,
	0x18, 0xed, 0x7e, 0x02, 0x6b, 0x55, 0x85, 0x62, 0xd4, 0x7d, 0xcd, 0xcf, 0x6d, 0x1e, 0xc2, 0x4f,
	0x8c, 0x97, 0xa7, 0x2c, 0xc9, 0x4d, 0x70, 0x1e, 0x04, 0x06, 0x78, 0x5c, 0xff, 0x65, 0x6d, 0xf7,
	0x08, 0x36, 0x96, 0xb5, 0xb8, 0x62, 0xfc, 0x4f, 0xcb, 0xe3, 0xfb, 0x0f, 0x36, 0x8c, 0xbe, 0x16,
	0x03, 0xcb, 0x33, 0x7e, 0x04, 0xfd, 0x92, 0xda, 0xde, 0xb5, 0x99, 0x5e, 0x69, 0xe8, 0x68, 0x1f,
	0xbc, 0x85, 0x0d, 0x04, 0x5c, 0x65, 0x22, 0x55, 0x1c, 0x03, 0xeb, 0x89, 0x88, 0xcc, 0x14, 0x83,
	0x80, 0xbe, 0xbd, 0xab, 0xd0, 0x11, 0x2a, 0xd4, 0xe7, 0x99, 0x9b, 0xa5, 0x2d, 0xd4, 0x97, 0xe7,
	0x19, 0x1f, 0x7d, 0x65, 0xa7, 0x38, 0x90, 0x9c, 0x69, 0xee, 0x62, 0xf3, 0xad, 0x45, 0xc2, 0x0b,
	0x29, 0xdf, 0x9a, 0xed, 0x0c, 0x1c, 0x12, 0x4f, 0x52, 0x51, 0x52, 0xbd, 0xaa, 0xa4, 0xd1, 0x73,
	0x1b, 0xf1, 0x0f, 0xe7, 0x99, 0x90, 0xfa, 0x58, 0xe4, 0xd2, 0x64, 0x27, 0x45, 0x5f, 0x76, 0x6b,
	0x16, 0xc2, 0xc8, 0x62, 0xbe, 0x42, 0xaa, 0x07, 0xcc, 0x5c, 0x60, 0x50, 0x2f, 0xd9, 0x9c, 0x8f,
	0x4e, 0xed, 0x26, 0xcd, 0x6c, 0x6e, 0x93, 0x1b, 0xd0, 0xd0, 0x6c, 0xea, 0x24, 0xa5, 0xd9, 0x14,
	0x3d, 0x68, 0xce, 0x95, 0x62, 0x53, 0x37, 0x89, 0x03, 0xc9, 0xb7, 0x66, 0x2c, 0x9d, 0x72, 0xe5,
	0x37, 0xc8, 0x4a, 0x1d, 0x58, 0x39, 0x45, 0x73, 0xe9, 0x14, 0x2f, 0x60, 0x83, 0xd6, 0x2d, 0x67,
	0x3d, 0x9b, 0xa2, 0x6b, 0x8b, 0x14, 0x5d, 0xca, 0x83, 0xf5, 0x4b, 0xf3, 0xe0, 0xc7, 0x56, 0x28,
	0xcf, 0x05, 0xbb, 0x5c, 0x5b, 0x1e, 0x34, 0x7f, 0xa3, 0x44, 0xea, 0x4a, 0x03, 0xfc, 0x1e, 0xfd,
	0xb6, 0x66, 0x37, 0x73, 0x94, 0x27, 0xc9, 0xdb, 0x37, 0x73, 0x41, 0x73, 0xf5, 0x15, 0x9a, 0xbb,
	0x0d, 0x6b, 0x99, 0x8c, 0x4f, 0xe3, 0x84, 0x4f, 0x79, 0x38, 0xc9, 0xd3, 0xb1, 0xcb, 0x9e, 0x05,
	0xf6, 0x69, 0x9e, 0x8e, 0x2f, 0x15, 0x4d, 0x69, 0x3b, 0x6a, 0xf6, 0xe3, 0x6f, 0xe7, 0xd7, 0xd6,
	0x42, 0x4c, 0x86, 0x2e, 0x15, 0x5e, 0x94, 0xb7, 0x5d, 0xe1, 0x45, 0x80, 0x59, 0x2e, 0x4f, 0x79,
	0x38, 0x9e, 0xc5, 0x49, 0x24, 0xb9, 0x93, 0xf3, 0x90, 0xb0, 0x07, 0x16, 0x39, 0xfa, 0xdb, 0x9a,
	0x9d, 0xf3, 0x98, 0x33, 0x39, 0x9e, 0x7d, 0x2f, 0xd7, 0xb8, 0x78, 0xa2, 0xfa, 0xaa, 0x13, 0x95,
	0x2c, 0xa7, 0x71, 0x99, 0xe5, 0x2c, 0xea, 0xb7, 0x66, 0xa9, 0x7e, 0x1b, 0xfd, 0x75, 0x0d, 0xd6,
	0x9f, 0x49, 0x96, 0xcd, 0x9e, 0xc8, 0xf8, 0x94, 0xcb, 0x27, 0x4c, 0x33, 0xef, 0x21, 0x34, 0x23,
	0xa6, 0x19, 0x55, 0x55, 0xfd, 0x07, 0x1f, 0x98, 0xc0, 0xb3, 0xc4, 0x74, 0x0f, 0x7f, 0x4c, 0x92,
	0x20, 0x66, 0xb4, 0xb7, 0x92, 0xe7, 0xd1, 0xf7, 0xee, 0x2f, 0xa0, 0x57, 0xb0, 0x7d, 0xaf, 0xa0,
	0xf4, 0x97, 0x0d, 0x18, 0x18, 0xb9, 0xe5, 0xf3, 0x39, 0x93, 0xe7, 0x98, 0xb4, 0x8b, 0xdb, 0x87,
	0x29, 0x15, 0x1b, 0x41, 0x09, 0x43, 0xbe, 0x49, 0xd1, 0xc7, 0x94, 0xfb, 0x8d, 0xc0, 0x81, 0xde,
	0x1a, 0xd4, 0xe3, 0xc8, 0x1a, 0x43, 0x3d, 0x8e, 0xbc, 0x47, 0x45, 0x1e, 0x6c, 0xd2, 0xf1, 0x6e,
	0x94, 0xf2, 0xa0, 0x5d, 0x6d, 0x65, 0x0a, 0x7c, 0x0f, 0x7a, 0xa6, 0x24, 0xc1, 0x74, 0xd0, 0x72,
	0x57, 0x0a, 0x44, 0x1c, 0x46, 0x98, 0xc5, 0x24, 0xcf, 0x44, 0x18, 0xc5, 0x53, 0x8e, 0x59, 0xac,
	0x6d, 0xb2, 0x18, 0xe2, 0x9e, 0x18, 0x14, 0x8e, 0x27, 0x16, 0xaa, 0x57, 0x3b, 0x44, 0xef, 0x22,
	0xe2, 0x4b, 0xac, 0x59, 0x31, 0x7a, 0x61, 0xd5, 0x15, 0x99, 0x8a, 0xa5, 0x6b, 0xce, 0x67, 0x50,
	0x54, 0xb4, 0xb8, 0x42, 0xbf, 0x47, 0x14, 0x53, 0xe8, 0xdf, 0x84, 0xc1, 0x69, 0x2c, 0x75, 0xce,
	0x12, 0x33, 0x0a, 0x88, 0xd6, 0xb7, 0x38, 0x1c, 0xf6, 0x43, 0xf2, 0x42, 0x0a, 0xcd, 0x23, 0x21,
	0x35, 0xc9, 0x2f, 0xb3, 0x43, 0xea, 0x71, 0x86, 0xab, 0xa2, 0x01, 0x32, 0xcd, 0x43, 0x0c, 0xa4,
	0x34, 0xb0, 0x15, 0xf4, 0x2d, 0x8e, 0x86, 0x50, 0x6d, 0x7b, 0x92, 0xc4, 0x63, 0xc3, 0xd1, 0x20,
	0x0e, 0x30, 0x28, 0x62, 0xc0, 0xb2, 0x1d, 0xd3, 0x88, 0xf1, 0x40, 0xfa, 0x1e, 0x1d, 0x43, 0x3b,
	0x10, 0x42, 0x3f, 0x3d, 0x2e, 0xa8, 0xb5, 0x05, 0xd5, 0x5c, 0x61, 0xce, 0x4d, 0x78, 0x44, 0xd1,
	0x59, 0x08, 0x6b, 0x80, 0x13, 0xa6, 0x78, 0x48, 0xa0, 0xd5, 0x72, 0x0f, 0x31, 0xcf, 0x11, 0x31,
	0xfa, 0x6d, 0xcb, 0xda, 0xd1, 0x61, 0xaa, 0x32, 0x3e, 0xd6, 0xd6, 0x1a, 0x6a, 0x85, 0x35, 0x54,
	0xb4, 0x52, 0x5f, 0xd2, 0xca, 0xb2, 0x56, 0x1b, 0x17, 0xb5, 0xba, 0x03, 0x6d, 0x5b, 0xa8, 0x9a,
	0xb3, 0x58, 0xc8, 0xd4, 0x61, 0xf3, 0x39, 0x12, 0x8c, 0xad, 0x38, 0xb0, 0x6c, 0xa9, 0x6d, 0x4b,
	0xb1, 0x96, 0xfa, 0x3e, 0xf4, 0x0a, 0x8b, 0xb6, 0xb7, 0xc3, 0x05, 0xc2, 0xfb, 0x04, 0x36, 0x0a,
	0xc0, 0xd6, 0x8a, 0xf6, 0xc6, 0xb5, 0x79, 0x6f, 0x71, 0x31, 0xb7, 0xa5, 0xc1, 0x7a, 0x81, 0xb1,
	0x77, 0xe5, 0xdb, 0xb0, 0x66, 0x4a, 0xdc, 0xa2, 0xe2, 0x31, 0x37, 0x86, 0xa1, 0xc1, 0xba, 0x92,
	0x67, 0x07, 0xda, 0x18, 0x8f, 0x84, 0xb4, 0xd7, 0x05, 0x0b, 0x79, 0x3f, 0x83, 0xb6, 0x5d, 0xb2,
	0xff, 0xb6, 0x25, 0x2d, 0x83, 0x37, 0x82, 0x01, 0x86, 0xba, 0x58, 0xf3, 0xb1, 0xce, 0x25, 0xa7,
	0x9b, 0x43, 0x2f, 0xa8, 0xe0, 0x50, 0x0b, 0x42, 0xd1, 0xad, 0xa1, 0x17, 0xd4, 0x05, 0x69, 0x51,
	0xa8, 0x62, 0x67, 0x6b, 0xe6, 0xe8, 0x42, 0xb9, 0x5d, 0x39, 0xe3, 0x5f, 0xbf, 0xc4, 0xf8, 0x37,
	0x2e, 0x18, 0xbf, 0xf7, 0x4b, 0x18, 0x4c, 0x31, 0x68, 0x85, 0x11, 0x45, 0x2d, 0xba, 0x26, 0xf4,
	0x1f, 0x5c, 0x59, 0x19, 0xce, 0x82, 0xfe, 0x74, 0x81, 0xf0, 0x6e, 0x43, 0x47, 0x0a, 0xa1, 0xc3,
	0x89, 0xa2, 0xcb, 0x43, 0xff, 0xc1, 0xc0, 0x0c, 0x32, 0x06, 0x1a, 0xb4, 0x91, 0xf8, 0x54, 0x79,
	0xf7, 0xa1, 0x3b, 0xe7, 0x9a, 0x51, 0xac, 0xdc, 0x22, 0xbe, 0xad, 0x52, 0x30, 0x79, 0x61, 0x49,
	0x41, 0xc1, 0x34, 0x7a, 0x08, 0xc3, 0x0a, 0xc9, 0x1b, 0xc1, 0x30, 0x61, 0x4a, 0xa3, 0xf9, 0x85,
	0x3a, 0x2e, 0xfa, 0x18, 0x7d, 0x44, 0x7e, 0xc9, 0xa6, 0x5f, 0xc6, 0x73, 0x3e, 0xfa, 0xdf, 0x26,
	0xf4, 0x8a, 0x96, 0xc0, 0x05, 0x03, 0xde, 0x86, 0x16, 0x86, 0x5a, 0x67, 0xbc, 0x06, 0x40, 0x6c,
	0x8c, 0x0b, 0x59, 0x8f, 0x30, 0x00, 0x16, 0xb4, 0xf4, 0x81, 0x11, 0xcc, 0x98, 0x6b, 0x87, 0xe0,
	0xc3, 0xc8, 0xd9, 0x2b, 0x4b, 0xa3, 0xb2, 0xbd, 0xb2, 0x34, 0x5a, 0xb6, 0xd7, 0x52, 0x64, 0xdd,
	0x83, 0x16, 0x7a, 0xb3, 0x89, 0x66, 0xfd, 0x07, 0x60, 0xce, 0x8e, 0xa8, 0xc0, 0x10, 0xb0, 0x62,
	0x44, 0xe5, 0x84, 0xf2, 0xcc, 0x86, 0xb4, 0x36, 0x82, 0xc1, 0x19, 0x5e, 0x4e, 0x0d, 0xc1, 0x4a,
	0xb9, 0x67, 0x03, 0x1e, 0x52, 0x8d, 0x6c, 0x1f, 0x16, 0x61, 0x1a, 0x68, 0xf6, 0xf7, 0xcc, 0xec,
	0x85, 0x20, 0x56, 0xc6, 0xe8, 0x6d, 0x68, 0x29, 0xcd, 0x34, 0x27, 0x2b, 0xed, 0x05, 0x06, 0xa0,
	0x92, 0x51, 0x33, 0x9d, 0x2b, 0x6b, 0x8b, 0x16, 0xf2, 0x3e, 0x86, 0x3e, 0xde, 0x39, 0x9c, 0x33,
	0x0d, 0x49, 0x83, 0xbb, 0xcb, 0xeb, 0xe0, 0x1d, 0xc4, 0x9a, 0x38, 0xcc, 0x8a, 0x6f, 0xef, 0x19,
	0x6c, 0xb8, 0x3b, 0xa8, 0xe2, 0x5a, 0xc7, 0xe9, 0x54, 0x91, 0xe1, 0xf6, 0x1f, 0xbc, 0x6f, 0x66,
	0xb0, 0xb9, 0xc4, 0xf6, 0x3c, 0x8e, 0x2d, 0x4f, 0xb0, 0x9e, 0x56, 0x11, 0xde, 0x5d, 0x68, 0xcf,
	0x45, 0x9e, 0x6a, 0xe5, 0xaf, 0xd3, 0x41, 0x6d, 0x9d, 0xff, 0x02, 0x71, 0x47, 0x22, 0x4e, 0x75,
	0x60, 0xe9, 0xbb, 0xf7, 0x01, 0x16, 0x9b, 0xb9, 0x70, 0x09, 0xae, 0x5d, 0xb8, 0x04, 0xff, 0x90,
	0xe8, 0x9f, 0xc1, 0xe6, 0xaf, 0x38, 0x4b, 0xf4, 0x6c, 0x3c, 0xe3, 0xe3, 0xd7, 0x01, 0x57, 0x79,
	0xa2, 0xad, 0x78, 0xa5, 0xb6, 0x53, 0x18, 0x00, 0xa7, 0xe5, 0xa9, 0xeb, 0xb2, 0xe1, 0x27, 0x06,
	0x55, 0xfe, 0x26, 0x46, 0xc1, 0x46, 0xdc, 0x46, 0xff, 0x2e, 0x22, 0x0e, 0xf0, 0x66, 0xbe, 0x03,
	0x6d, 0xdb, 0x95, 0xb1, 0x11, 0xd3, 0x40, 0x23, 0x09, 0x6d, 0xb3, 0x62, 0x49, 0x5f, 0xb5, 0x8a,
	0xbe, 0x6e, 0xc3, 0xda, 0x84, 0xc5, 0x49, 0x9c, 0x4e, 0x43, 0xa5, 0x25, 0x67, 0xaf, 0x6d, 0xee,
	0x19, 0x5a, 0xec, 0x31, 0x21, 0xbd, 0x9f, 0x41, 0x23, 0x11, 0x53, 0x0a, 0xd6, 0xfd, 0x07, 0x57,
	0x8d, 0x34, 0x2f, 0x9c, 0x25, 0x40, 0x9e, 0xd1, 0x7f, 0xd6, 0x61, 0xad, 0xd0, 0xf4, 0xf1, 0x92,
	0xb1, 0x54, 0x17, 0xf7, 0xa1, 0x23, 0xf3, 0x34, 0x8d, 0xd3, 0xa9, 0xad, 0xf4, 0x1c, 0x68, 0x52,
	0x40, 0xae, 0x78, 0x64, 0x5b, 0x6e, 0x16, 0xc2, 0x92, 0x45, 0x72, 0x12, 0x11, 0x0e, 0x32, 0x9d,
	0xa3, 0x12, 0x86, 0x82, 0x9e, 0x98, 0x87, 0xaf, 0xe3, 0x24, 0xe1, 0x91, 0x6d, 0x20, 0xf5, 0x84,
	0x98, 0x7f, 0x41, 0x08, 0x0c, 0x7a, 0x11, 0x67, 0x91, 0xed, 0x1d, 0xd1, 0x37, 0x8a, 0x3a, 0x8b,
	0x23, 0xdb, 0x80, 0xc3, 0xcf, 0xaa, 0xa8, 0xbb, 0x4b, 0xa2, 0xde, 0x86, 0x16, 0x97, 0x52, 0x48,
	0x1b, 0xeb, 0x0d, 0x40, 0xd7, 0x66, 0xdc, 0x03, 0x8f, 0x42, 0xa6, 0x6d, 0x9c, 0xef, 0x59, 0xcc,
	0x3e, 0x25, 0xef, 0x49, 0x9c, 0xc6, 0x6a, 0x66, 0xe8, 0xc6, 0x93, 0xc0, 0xa1, 0xf6, 0xb5, 0xf7,
	0x13, 0x68, 0xcf, 0x48, 0x9c, 0xe4, 0x4e, 0x45, 0x6c, 0x34, 0x22, 0x0e, 0x2c, 0x6d, 0xf4, 0x57,
	0x75, 0x18, 0x16, 0xa2, 0x7d, 0x89, 0xbb, 0x59, 0x8e, 0x5c, 0xd7, 0x01, 0xe2, 0x2c, 0x74, 0x9d,
	0xd5, 0xba, 0xed, 0x70, 0x65, 0xfb, 0xb6, 0xab, 0xea, 0x41, 0x13, 0x69, 0x45, 0x97, 0x36, 0x8a,
	0x64, 0x51, 0x63, 0x36, 0x17, 0x35, 0x26, 0xe2, 0xa8, 0x03, 0xd6, 0xa2, 0xc3, 0xd3, 0x77, 0xa9,
	0xfd, 0xd4, 0xae, 0xb4, 0x9f, 0x7e, 0x51, 0x04, 0x95, 0x4e, 0xb9, 0xb4, 0xad, 0xec, 0x73, 0x55,
	0x60, 0xf9, 0x21, 0x9e, 0xf4, 0xdf, 0x2d, 0xd8, 0x2c, 0x16, 0xf8, 0xfc, 0xf8, 0xd5, 0xcb, 0x4f,
	0x99, 0xba, 0x28, 0x8c, 0xa5, 0xfa, 0xb5, 0x54, 0x15, 0x78, 0xd0, 0xcc, 0xd8, 0xa2, 0x5b, 0x8d,
	0xdf, 0x24, 0x1b, 0x39, 0x35, 0x15, 0x2c, 0xca, 0x46, 0x4e, 0x95, 0xf7, 0xa1, 0x8b, 0x7d, 0x2d,
	0xd2, 0xca, 0xf6, 0xd2, 0xd1, 0xc8, 0xba, 0x5d, 0x44, 0x2c, 0xd2, 0x43, 0xbb, 0x9c, 0x1e, 0xee,
	0xc2, 0x86, 0xe4, 0x4a, 0x24, 0xa7, 0x14, 0x11, 0x43, 0x5a, 0xd5, 0x94, 0x21, 0x6b, 0x06, 0x8f,
	0x91, 0xe7, 0x08, 0xd7, 0xbf, 0x05, 0x43, 0x0c, 0x85, 0x28, 0x7f, 0xc3, 0x66, 0xfa, 0x93, 0x03,
	0x87, 0x24, 0xa6, 0xeb, 0x40, 0xf1, 0x52, 0x19, 0x0e, 0x63, 0x82, 0x3d, 0xc2, 0x10, 0xf9, 0x1a,
	0x74, 0x13, 0x31, 0x35, 0x44, 0x63, 0x84, 0x9d, 0x44, 0x4c, 0x89, 0x74, 0x07, 0x9a, 0x29, 0xda,
	0x73, 0xbf, 0x9c, 0x53, 0x2b, 0x4a, 0x0a, 0x88, 0xa1, 0xb0, 0x87, 0x41, 0xc9, 0x1e, 0xe8, 0x6e,
	0x45, 0xe6, 0x1c, 0x8e, 0x31, 0x6e, 0x52, 0x5c, 0x6f, 0xe1, 0xdd, 0x8a, 0x90, 0x07, 0x88, 0x43,
	0x03, 0xb1, 0x45, 0x81, 0x29, 0x36, 0x2c, 0x44, 0xfd, 0x49, 0x64, 0x08, 0x49, 0xef, 0x54, 0x70,
	0xf4, 0x02, 0x20, 0x14, 0xe9, 0x1f, 0x67, 0xcf, 0xa4, 0x18, 0x73, 0xa5, 0x2c, 0x8b, 0xed, 0x4f,
	0x5a, 0xa4, 0x61, 0xfa, 0x10, 0x36, 0x59, 0x96, 0x85, 0x4c, 0xce, 0x85, 0x0c, 0x33, 0x29, 0xa8,
	0xd1, 0x68, 0x9a, 0x94, 0xeb, 0x2c, 0xcb, 0xf6, 0x11, 0x7f, 0x64, 0xd0, 0x28, 0x06, 0xfe, 0x86,
	0x8f, 0xc3, 0x38, 0xc2, 0x5a, 0x83, 0xba, 0x0a, 0x08, 0x1f, 0x46, 0xca, 0x7b, 0x54, 0xcd, 0x4f,
	0x5b, 0xb6, 0x7c, 0x19, 0xbf, 0x2b, 0x35, 0x2d, 0xd7, 0x3d, 0xdb, 0xdf, 0xb9, 0xee, 0x29, 0xe5,
	0xeb, 0x2b, 0x97, 0xe6, 0xeb, 0x9d, 0xe5, 0x7c, 0x3d, 0xfa, 0x9f, 0x5a, 0xc9, 0xdf, 0xd1, 0xcc,
	0xbd, 0x67, 0xb0, 0xb5, 0x28, 0x58, 0x7f, 0xa3, 0x44, 0x1a, 0x62, 0x5d, 0x6e, 0xdb, 0xfc, 0x57,
	0x97, 0x94, 0xea, 0x1c, 0x23, 0xd8, 0x2c, 0xc6, 0x7c, 0xae, 0x44, 0x4a, 0xbe, 0xb2, 0xc8, 0x90,
	0xf5, 0xcb, 0x33, 0x64, 0xa9, 0x4c, 0x6d, 0xbc, 0xab, 0x4c, 0xfd, 0xf3, 0x15, 0xf9, 0xbb, 0x59,
	0x16, 0xd4, 0xbb, 0x12, 0xf7, 0xe8, 0xdf, 0xea, 0xb0, 0xbe, 0xc4, 0xe4, 0xbd, 0x80, 0x2b, 0xcb,
	0xb3, 0x96, 0x4f, 0x7d, 0x6d, 0xe5, 0xd4, 0x74, 0xee, 0xad, 0xf4, 0x22, 0xd2, 0xfb, 0x1a, 0xfc,
	0x88, 0x4f, 0x58, 0x9e, 0xe8, 0xf0, 0xc2, 0x66, 0xeb, 0xe5, 0x62, 0xe3, 0x89, 0xe1, 0x5a, 0xde,
	0xf3, 0x4e, 0xb4, 0x12, 0xef, 0xfd, 0x19, 0x74, 0xed, 0x7c, 0xca, 0xe6, 0xc9, 0x5b, 0x2b, 0x77,
	0xe6, 0x60, 0x1b, 0x0d, 0x8b, 0x41, 0xbb, 0x5f, 0xc3, 0xb0, 0x42, 0x5a, 0x11, 0x11, 0xef, 0x57,
	0xdb, 0x97, 0xd7, 0xee, 0xb9, 0xc7, 0xc1, 0xcf, 0xd2, 0x28, 0x43, 0xad, 0x15, 0xbb, 0x2c, 0x05,
	0xcb, 0x7f, 0xac, 0xc1, 0xce, 0xea, 0xc2, 0xc9, 0x7b, 0x5a, 0xda, 0xb3, 0x69, 0x4c, 0x7c, 0x78,
	0x59, 0xa1, 0xf5, 0x07, 0xdf, 0xfa, 0x3f, 0x35, 0x60, 0x6b, 0x85, 0x62, 0xe9, 0x39, 0x4d, 0xc6,
	0xd1, 0xd4, 0x55, 0x68, 0x16, 0xa2, 0x34, 0xcc, 0xd2, 0xe8, 0x44, 0xbc, 0xc1, 0x72, 0xdc, 0xa6,
	0x3f, 0x8b, 0x31, 0x1d, 0x85, 0x19, 0x8b, 0x65, 0x16, 0xa7, 0xa6, 0xbc, 0x33, 0xb5, 0x45, 0xdf,
	0xe2, 0xe8, 0x8d, 0xe3, 0x4f, 0xe0, 0x6a, 0x12, 0xa7, 0xaf, 0xc3, 0x44, 0x8c, 0x59, 0x12, 0xc6,
	0xd9, 0xe9, 0xa3, 0x22, 0x9b, 0x9a, 0x04, 0xb9, 0x8d, 0xe4, 0xe7, 0x48, 0x3d, 0xcc, 0x4e, 0x1f,
	0xb9, 0xc4, 0xfa, 0x18, 0x76, 0x97, 0x87, 0x65, 0x92, 0x4f, 0xe2, 0x37, 0x61, 0xc2, 0x53, 0x9b,
	0x46, 0x77, 0x2a, 0x23, 0x8f, 0x88, 0xfc, 0x9c, 0xa7, 0xde, 0x08, 0x5a, 0x19, 0x95, 0xfc, 0x6d,
	0x9b, 0xfa, 0x53, 0xa6, 0xa9, 0xe2, 0x7f, 0xc1, 0xb2, 0xc0, 0x90, 0xa8, 0x97, 0x61, 0x0f, 0x86,
	0x72, 0xed, 0xd8, 0x4e, 0xac, 0x41, 0x7d, 0xc1, 0xcf, 0xbd, 0xa7, 0xb0, 0xa3, 0xf8, 0x58, 0xa4,
	0x11, 0x93, 0xe7, 0xe1, 0xa2, 0x04, 0xe0, 0xca, 0xef, 0x5a, 0xff, 0x76, 0xf2, 0xb6, 0x5b, 0x0e,
	0xb6, 0x0b, 0xfe, 0x43, 0x57, 0x1f, 0x70, 0xe5, 0x7d, 0x0e, 0x7e, 0x79, 0x9e, 0xc5, 0xf1, 0x39,
	0x5e, 0x28, 0x56, 0xcf, 0xb4, 0x53, 0x9a, 0xa9, 0x10, 0x09, 0x57, 0xa3, 0x7f, 0xae, 0xc3, 0xce,
	0x6a, 0x27, 0xc2, 0xf3, 0x70, 0xab, 0xf7, 0xb0, 0xc8, 0xd9, 0xe0, 0x50, 0xe6, 0xee, 0x34, 0x65,
	0x9a, 0x9f, 0xb1, 0x73, 0x97, 0xbb, 0x2d, 0xe8, 0xdd, 0x83, 0xad, 0x69, 0x22, 0x4e, 0x96, 0xb5,
	0x63, 0x52, 0xf9, 0xa6, 0x21, 0x95, 0x55, 0xf3, 0x10, 0x76, 0xca, 0xfc, 0x25, 0xb5, 0x98, 0x9e,
	0xdd, 0xd6, 0x62, 0xc8, 0x42, 0x27, 0xd5, 0x3a, 0xaa, 0xb5, 0x5c, 0x47, 0x8d, 0x60, 0x18, 0x67,
	0xe5, 0xa9, 0xda, 0xa6, 0x61, 0x13, 0x67, 0x8b, 0x29, 0x6e, 0xc2, 0x80, 0x16, 0x74, 0xc7, 0x30,
	0x3a, 0xeb, 0x23, 0xee, 0x99, 0x3d, 0x0a, 0x66, 0x46, 0x36, 0x2e, 0x96, 0xe9, 0xda, 0xcc, 0xc8,
	0xc6, 0x76, 0x9d, 0xd1, 0xbf, 0xd4, 0x00, 0x16, 0x21, 0x79, 0x65, 0x13, 0x67, 0x45, 0x8b, 0xb0,
	0xd4, 0xcf, 0x6f, 0xd8, 0x7a, 0xdb, 0xf4, 0xf3, 0xf7, 0xa0, 0x1f, 0x71, 0xa5, 0xe3, 0xd4, 0x3c,
	0x80, 0x1a, 0x83, 0x2e, 0xa3, 0x4a, 0x39, 0xbc, 0x55, 0xc9, 0xe1, 0x1e, 0x34, 0xc9, 0x63, 0x4c,
	0x6d, 0x43, 0xdf, 0x58, 0x6e, 0xc9, 0x33, 0xfb, 0xc8, 0x5a, 0x97, 0x98, 0xcf, 0xfa, 0x99, 0x14,
	0x19, 0x9b, 0x96, 0x9f, 0x57, 0xcb, 0xa8, 0xd1, 0xdf, 0xb5, 0x8b, 0xe8, 0x1e, 0x70, 0xbb, 0x27,
	0xb7, 0xff, 0x5a, 0x69, 0xff, 0xa6, 0x90, 0xab, 0xaf, 0x2a, 0xe4, 0x1a, 0xd5, 0x42, 0x0e, 0x6f,
	0x4f, 0x63, 0x51, 0x74, 0xbd, 0x0c, 0xf0, 0xd6, 0x53, 0x90, 0xd5, 0xb1, 0x93, 0x84, 0x93, 0x29,
	0xd8, 0x5b, 0x00, 0x18, 0x14, 0xea, 0xdf, 0xbb, 0x09, 0xcd, 0x38, 0x63, 0x73, 0x3a, 0x54, 0xff,
	0xc1, 0xb0, 0xb0, 0xf4, 0xc3, 0xa3, 0xfd, 0x17, 0x01, 0x91, 0xbc, 0x5d, 0xe8, 0xc6, 0xa9, 0xe6,
	0x32, 0x65, 0x09, 0x1d, 0xb1, 0x1b, 0x14, 0x30, 0xde, 0x4e, 0x98, 0xd6, 0x6c, 0x3c, 0xc3, 0x09,
	0xa9, 0x3a, 0xeb, 0x06, 0x25, 0x0c, 0x9e, 0x23, 0x4e, 0xa7, 0xa4, 0x6b, 0x30, 0xf7, 0x1d, 0x0b,
	0x7a, 0x1f, 0x41, 0xdf, 0xe4, 0x50, 0xf3, 0xe8, 0x67, 0x8a, 0x34, 0xbf, 0x58, 0xdf, 0xe6, 0x59,
	0x3e, 0xe1, 0x92, 0xa7, 0x63, 0x4e, 0x5d, 0xda, 0x49, 0x3c, 0xa5, 0xf7, 0xc0, 0x0f, 0x8a, 0xa1,
	0x22, 0x4d, 0xce, 0xa9, 0x6c, 0xeb, 0x3a, 0x86, 0x57, 0x69, 0x72, 0xee, 0x7d, 0x56, 0x69, 0xf3,
	0x0e, 0xc9, 0x89, 0x6f, 0x57, 0x52, 0x93, 0x53, 0xc6, 0xa2, 0x74, 0xb0, 0x11, 0xbe, 0xdc, 0x0d,
	0xfe, 0x04, 0x3a, 0xc2, 0xb4, 0xda, 0xfd, 0x35, 0x9a, 0x63, 0xb4, 0x7a, 0x0e, 0xdb, 0x8f, 0x37,
	0x13, 0xb8, 0x21, 0xde, 0x47, 0xc5, 0x2d, 0xc1, 0xdc, 0xc8, 0x6f, 0xae, 0x1e, 0xbc, 0xaa, 0x01,
	0x71, 0x07, 0x5a, 0x19, 0xc7, 0xad, 0x6f, 0xd0, 0xc8, 0xcd, 0x42, 0x2a, 0x47, 0x9c, 0xcb, 0xc3,
	0x74, 0x22, 0x02, 0x43, 0xdf, 0xfd, 0x0a, 0xd6, 0x97, 0x0e, 0xb0, 0x22, 0x0f, 0xfd, 0x71, 0x35,
	0x0f, 0xed, 0x98, 0x7d, 0xb8, 0x24, 0xe4, 0x36, 0x52, 0x7e, 0x07, 0x7c, 0x0c, 0x83, 0xf2, 0x99,
	0xbe, 0xcf, 0x45, 0xe5, 0x87, 0xdc, 0x71, 0xfe, 0xbe, 0x06, 0x1b, 0xcb, 0xdb, 0x5a, 0xe9, 0x2d,
	0x4b, 0xb1, 0xb4, 0x7e, 0x21, 0x96, 0x2e, 0x85, 0x99, 0xc6, 0x72, 0x98, 0xb1, 0xa1, 0xea, 0xe7,
	0x4b, 0x99, 0x0e, 0x43, 0xd5, 0xcf, 0xab, 0x2c, 0x8f, 0x96, 0x42, 0x22, 0x45, 0x33, 0x17, 0xac,
	0x7e, 0xd7, 0x2c, 0xaa, 0x00, 0xf3, 0x68, 0xe9, 0xdd, 0x81, 0x75, 0x6a, 0x0f, 0x84, 0x51, 0x9e,
	0x25, 0xf1, 0x18, 0x2f, 0x52, 0xe6, 0xc1, 0x67, 0x8d, 0xd0, 0x4f, 0x1c, 0xb6, 0xe4, 0xb0, 0xf5,
	0x8a, 0xc3, 0x16, 0xee, 0xdd, 0x28, 0xbb, 0xf7, 0x92, 0x1b, 0x37, 0xdf, 0xea, 0xc6, 0xad, 0xef,
	0xe6, 0xc6, 0xed, 0x4b, 0xdd, 0xb8, 0x73, 0x99, 0x1b, 0x77, 0xab, 0x6e, 0xbc, 0xe4, 0x8b, 0xbd,
	0x0b, 0xbe, 0xb8, 0xe4, 0xe7, 0xf0, 0x3d, 0xfc, 0xfc, 0xf1, 0xc2, 0xff, 0xfa, 0xe4, 0x08, 0x7b,
	0x15, 0x17, 0x32, 0x22, 0x7f, 0x8b, 0xf7, 0x2d, 0xee, 0xe8, 0x83, 0xf2, 0x1d, 0xbd, 0x3a, 0x74,
	0xd5, 0x1d, 0xfd, 0x47, 0xb2, 0xfd, 0x09, 0x6c, 0x57, 0xf6, 0x16, 0xf0, 0x6f, 0x72, 0xae, 0xb4,
	0xf7, 0x18, 0xd6, 0x5c, 0xcd, 0x6e, 0x32, 0x80, 0xbd, 0x03, 0x6c, 0xad, 0x38, 0x4f, 0x30, 0x4c,
	0x2b, 0xc6, 0xe8, 0x41, 0xf3, 0x65, 0x29, 0x51, 0xd2, 0xfb, 0xf5, 0x3e, 0x5c, 0x59, 0x5a, 0xc7,
	0x3e, 0xfe, 0xae, 0x68, 0x25, 0x9c, 0x31, 0x59, 0x74, 0xaa, 0x7a, 0x81, 0x03, 0x47, 0x12, 0xd6,
	0xdc, 0x14, 0x22, 0x4d, 0xf9, 0x58, 0x57, 0x9f, 0x1c, 0x6a, 0xcb, 0x4f, 0x0e, 0x9f, 0xc2, 0x7a,
	0xe1, 0xad, 0xf6, 0x5e, 0xf5, 0xce, 0x8a, 0x78, 0xcd, 0x8d, 0x30, 0xf6, 0x31, 0x7a, 0x06, 0x9b,
	0x76, 0xcd, 0x27, 0xb1, 0x1a, 0x7f, 0xa7, 0x65, 0x8b, 0x17, 0xd7, 0x7a, 0xe9, 0xc5, 0x75, 0xf4,
	0xac, 0x38, 0xbf, 0x7d, 0xcb, 0x29, 0x3d, 0xd0, 0x1a, 0xc7, 0xab, 0x95, 0x1d, 0xcf, 0x87, 0xce,
	0x29, 0x97, 0x27, 0x42, 0xb9, 0x69, 0x1c, 0x38, 0xfa, 0x87, 0x3a, 0xb4, 0xa8, 0x0b, 0xbf, 0xea,
	0x31, 0x68, 0xf1, 0xc4, 0x57, 0x5f, 0x7a, 0xe2, 0xab, 0xbc, 0x14, 0x35, 0xde, 0xf1, 0x52, 0xd4,
	0xbc, 0xf8, 0x52, 0x54, 0x2a, 0x0c, 0x5a, 0xd5, 0x3e, 0xba, 0x7b, 0xde, 0x68, 0x5f, 0xf2, 0xbc,
	0xd1, 0xb9, 0xf8, 0xbc, 0x71, 0xbf, 0x70, 0x94, 0x6e, 0xb9, 0xd5, 0x49, 0x47, 0xfb, 0x7f, 0x6e,
	0x62, 0x7d, 0xba, 0xf1, 0xbb, 0x6f, 0x6f, 0xd4, 0xfe, 0xf5, 0xdb, 0x1b, 0xb5, 0xdf, 0x7f, 0x7b,
	0xa3, 0xf6, 0x37, 0xff, 0x75, 0xe3, 0x8f, 0x4e, 0xda, 0xf4, 0x5f, 0x32, 0x1f, 0xfe, 0x5f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x6c, 0xcd, 0x9d, 0x8d, 0x41, 0x2a, 0x00, 0x00,
}
