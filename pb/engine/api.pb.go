// Code generated by protoc-gen-gogo.
// source: pb/moby/api.proto
// DO NOT EDIT!

/*
	Package moby is a generated protocol buffer package.

	It is generated from these files:
		pb/moby/api.proto

	It has these top-level messages:
		HealthConfig
		Config
		LogConfig
		RestartPolicy
		Resources
		DeviceMapping
		HostConfig
		PortBinding
		PortMap
		PortSet
		VolumeMount
		BindOptions
		VolumeOptions
		DriverConfig
		TmpfsOptions
		WeightDevice
		ThrottleDevice
		Ulimit
		NetworkingConfig
		EndpointSettings
		EndpointIPAMConfig
		ImageSummary
		ImageInspect
		RootFS
		ImageMetadata
		GraphDriverData
		Port
		NetworkSettings
		SummaryNetworkSettings
		Address
		NetworkSettingsBase
		DefaultNetworkSettings
		MountPoint
		Container
		ContainerState
		ContainerNode
		ContainerJSONBase
		ContainerJSON
		NetworkResource
		EndpointResource
		NetworkCreate
		NetworkCreateRequest
		NetworkCreateResponse
		NetworkConnect
		NetworkDisconnect
		IPAM
		IPAMConfig
		Image
		ImageListOptions
		ContainerListOptions
		FiltersArgs
*/
package moby

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// HealthConfig holds configuration settings for the HEALTHCHECK feature.
// to see https://github.com/moby/moby/blob/master/api/types/container/config.go
type HealthConfig struct {
	// Test is the test to perform to check that the container is healthy.
	// An empty slice means to inherit the default.
	// The options are:
	// {} : inherit healthcheck
	// {"NONE"} : disable healthcheck
	// {"CMD", args...} : exec arguments directly
	// {"CMD-SHELL", command} : run command with system's default shell
	Test []string `protobuf:"bytes,1,rep,name=test" json:"test,omitempty"`
	// Zero means to inherit. Durations are expressed as integer nanoseconds.
	// Golang    time.Duration
	// Interval is the time to wait between checks.
	IntervalSeconds int64 `protobuf:"varint,2,opt,name=interval_seconds,json=intervalSeconds,proto3" json:"interval_seconds,omitempty"`
	// Golang     time.Duration
	// Timeout is the time to wait before considering the check to have hung.
	TimeoutSeconds int64 `protobuf:"varint,3,opt,name=timeout_seconds,json=timeoutSeconds,proto3" json:"timeout_seconds,omitempty"`
	// Golang time.Duration
	// The start period for the container to initialize before the retries starts to count down.
	StartPeriod int64 `protobuf:"varint,4,opt,name=start_period,json=startPeriod,proto3" json:"start_period,omitempty"`
	// Retries is the number of consecutive failures needed to consider a container as unhealthy.
	// Zero means inherit.
	Retries int32 `protobuf:"varint,5,opt,name=retries,proto3" json:"retries,omitempty"`
}

func (m *HealthConfig) Reset()                    { *m = HealthConfig{} }
func (m *HealthConfig) String() string            { return proto.CompactTextString(m) }
func (*HealthConfig) ProtoMessage()               {}
func (*HealthConfig) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{0} }

func (m *HealthConfig) GetTest() []string {
	if m != nil {
		return m.Test
	}
	return nil
}

func (m *HealthConfig) GetIntervalSeconds() int64 {
	if m != nil {
		return m.IntervalSeconds
	}
	return 0
}

func (m *HealthConfig) GetTimeoutSeconds() int64 {
	if m != nil {
		return m.TimeoutSeconds
	}
	return 0
}

func (m *HealthConfig) GetStartPeriod() int64 {
	if m != nil {
		return m.StartPeriod
	}
	return 0
}

func (m *HealthConfig) GetRetries() int32 {
	if m != nil {
		return m.Retries
	}
	return 0
}

// Config contains the configuration data about a container.
// It should hold only portable information about the container.
// Here, "portable" means "independent from the host we are running on".
// Non-portable information *should* appear in HostConfig.
// All fields added to this struct must be marked 'omitempty' to keep getting
// predictable hashes from the old 'v1Compatibility' configuration.
// to see https://github.com/moby/moby/blob/master/api/types/container/config.go
type Config struct {
	Hostname        string            `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Domainname      string            `protobuf:"bytes,2,opt,name=domainname,proto3" json:"domainname,omitempty"`
	User            string            `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
	AttachStdin     bool              `protobuf:"varint,4,opt,name=attach_stdin,json=attachStdin,proto3" json:"attach_stdin,omitempty"`
	AttachStdout    bool              `protobuf:"varint,5,opt,name=attach_stdout,json=attachStdout,proto3" json:"attach_stdout,omitempty"`
	AttachStderr    bool              `protobuf:"varint,6,opt,name=attach_stderr,json=attachStderr,proto3" json:"attach_stderr,omitempty"`
	ExposedPorts    *PortSet          `protobuf:"bytes,7,opt,name=exposed_ports,json=exposedPorts" json:"exposed_ports,omitempty"`
	Tty             bool              `protobuf:"varint,8,opt,name=tty,proto3" json:"tty,omitempty"`
	OpenStdin       bool              `protobuf:"varint,9,opt,name=open_stdin,json=openStdin,proto3" json:"open_stdin,omitempty"`
	StdinOnce       bool              `protobuf:"varint,10,opt,name=stdin_once,json=stdinOnce,proto3" json:"stdin_once,omitempty"`
	Env             []string          `protobuf:"bytes,11,rep,name=env" json:"env,omitempty"`
	Cmd             []string          `protobuf:"bytes,12,rep,name=cmd" json:"cmd,omitempty"`
	Healthcheck     *HealthConfig     `protobuf:"bytes,13,opt,name=healthcheck" json:"healthcheck,omitempty"`
	ArgsEscaped     bool              `protobuf:"varint,14,opt,name=args_escaped,json=argsEscaped,proto3" json:"args_escaped,omitempty"`
	Image           string            `protobuf:"bytes,15,opt,name=image,proto3" json:"image,omitempty"`
	Volumes         map[string]string `protobuf:"bytes,16,rep,name=volumes" json:"volumes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	WorkingDir      string            `protobuf:"bytes,17,opt,name=working_dir,json=workingDir,proto3" json:"working_dir,omitempty"`
	Entrypoint      []string          `protobuf:"bytes,18,rep,name=entrypoint" json:"entrypoint,omitempty"`
	NetworkDisabled bool              `protobuf:"varint,19,opt,name=network_disabled,json=networkDisabled,proto3" json:"network_disabled,omitempty"`
	MacAddress      string            `protobuf:"bytes,20,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	OnBuild         []string          `protobuf:"bytes,21,rep,name=on_build,json=onBuild" json:"on_build,omitempty"`
	Labels          map[string]string `protobuf:"bytes,22,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	StopSignal      string            `protobuf:"bytes,23,opt,name=stop_signal,json=stopSignal,proto3" json:"stop_signal,omitempty"`
	StopTimeout     int32             `protobuf:"varint,24,opt,name=stop_timeout,json=stopTimeout,proto3" json:"stop_timeout,omitempty"`
	Shell           []string          `protobuf:"bytes,25,rep,name=shell" json:"shell,omitempty"`
}

func (m *Config) Reset()                    { *m = Config{} }
func (m *Config) String() string            { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()               {}
func (*Config) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{1} }

func (m *Config) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Config) GetDomainname() string {
	if m != nil {
		return m.Domainname
	}
	return ""
}

func (m *Config) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *Config) GetAttachStdin() bool {
	if m != nil {
		return m.AttachStdin
	}
	return false
}

func (m *Config) GetAttachStdout() bool {
	if m != nil {
		return m.AttachStdout
	}
	return false
}

func (m *Config) GetAttachStderr() bool {
	if m != nil {
		return m.AttachStderr
	}
	return false
}

func (m *Config) GetExposedPorts() *PortSet {
	if m != nil {
		return m.ExposedPorts
	}
	return nil
}

func (m *Config) GetTty() bool {
	if m != nil {
		return m.Tty
	}
	return false
}

func (m *Config) GetOpenStdin() bool {
	if m != nil {
		return m.OpenStdin
	}
	return false
}

func (m *Config) GetStdinOnce() bool {
	if m != nil {
		return m.StdinOnce
	}
	return false
}

func (m *Config) GetEnv() []string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *Config) GetCmd() []string {
	if m != nil {
		return m.Cmd
	}
	return nil
}

func (m *Config) GetHealthcheck() *HealthConfig {
	if m != nil {
		return m.Healthcheck
	}
	return nil
}

func (m *Config) GetArgsEscaped() bool {
	if m != nil {
		return m.ArgsEscaped
	}
	return false
}

func (m *Config) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *Config) GetVolumes() map[string]string {
	if m != nil {
		return m.Volumes
	}
	return nil
}

func (m *Config) GetWorkingDir() string {
	if m != nil {
		return m.WorkingDir
	}
	return ""
}

func (m *Config) GetEntrypoint() []string {
	if m != nil {
		return m.Entrypoint
	}
	return nil
}

func (m *Config) GetNetworkDisabled() bool {
	if m != nil {
		return m.NetworkDisabled
	}
	return false
}

func (m *Config) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *Config) GetOnBuild() []string {
	if m != nil {
		return m.OnBuild
	}
	return nil
}

func (m *Config) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Config) GetStopSignal() string {
	if m != nil {
		return m.StopSignal
	}
	return ""
}

func (m *Config) GetStopTimeout() int32 {
	if m != nil {
		return m.StopTimeout
	}
	return 0
}

func (m *Config) GetShell() []string {
	if m != nil {
		return m.Shell
	}
	return nil
}

// LogConfig represents the logging configuration of the container.
// to see https://github.com/moby/moby/blob/master/api/types/container/host_config.go
type LogConfig struct {
	Type   string            `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Config map[string]string `protobuf:"bytes,2,rep,name=config" json:"config,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *LogConfig) Reset()                    { *m = LogConfig{} }
func (m *LogConfig) String() string            { return proto.CompactTextString(m) }
func (*LogConfig) ProtoMessage()               {}
func (*LogConfig) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{2} }

func (m *LogConfig) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *LogConfig) GetConfig() map[string]string {
	if m != nil {
		return m.Config
	}
	return nil
}

// RestartPolicy represents the restart policies of the container.
type RestartPolicy struct {
	Name              string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	MaximumRetryCount int32  `protobuf:"varint,2,opt,name=maximum_retry_count,json=maximumRetryCount,proto3" json:"maximum_retry_count,omitempty"`
}

func (m *RestartPolicy) Reset()                    { *m = RestartPolicy{} }
func (m *RestartPolicy) String() string            { return proto.CompactTextString(m) }
func (*RestartPolicy) ProtoMessage()               {}
func (*RestartPolicy) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{3} }

func (m *RestartPolicy) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RestartPolicy) GetMaximumRetryCount() int32 {
	if m != nil {
		return m.MaximumRetryCount
	}
	return 0
}

// Resources contains container's resources (cgroups config, ulimits...)
// to see https://github.com/moby/moby/blob/master/api/types/container/host_config.go
type Resources struct {
	// Applicable to all platforms
	CpuShares int64 `protobuf:"varint,1,opt,name=cpu_shares,json=cpuShares,proto3" json:"cpu_shares,omitempty"`
	Memory    int64 `protobuf:"varint,2,opt,name=memory,proto3" json:"memory,omitempty"`
	NanoCpus  int64 `protobuf:"varint,3,opt,name=nano_cpus,json=nanoCpus,proto3" json:"nano_cpus,omitempty"`
	// Applicable to UNIX platforms
	CgroupParent         string            `protobuf:"bytes,4,opt,name=cgroup_parent,json=cgroupParent,proto3" json:"cgroup_parent,omitempty"`
	BlkioWeight          int32             `protobuf:"varint,5,opt,name=blkio_weight,json=blkioWeight,proto3" json:"blkio_weight,omitempty"`
	BlkioWeightDevice    []*WeightDevice   `protobuf:"bytes,6,rep,name=blkio_weight_device,json=blkioWeightDevice" json:"blkio_weight_device,omitempty"`
	BlkioDeviceReadBps   []*ThrottleDevice `protobuf:"bytes,7,rep,name=blkio_device_read_bps,json=blkioDeviceReadBps" json:"blkio_device_read_bps,omitempty"`
	BlkioDeviceWriteBps  []*ThrottleDevice `protobuf:"bytes,8,rep,name=blkio_device_write_bps,json=blkioDeviceWriteBps" json:"blkio_device_write_bps,omitempty"`
	BlkioDeviceReadIops  []*ThrottleDevice `protobuf:"bytes,9,rep,name=blkio_device_read_iops,json=blkioDeviceReadIops" json:"blkio_device_read_iops,omitempty"`
	BlkioDeviceWriteIops []*ThrottleDevice `protobuf:"bytes,10,rep,name=blkio_device_write_iops,json=blkioDeviceWriteIops" json:"blkio_device_write_iops,omitempty"`
	CpuPeriod            int64             `protobuf:"varint,11,opt,name=cpu_period,json=cpuPeriod,proto3" json:"cpu_period,omitempty"`
	CpuQuota             int64             `protobuf:"varint,12,opt,name=cpu_quota,json=cpuQuota,proto3" json:"cpu_quota,omitempty"`
	CpuRealtimePeriod    int64             `protobuf:"varint,13,opt,name=cpu_realtime_period,json=cpuRealtimePeriod,proto3" json:"cpu_realtime_period,omitempty"`
	CpuRealtimeRuntime   int64             `protobuf:"varint,14,opt,name=cpu_realtime_runtime,json=cpuRealtimeRuntime,proto3" json:"cpu_realtime_runtime,omitempty"`
	CpusetCpus           string            `protobuf:"bytes,15,opt,name=cpuset_cpus,json=cpusetCpus,proto3" json:"cpuset_cpus,omitempty"`
	CpusetMems           string            `protobuf:"bytes,16,opt,name=cpuset_mems,json=cpusetMems,proto3" json:"cpuset_mems,omitempty"`
	Devices              []*DeviceMapping  `protobuf:"bytes,17,rep,name=devices" json:"devices,omitempty"`
	DeviceCgroupRules    []string          `protobuf:"bytes,18,rep,name=device_cgroup_rules,json=deviceCgroupRules" json:"device_cgroup_rules,omitempty"`
	DiskQuota            int64             `protobuf:"varint,19,opt,name=disk_quota,json=diskQuota,proto3" json:"disk_quota,omitempty"`
	KernelMemory         int64             `protobuf:"varint,20,opt,name=kernel_memory,json=kernelMemory,proto3" json:"kernel_memory,omitempty"`
	MemoryReservation    int64             `protobuf:"varint,21,opt,name=memory_reservation,json=memoryReservation,proto3" json:"memory_reservation,omitempty"`
	MemorySwap           int64             `protobuf:"varint,22,opt,name=memory_swap,json=memorySwap,proto3" json:"memory_swap,omitempty"`
	MemorySwappiness     int64             `protobuf:"varint,23,opt,name=memory_swappiness,json=memorySwappiness,proto3" json:"memory_swappiness,omitempty"`
	OomKillDisable       bool              `protobuf:"varint,24,opt,name=oom_kill_disable,json=oomKillDisable,proto3" json:"oom_kill_disable,omitempty"`
	PidsLimit            int64             `protobuf:"varint,25,opt,name=pids_limit,json=pidsLimit,proto3" json:"pids_limit,omitempty"`
	Ulimits              []*Ulimit         `protobuf:"bytes,26,rep,name=ulimits" json:"ulimits,omitempty"`
	// Applicable to Windows
	CpuCount           int64  `protobuf:"varint,27,opt,name=cpu_count,json=cpuCount,proto3" json:"cpu_count,omitempty"`
	CpuPercent         int64  `protobuf:"varint,28,opt,name=cpu_percent,json=cpuPercent,proto3" json:"cpu_percent,omitempty"`
	IoMaximumIops      uint64 `protobuf:"varint,29,opt,name=io_maximum_iops,json=ioMaximumIops,proto3" json:"io_maximum_iops,omitempty"`
	IoMaximumBandwidth uint64 `protobuf:"varint,30,opt,name=io_maximum_bandwidth,json=ioMaximumBandwidth,proto3" json:"io_maximum_bandwidth,omitempty"`
}

func (m *Resources) Reset()                    { *m = Resources{} }
func (m *Resources) String() string            { return proto.CompactTextString(m) }
func (*Resources) ProtoMessage()               {}
func (*Resources) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{4} }

func (m *Resources) GetCpuShares() int64 {
	if m != nil {
		return m.CpuShares
	}
	return 0
}

func (m *Resources) GetMemory() int64 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *Resources) GetNanoCpus() int64 {
	if m != nil {
		return m.NanoCpus
	}
	return 0
}

func (m *Resources) GetCgroupParent() string {
	if m != nil {
		return m.CgroupParent
	}
	return ""
}

func (m *Resources) GetBlkioWeight() int32 {
	if m != nil {
		return m.BlkioWeight
	}
	return 0
}

func (m *Resources) GetBlkioWeightDevice() []*WeightDevice {
	if m != nil {
		return m.BlkioWeightDevice
	}
	return nil
}

func (m *Resources) GetBlkioDeviceReadBps() []*ThrottleDevice {
	if m != nil {
		return m.BlkioDeviceReadBps
	}
	return nil
}

func (m *Resources) GetBlkioDeviceWriteBps() []*ThrottleDevice {
	if m != nil {
		return m.BlkioDeviceWriteBps
	}
	return nil
}

func (m *Resources) GetBlkioDeviceReadIops() []*ThrottleDevice {
	if m != nil {
		return m.BlkioDeviceReadIops
	}
	return nil
}

func (m *Resources) GetBlkioDeviceWriteIops() []*ThrottleDevice {
	if m != nil {
		return m.BlkioDeviceWriteIops
	}
	return nil
}

func (m *Resources) GetCpuPeriod() int64 {
	if m != nil {
		return m.CpuPeriod
	}
	return 0
}

func (m *Resources) GetCpuQuota() int64 {
	if m != nil {
		return m.CpuQuota
	}
	return 0
}

func (m *Resources) GetCpuRealtimePeriod() int64 {
	if m != nil {
		return m.CpuRealtimePeriod
	}
	return 0
}

func (m *Resources) GetCpuRealtimeRuntime() int64 {
	if m != nil {
		return m.CpuRealtimeRuntime
	}
	return 0
}

func (m *Resources) GetCpusetCpus() string {
	if m != nil {
		return m.CpusetCpus
	}
	return ""
}

func (m *Resources) GetCpusetMems() string {
	if m != nil {
		return m.CpusetMems
	}
	return ""
}

func (m *Resources) GetDevices() []*DeviceMapping {
	if m != nil {
		return m.Devices
	}
	return nil
}

func (m *Resources) GetDeviceCgroupRules() []string {
	if m != nil {
		return m.DeviceCgroupRules
	}
	return nil
}

func (m *Resources) GetDiskQuota() int64 {
	if m != nil {
		return m.DiskQuota
	}
	return 0
}

func (m *Resources) GetKernelMemory() int64 {
	if m != nil {
		return m.KernelMemory
	}
	return 0
}

func (m *Resources) GetMemoryReservation() int64 {
	if m != nil {
		return m.MemoryReservation
	}
	return 0
}

func (m *Resources) GetMemorySwap() int64 {
	if m != nil {
		return m.MemorySwap
	}
	return 0
}

func (m *Resources) GetMemorySwappiness() int64 {
	if m != nil {
		return m.MemorySwappiness
	}
	return 0
}

func (m *Resources) GetOomKillDisable() bool {
	if m != nil {
		return m.OomKillDisable
	}
	return false
}

func (m *Resources) GetPidsLimit() int64 {
	if m != nil {
		return m.PidsLimit
	}
	return 0
}

func (m *Resources) GetUlimits() []*Ulimit {
	if m != nil {
		return m.Ulimits
	}
	return nil
}

func (m *Resources) GetCpuCount() int64 {
	if m != nil {
		return m.CpuCount
	}
	return 0
}

func (m *Resources) GetCpuPercent() int64 {
	if m != nil {
		return m.CpuPercent
	}
	return 0
}

func (m *Resources) GetIoMaximumIops() uint64 {
	if m != nil {
		return m.IoMaximumIops
	}
	return 0
}

func (m *Resources) GetIoMaximumBandwidth() uint64 {
	if m != nil {
		return m.IoMaximumBandwidth
	}
	return 0
}

// DeviceMapping represents the device mapping between the host and the container.
type DeviceMapping struct {
	PathOnHost        string `protobuf:"bytes,1,opt,name=path_on_host,json=pathOnHost,proto3" json:"path_on_host,omitempty"`
	PathInContainer   string `protobuf:"bytes,2,opt,name=path_in_container,json=pathInContainer,proto3" json:"path_in_container,omitempty"`
	CgroupPermissions string `protobuf:"bytes,3,opt,name=cgroup_permissions,json=cgroupPermissions,proto3" json:"cgroup_permissions,omitempty"`
}

func (m *DeviceMapping) Reset()                    { *m = DeviceMapping{} }
func (m *DeviceMapping) String() string            { return proto.CompactTextString(m) }
func (*DeviceMapping) ProtoMessage()               {}
func (*DeviceMapping) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{5} }

func (m *DeviceMapping) GetPathOnHost() string {
	if m != nil {
		return m.PathOnHost
	}
	return ""
}

func (m *DeviceMapping) GetPathInContainer() string {
	if m != nil {
		return m.PathInContainer
	}
	return ""
}

func (m *DeviceMapping) GetCgroupPermissions() string {
	if m != nil {
		return m.CgroupPermissions
	}
	return ""
}

// HostConfig the non-portable Config structure of a container.
// Here, "non-portable" means "dependent of the host we are running on".
// Portable information *should* appear in Config.
// to see https://github.com/moby/moby/blob/master/api/types/container/host_config.go
type HostConfig struct {
	// Applicable to all platforms
	Binds           []string       `protobuf:"bytes,1,rep,name=binds" json:"binds,omitempty"`
	ContainerIdFile string         `protobuf:"bytes,2,opt,name=container_id_file,json=containerIdFile,proto3" json:"container_id_file,omitempty"`
	LogConfig       *LogConfig     `protobuf:"bytes,3,opt,name=log_config,json=logConfig" json:"log_config,omitempty"`
	NetworkMode     string         `protobuf:"bytes,4,opt,name=network_mode,json=networkMode,proto3" json:"network_mode,omitempty"`
	PortBindings    *PortMap       `protobuf:"bytes,5,opt,name=port_bindings,json=portBindings" json:"port_bindings,omitempty"`
	RestartPolicy   *RestartPolicy `protobuf:"bytes,6,opt,name=restart_policy,json=restartPolicy" json:"restart_policy,omitempty"`
	AutoRemove      bool           `protobuf:"varint,7,opt,name=auto_remove,json=autoRemove,proto3" json:"auto_remove,omitempty"`
	VolumeDriver    string         `protobuf:"bytes,8,opt,name=volume_driver,json=volumeDriver,proto3" json:"volume_driver,omitempty"`
	VolumesFrom     []string       `protobuf:"bytes,9,rep,name=volumes_from,json=volumesFrom" json:"volumes_from,omitempty"`
	// Applicable to UNIX platforms
	CapAdd          []string          `protobuf:"bytes,10,rep,name=cap_add,json=capAdd" json:"cap_add,omitempty"`
	CapDrop         []string          `protobuf:"bytes,11,rep,name=cap_drop,json=capDrop" json:"cap_drop,omitempty"`
	Dns             []string          `protobuf:"bytes,12,rep,name=dns" json:"dns,omitempty"`
	DnsOptions      []string          `protobuf:"bytes,13,rep,name=dns_options,json=dnsOptions" json:"dns_options,omitempty"`
	DnsSearch       []string          `protobuf:"bytes,14,rep,name=dns_search,json=dnsSearch" json:"dns_search,omitempty"`
	ExtraHosts      []string          `protobuf:"bytes,15,rep,name=extra_hosts,json=extraHosts" json:"extra_hosts,omitempty"`
	GroupAdd        []string          `protobuf:"bytes,16,rep,name=group_add,json=groupAdd" json:"group_add,omitempty"`
	IpcMode         string            `protobuf:"bytes,17,opt,name=ipc_mode,json=ipcMode,proto3" json:"ipc_mode,omitempty"`
	Cgroup          string            `protobuf:"bytes,18,opt,name=cgroup,proto3" json:"cgroup,omitempty"`
	Links           []string          `protobuf:"bytes,19,rep,name=links" json:"links,omitempty"`
	OomScoreAdj     int32             `protobuf:"varint,20,opt,name=oom_score_adj,json=oomScoreAdj,proto3" json:"oom_score_adj,omitempty"`
	PidMode         string            `protobuf:"bytes,21,opt,name=pid_mode,json=pidMode,proto3" json:"pid_mode,omitempty"`
	Privileged      bool              `protobuf:"varint,22,opt,name=privileged,proto3" json:"privileged,omitempty"`
	PublishAllPorts bool              `protobuf:"varint,23,opt,name=publish_all_ports,json=publishAllPorts,proto3" json:"publish_all_ports,omitempty"`
	ReadonlyRootfs  bool              `protobuf:"varint,24,opt,name=readonly_rootfs,json=readonlyRootfs,proto3" json:"readonly_rootfs,omitempty"`
	SecurityOpt     []string          `protobuf:"bytes,25,rep,name=security_opt,json=securityOpt" json:"security_opt,omitempty"`
	StorageOpt      map[string]string `protobuf:"bytes,26,rep,name=storage_opt,json=storageOpt" json:"storage_opt,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Tmpfs           map[string]string `protobuf:"bytes,27,rep,name=tmpfs" json:"tmpfs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	UtsMode         string            `protobuf:"bytes,28,opt,name=uts_mode,json=utsMode,proto3" json:"uts_mode,omitempty"`
	UsernsMode      string            `protobuf:"bytes,29,opt,name=userns_mode,json=usernsMode,proto3" json:"userns_mode,omitempty"`
	ShmSize         int64             `protobuf:"varint,30,opt,name=shm_size,json=shmSize,proto3" json:"shm_size,omitempty"`
	Sysctls         map[string]string `protobuf:"bytes,31,rep,name=sysctls" json:"sysctls,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Runtime         string            `protobuf:"bytes,32,opt,name=runtime,proto3" json:"runtime,omitempty"`
	// Applicable to Windows
	ConsoleSizeHeight uint32 `protobuf:"varint,33,opt,name=console_size_height,json=consoleSizeHeight,proto3" json:"console_size_height,omitempty"`
	ConsoleSizeWidth  uint32 `protobuf:"varint,34,opt,name=console_size_width,json=consoleSizeWidth,proto3" json:"console_size_width,omitempty"`
	Isolation         string `protobuf:"bytes,35,opt,name=isolation,proto3" json:"isolation,omitempty"`
	// Contains container's resources (cgroups, ulimits)
	Resources *Resources `protobuf:"bytes,36,opt,name=resources" json:"resources,omitempty"`
	// Mounts specs used by the container
	Mounts []*VolumeMount `protobuf:"bytes,37,rep,name=mounts" json:"mounts,omitempty"`
	// Run a custom init inside the container, if null, use the daemon's configured settings
	Init bool `protobuf:"varint,38,opt,name=init,proto3" json:"init,omitempty"`
}

func (m *HostConfig) Reset()                    { *m = HostConfig{} }
func (m *HostConfig) String() string            { return proto.CompactTextString(m) }
func (*HostConfig) ProtoMessage()               {}
func (*HostConfig) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{6} }

func (m *HostConfig) GetBinds() []string {
	if m != nil {
		return m.Binds
	}
	return nil
}

func (m *HostConfig) GetContainerIdFile() string {
	if m != nil {
		return m.ContainerIdFile
	}
	return ""
}

func (m *HostConfig) GetLogConfig() *LogConfig {
	if m != nil {
		return m.LogConfig
	}
	return nil
}

func (m *HostConfig) GetNetworkMode() string {
	if m != nil {
		return m.NetworkMode
	}
	return ""
}

func (m *HostConfig) GetPortBindings() *PortMap {
	if m != nil {
		return m.PortBindings
	}
	return nil
}

func (m *HostConfig) GetRestartPolicy() *RestartPolicy {
	if m != nil {
		return m.RestartPolicy
	}
	return nil
}

func (m *HostConfig) GetAutoRemove() bool {
	if m != nil {
		return m.AutoRemove
	}
	return false
}

func (m *HostConfig) GetVolumeDriver() string {
	if m != nil {
		return m.VolumeDriver
	}
	return ""
}

func (m *HostConfig) GetVolumesFrom() []string {
	if m != nil {
		return m.VolumesFrom
	}
	return nil
}

func (m *HostConfig) GetCapAdd() []string {
	if m != nil {
		return m.CapAdd
	}
	return nil
}

func (m *HostConfig) GetCapDrop() []string {
	if m != nil {
		return m.CapDrop
	}
	return nil
}

func (m *HostConfig) GetDns() []string {
	if m != nil {
		return m.Dns
	}
	return nil
}

func (m *HostConfig) GetDnsOptions() []string {
	if m != nil {
		return m.DnsOptions
	}
	return nil
}

func (m *HostConfig) GetDnsSearch() []string {
	if m != nil {
		return m.DnsSearch
	}
	return nil
}

func (m *HostConfig) GetExtraHosts() []string {
	if m != nil {
		return m.ExtraHosts
	}
	return nil
}

func (m *HostConfig) GetGroupAdd() []string {
	if m != nil {
		return m.GroupAdd
	}
	return nil
}

func (m *HostConfig) GetIpcMode() string {
	if m != nil {
		return m.IpcMode
	}
	return ""
}

func (m *HostConfig) GetCgroup() string {
	if m != nil {
		return m.Cgroup
	}
	return ""
}

func (m *HostConfig) GetLinks() []string {
	if m != nil {
		return m.Links
	}
	return nil
}

func (m *HostConfig) GetOomScoreAdj() int32 {
	if m != nil {
		return m.OomScoreAdj
	}
	return 0
}

func (m *HostConfig) GetPidMode() string {
	if m != nil {
		return m.PidMode
	}
	return ""
}

func (m *HostConfig) GetPrivileged() bool {
	if m != nil {
		return m.Privileged
	}
	return false
}

func (m *HostConfig) GetPublishAllPorts() bool {
	if m != nil {
		return m.PublishAllPorts
	}
	return false
}

func (m *HostConfig) GetReadonlyRootfs() bool {
	if m != nil {
		return m.ReadonlyRootfs
	}
	return false
}

func (m *HostConfig) GetSecurityOpt() []string {
	if m != nil {
		return m.SecurityOpt
	}
	return nil
}

func (m *HostConfig) GetStorageOpt() map[string]string {
	if m != nil {
		return m.StorageOpt
	}
	return nil
}

func (m *HostConfig) GetTmpfs() map[string]string {
	if m != nil {
		return m.Tmpfs
	}
	return nil
}

func (m *HostConfig) GetUtsMode() string {
	if m != nil {
		return m.UtsMode
	}
	return ""
}

func (m *HostConfig) GetUsernsMode() string {
	if m != nil {
		return m.UsernsMode
	}
	return ""
}

func (m *HostConfig) GetShmSize() int64 {
	if m != nil {
		return m.ShmSize
	}
	return 0
}

func (m *HostConfig) GetSysctls() map[string]string {
	if m != nil {
		return m.Sysctls
	}
	return nil
}

func (m *HostConfig) GetRuntime() string {
	if m != nil {
		return m.Runtime
	}
	return ""
}

func (m *HostConfig) GetConsoleSizeHeight() uint32 {
	if m != nil {
		return m.ConsoleSizeHeight
	}
	return 0
}

func (m *HostConfig) GetConsoleSizeWidth() uint32 {
	if m != nil {
		return m.ConsoleSizeWidth
	}
	return 0
}

func (m *HostConfig) GetIsolation() string {
	if m != nil {
		return m.Isolation
	}
	return ""
}

func (m *HostConfig) GetResources() *Resources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *HostConfig) GetMounts() []*VolumeMount {
	if m != nil {
		return m.Mounts
	}
	return nil
}

func (m *HostConfig) GetInit() bool {
	if m != nil {
		return m.Init
	}
	return false
}

// PortBinding represents a binding between a Host IP address and a Host Port
// to see https://github.com/docker/go-connections/blob/master/nat/nat.go
type PortBinding struct {
	// HostIP is the host IP Address
	HostIp   string `protobuf:"bytes,1,opt,name=host_ip,json=hostIp,proto3" json:"host_ip,omitempty"`
	HostPort string `protobuf:"bytes,2,opt,name=host_port,json=hostPort,proto3" json:"host_port,omitempty"`
}

func (m *PortBinding) Reset()                    { *m = PortBinding{} }
func (m *PortBinding) String() string            { return proto.CompactTextString(m) }
func (*PortBinding) ProtoMessage()               {}
func (*PortBinding) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{7} }

func (m *PortBinding) GetHostIp() string {
	if m != nil {
		return m.HostIp
	}
	return ""
}

func (m *PortBinding) GetHostPort() string {
	if m != nil {
		return m.HostPort
	}
	return ""
}

// PortMap is a collection of PortBinding indexed by Port
// to see https://github.com/docker/go-connections/blob/master/nat/nat.go
type PortMap struct {
	Value       map[string]*PortBinding          `protobuf:"bytes,1,rep,name=value" json:"value,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	MappingInfo map[string]*PortMap_PortBindings `protobuf:"bytes,2,rep,name=mapping_info,json=mappingInfo" json:"mapping_info,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *PortMap) Reset()                    { *m = PortMap{} }
func (m *PortMap) String() string            { return proto.CompactTextString(m) }
func (*PortMap) ProtoMessage()               {}
func (*PortMap) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{8} }

func (m *PortMap) GetValue() map[string]*PortBinding {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *PortMap) GetMappingInfo() map[string]*PortMap_PortBindings {
	if m != nil {
		return m.MappingInfo
	}
	return nil
}

type PortMap_PortBindings struct {
	PortBindings []*PortBinding `protobuf:"bytes,1,rep,name=port_bindings,json=portBindings" json:"port_bindings,omitempty"`
}

func (m *PortMap_PortBindings) Reset()                    { *m = PortMap_PortBindings{} }
func (m *PortMap_PortBindings) String() string            { return proto.CompactTextString(m) }
func (*PortMap_PortBindings) ProtoMessage()               {}
func (*PortMap_PortBindings) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{8, 0} }

func (m *PortMap_PortBindings) GetPortBindings() []*PortBinding {
	if m != nil {
		return m.PortBindings
	}
	return nil
}

// PortSet is a collection of structs indexed by Port
// to see https://github.com/docker/go-connections/blob/master/nat/nat.go
type PortSet struct {
	Value map[string]string `protobuf:"bytes,1,rep,name=value" json:"value,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *PortSet) Reset()                    { *m = PortSet{} }
func (m *PortSet) String() string            { return proto.CompactTextString(m) }
func (*PortSet) ProtoMessage()               {}
func (*PortSet) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{9} }

func (m *PortSet) GetValue() map[string]string {
	if m != nil {
		return m.Value
	}
	return nil
}

// Mount represents a mount (volume).
// to see https://github.com/moby/moby/blob/master/api/types/mount/mount.go
type VolumeMount struct {
	MountType string `protobuf:"bytes,1,opt,name=mount_type,json=mountType,proto3" json:"mount_type,omitempty"`
	// Source specifies the name of the mount. Depending on mount type, this
	// may be a volume name or a host path, or even ignored.
	// Source is not supported for tmpfs (must be an empty value)
	Source        string         `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	Target        string         `protobuf:"bytes,3,opt,name=target,proto3" json:"target,omitempty"`
	ReadOnly      string         `protobuf:"bytes,4,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	Consistency   string         `protobuf:"bytes,5,opt,name=consistency,proto3" json:"consistency,omitempty"`
	BindOptions   *BindOptions   `protobuf:"bytes,6,opt,name=bind_options,json=bindOptions" json:"bind_options,omitempty"`
	VolumeOptions *VolumeOptions `protobuf:"bytes,7,opt,name=volume_options,json=volumeOptions" json:"volume_options,omitempty"`
	TmpfsOptions  *TmpfsOptions  `protobuf:"bytes,8,opt,name=tmpfs_options,json=tmpfsOptions" json:"tmpfs_options,omitempty"`
}

func (m *VolumeMount) Reset()                    { *m = VolumeMount{} }
func (m *VolumeMount) String() string            { return proto.CompactTextString(m) }
func (*VolumeMount) ProtoMessage()               {}
func (*VolumeMount) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{10} }

func (m *VolumeMount) GetMountType() string {
	if m != nil {
		return m.MountType
	}
	return ""
}

func (m *VolumeMount) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *VolumeMount) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *VolumeMount) GetReadOnly() string {
	if m != nil {
		return m.ReadOnly
	}
	return ""
}

func (m *VolumeMount) GetConsistency() string {
	if m != nil {
		return m.Consistency
	}
	return ""
}

func (m *VolumeMount) GetBindOptions() *BindOptions {
	if m != nil {
		return m.BindOptions
	}
	return nil
}

func (m *VolumeMount) GetVolumeOptions() *VolumeOptions {
	if m != nil {
		return m.VolumeOptions
	}
	return nil
}

func (m *VolumeMount) GetTmpfsOptions() *TmpfsOptions {
	if m != nil {
		return m.TmpfsOptions
	}
	return nil
}

// BindOptions defines options specific to mounts of type "bind".
// to see https://github.com/moby/moby/blob/master/api/types/mount/mount.go
type BindOptions struct {
	Propagation string `protobuf:"bytes,1,opt,name=propagation,proto3" json:"propagation,omitempty"`
}

func (m *BindOptions) Reset()                    { *m = BindOptions{} }
func (m *BindOptions) String() string            { return proto.CompactTextString(m) }
func (*BindOptions) ProtoMessage()               {}
func (*BindOptions) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{11} }

func (m *BindOptions) GetPropagation() string {
	if m != nil {
		return m.Propagation
	}
	return ""
}

// VolumeOptions represents the options for a mount of type volume.
type VolumeOptions struct {
	NoCopy bool              `protobuf:"varint,1,opt,name=no_copy,json=noCopy,proto3" json:"no_copy,omitempty"`
	Labels map[string]string `protobuf:"bytes,2,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Driver *DriverConfig     `protobuf:"bytes,3,opt,name=driver" json:"driver,omitempty"`
}

func (m *VolumeOptions) Reset()                    { *m = VolumeOptions{} }
func (m *VolumeOptions) String() string            { return proto.CompactTextString(m) }
func (*VolumeOptions) ProtoMessage()               {}
func (*VolumeOptions) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{12} }

func (m *VolumeOptions) GetNoCopy() bool {
	if m != nil {
		return m.NoCopy
	}
	return false
}

func (m *VolumeOptions) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *VolumeOptions) GetDriver() *DriverConfig {
	if m != nil {
		return m.Driver
	}
	return nil
}

// Driver represents a volume driver.
type DriverConfig struct {
	Name    string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Options map[string]string `protobuf:"bytes,2,rep,name=options" json:"options,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *DriverConfig) Reset()                    { *m = DriverConfig{} }
func (m *DriverConfig) String() string            { return proto.CompactTextString(m) }
func (*DriverConfig) ProtoMessage()               {}
func (*DriverConfig) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{13} }

func (m *DriverConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DriverConfig) GetOptions() map[string]string {
	if m != nil {
		return m.Options
	}
	return nil
}

// TmpfsOptions defines options specific to mounts of type "tmpfs".
type TmpfsOptions struct {
	// Size sets the size of the tmpfs, in bytes.
	//
	// This will be converted to an operating system specific value
	// depending on the host. For example, on linux, it will be converted to
	// use a 'k', 'm' or 'g' syntax. BSD, though not widely supported with
	// docker, uses a straight byte value.
	//
	// Percentages are not supported.
	SizeBytes int64 `protobuf:"varint,1,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	// Mode of the tmpfs upon creation
	Mode uint32 `protobuf:"varint,2,opt,name=mode,proto3" json:"mode,omitempty"`
}

func (m *TmpfsOptions) Reset()                    { *m = TmpfsOptions{} }
func (m *TmpfsOptions) String() string            { return proto.CompactTextString(m) }
func (*TmpfsOptions) ProtoMessage()               {}
func (*TmpfsOptions) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{14} }

func (m *TmpfsOptions) GetSizeBytes() int64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *TmpfsOptions) GetMode() uint32 {
	if m != nil {
		return m.Mode
	}
	return 0
}

// WeightDevice is a structure that holds device:weight pair
// to see http://github.com/moby/moby/blob/master/api/types/blkiodev/blkio.go
type WeightDevice struct {
	Path   string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Weight int32  `protobuf:"varint,2,opt,name=weight,proto3" json:"weight,omitempty"`
}

func (m *WeightDevice) Reset()                    { *m = WeightDevice{} }
func (m *WeightDevice) String() string            { return proto.CompactTextString(m) }
func (*WeightDevice) ProtoMessage()               {}
func (*WeightDevice) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{15} }

func (m *WeightDevice) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *WeightDevice) GetWeight() int32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

// ThrottleDevice is a structure that holds device:rate_per_second pair
// to see http://github.com/moby/moby/blob/master/api/types/blkiodev/blkio.go
type ThrottleDevice struct {
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Rate uint64 `protobuf:"varint,2,opt,name=rate,proto3" json:"rate,omitempty"`
}

func (m *ThrottleDevice) Reset()                    { *m = ThrottleDevice{} }
func (m *ThrottleDevice) String() string            { return proto.CompactTextString(m) }
func (*ThrottleDevice) ProtoMessage()               {}
func (*ThrottleDevice) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{16} }

func (m *ThrottleDevice) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *ThrottleDevice) GetRate() uint64 {
	if m != nil {
		return m.Rate
	}
	return 0
}

// Ulimit is a human friendly version of Rlimit.
// to see https://github.com/docker/go-units/blob/master/ulimit.go
type Ulimit struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Hard int64  `protobuf:"varint,2,opt,name=hard,proto3" json:"hard,omitempty"`
	Soft int64  `protobuf:"varint,3,opt,name=soft,proto3" json:"soft,omitempty"`
}

func (m *Ulimit) Reset()                    { *m = Ulimit{} }
func (m *Ulimit) String() string            { return proto.CompactTextString(m) }
func (*Ulimit) ProtoMessage()               {}
func (*Ulimit) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{17} }

func (m *Ulimit) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Ulimit) GetHard() int64 {
	if m != nil {
		return m.Hard
	}
	return 0
}

func (m *Ulimit) GetSoft() int64 {
	if m != nil {
		return m.Soft
	}
	return 0
}

// NetworkingConfig represents the container's networking configuration for each of its interfaces
// Carries the networking configs specified in the 'docker run' and 'docker network connect' commands
// to see https://github.com/moby/moby/blob/master/api/types/network/network.go
type NetworkingConfig struct {
	EndpointsConfig map[string]*EndpointSettings `protobuf:"bytes,1,rep,name=endpoints_config,json=endpointsConfig" json:"endpoints_config,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *NetworkingConfig) Reset()                    { *m = NetworkingConfig{} }
func (m *NetworkingConfig) String() string            { return proto.CompactTextString(m) }
func (*NetworkingConfig) ProtoMessage()               {}
func (*NetworkingConfig) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{18} }

func (m *NetworkingConfig) GetEndpointsConfig() map[string]*EndpointSettings {
	if m != nil {
		return m.EndpointsConfig
	}
	return nil
}

// EndpointSettings stores the network endpoint details
type EndpointSettings struct {
	// Configurations
	IpamConfig *EndpointIPAMConfig `protobuf:"bytes,1,opt,name=ipam_config,json=ipamConfig" json:"ipam_config,omitempty"`
	Links      []string            `protobuf:"bytes,2,rep,name=links" json:"links,omitempty"`
	Aliases    []string            `protobuf:"bytes,3,rep,name=aliases" json:"aliases,omitempty"`
	// Operational data
	NetworkId           string            `protobuf:"bytes,4,opt,name=network_id,json=networkId,proto3" json:"network_id,omitempty"`
	EndpointId          string            `protobuf:"bytes,5,opt,name=endpoint_id,json=endpointId,proto3" json:"endpoint_id,omitempty"`
	Gateway             string            `protobuf:"bytes,6,opt,name=gateway,proto3" json:"gateway,omitempty"`
	IpAddress           string            `protobuf:"bytes,7,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	IpPrefixLen         int32             `protobuf:"varint,8,opt,name=ip_prefix_len,json=ipPrefixLen,proto3" json:"ip_prefix_len,omitempty"`
	Ipv6Gateway         string            `protobuf:"bytes,9,opt,name=ipv6_gateway,json=ipv6Gateway,proto3" json:"ipv6_gateway,omitempty"`
	GlobalIpv6Address   string            `protobuf:"bytes,10,opt,name=global_ipv6_address,json=globalIpv6Address,proto3" json:"global_ipv6_address,omitempty"`
	GlobalIpv6PrefixLen int32             `protobuf:"varint,11,opt,name=global_ipv6_prefix_len,json=globalIpv6PrefixLen,proto3" json:"global_ipv6_prefix_len,omitempty"`
	MacAddress          string            `protobuf:"bytes,12,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	DriverOpts          map[string]string `protobuf:"bytes,13,rep,name=driver_opts,json=driverOpts" json:"driver_opts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *EndpointSettings) Reset()                    { *m = EndpointSettings{} }
func (m *EndpointSettings) String() string            { return proto.CompactTextString(m) }
func (*EndpointSettings) ProtoMessage()               {}
func (*EndpointSettings) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{19} }

func (m *EndpointSettings) GetIpamConfig() *EndpointIPAMConfig {
	if m != nil {
		return m.IpamConfig
	}
	return nil
}

func (m *EndpointSettings) GetLinks() []string {
	if m != nil {
		return m.Links
	}
	return nil
}

func (m *EndpointSettings) GetAliases() []string {
	if m != nil {
		return m.Aliases
	}
	return nil
}

func (m *EndpointSettings) GetNetworkId() string {
	if m != nil {
		return m.NetworkId
	}
	return ""
}

func (m *EndpointSettings) GetEndpointId() string {
	if m != nil {
		return m.EndpointId
	}
	return ""
}

func (m *EndpointSettings) GetGateway() string {
	if m != nil {
		return m.Gateway
	}
	return ""
}

func (m *EndpointSettings) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *EndpointSettings) GetIpPrefixLen() int32 {
	if m != nil {
		return m.IpPrefixLen
	}
	return 0
}

func (m *EndpointSettings) GetIpv6Gateway() string {
	if m != nil {
		return m.Ipv6Gateway
	}
	return ""
}

func (m *EndpointSettings) GetGlobalIpv6Address() string {
	if m != nil {
		return m.GlobalIpv6Address
	}
	return ""
}

func (m *EndpointSettings) GetGlobalIpv6PrefixLen() int32 {
	if m != nil {
		return m.GlobalIpv6PrefixLen
	}
	return 0
}

func (m *EndpointSettings) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *EndpointSettings) GetDriverOpts() map[string]string {
	if m != nil {
		return m.DriverOpts
	}
	return nil
}

// EndpointIPAMConfig represents IPAM configurations for the endpoint
type EndpointIPAMConfig struct {
	Ipv4Address  string   `protobuf:"bytes,1,opt,name=ipv4_address,json=ipv4Address,proto3" json:"ipv4_address,omitempty"`
	Ipv6Address  string   `protobuf:"bytes,2,opt,name=ipv6_address,json=ipv6Address,proto3" json:"ipv6_address,omitempty"`
	LinkLocalIps []string `protobuf:"bytes,3,rep,name=link_local_ips,json=linkLocalIps" json:"link_local_ips,omitempty"`
}

func (m *EndpointIPAMConfig) Reset()                    { *m = EndpointIPAMConfig{} }
func (m *EndpointIPAMConfig) String() string            { return proto.CompactTextString(m) }
func (*EndpointIPAMConfig) ProtoMessage()               {}
func (*EndpointIPAMConfig) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{20} }

func (m *EndpointIPAMConfig) GetIpv4Address() string {
	if m != nil {
		return m.Ipv4Address
	}
	return ""
}

func (m *EndpointIPAMConfig) GetIpv6Address() string {
	if m != nil {
		return m.Ipv6Address
	}
	return ""
}

func (m *EndpointIPAMConfig) GetLinkLocalIps() []string {
	if m != nil {
		return m.LinkLocalIps
	}
	return nil
}

// ImageSummary image summary
// swagger:model ImageSummary
type ImageSummary struct {
	// containers
	// Required: true
	Containers int64 `protobuf:"varint,1,opt,name=containers,proto3" json:"containers,omitempty"`
	// created
	// Required: true
	Created int64 `protobuf:"varint,2,opt,name=created,proto3" json:"created,omitempty"`
	// Id
	// Required: true
	Id string `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
	// labels
	// Required: true
	Labels map[string]string `protobuf:"bytes,4,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// parent Id
	// Required: true
	ParentId string `protobuf:"bytes,5,opt,name=parent_id,json=parentId,proto3" json:"parent_id,omitempty"`
	// repo digests
	// Required: true
	RepoDigests []string `protobuf:"bytes,6,rep,name=repo_digests,json=repoDigests" json:"repo_digests,omitempty"`
	// repo tags
	// Required: true
	RepoTags []string `protobuf:"bytes,7,rep,name=repo_tags,json=repoTags" json:"repo_tags,omitempty"`
	// shared size
	// Required: true
	SharedSize int64 `protobuf:"varint,8,opt,name=shared_size,json=sharedSize,proto3" json:"shared_size,omitempty"`
	// size
	// Required: true
	Size_ int64 `protobuf:"varint,9,opt,name=size,proto3" json:"size,omitempty"`
	// virtual size
	// Required: true
	VirtualSize int64 `protobuf:"varint,10,opt,name=virtual_size,json=virtualSize,proto3" json:"virtual_size,omitempty"`
}

func (m *ImageSummary) Reset()                    { *m = ImageSummary{} }
func (m *ImageSummary) String() string            { return proto.CompactTextString(m) }
func (*ImageSummary) ProtoMessage()               {}
func (*ImageSummary) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{21} }

func (m *ImageSummary) GetContainers() int64 {
	if m != nil {
		return m.Containers
	}
	return 0
}

func (m *ImageSummary) GetCreated() int64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *ImageSummary) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ImageSummary) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ImageSummary) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *ImageSummary) GetRepoDigests() []string {
	if m != nil {
		return m.RepoDigests
	}
	return nil
}

func (m *ImageSummary) GetRepoTags() []string {
	if m != nil {
		return m.RepoTags
	}
	return nil
}

func (m *ImageSummary) GetSharedSize() int64 {
	if m != nil {
		return m.SharedSize
	}
	return 0
}

func (m *ImageSummary) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *ImageSummary) GetVirtualSize() int64 {
	if m != nil {
		return m.VirtualSize
	}
	return 0
}

// ImageInspect contains response of Engine API:
// GET "/images/{name:.*}/json"
type ImageInspect struct {
	Id              string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	RepoTags        []string         `protobuf:"bytes,2,rep,name=repo_tags,json=repoTags" json:"repo_tags,omitempty"`
	RepoDigests     []string         `protobuf:"bytes,3,rep,name=repo_digests,json=repoDigests" json:"repo_digests,omitempty"`
	Parent          string           `protobuf:"bytes,4,opt,name=parent,proto3" json:"parent,omitempty"`
	Comment         string           `protobuf:"bytes,5,opt,name=comment,proto3" json:"comment,omitempty"`
	Created         string           `protobuf:"bytes,6,opt,name=created,proto3" json:"created,omitempty"`
	Container       string           `protobuf:"bytes,7,opt,name=container,proto3" json:"container,omitempty"`
	ContainerConfig *Config          `protobuf:"bytes,8,opt,name=container_config,json=containerConfig" json:"container_config,omitempty"`
	DockerVersion   string           `protobuf:"bytes,9,opt,name=docker_version,json=dockerVersion,proto3" json:"docker_version,omitempty"`
	Author          string           `protobuf:"bytes,10,opt,name=author,proto3" json:"author,omitempty"`
	Config          *Config          `protobuf:"bytes,11,opt,name=config" json:"config,omitempty"`
	Architecture    string           `protobuf:"bytes,12,opt,name=architecture,proto3" json:"architecture,omitempty"`
	Os              string           `protobuf:"bytes,13,opt,name=os,proto3" json:"os,omitempty"`
	OsVersion       string           `protobuf:"bytes,14,opt,name=os_version,json=osVersion,proto3" json:"os_version,omitempty"`
	Size_           int64            `protobuf:"varint,15,opt,name=size,proto3" json:"size,omitempty"`
	VirtualSize     int64            `protobuf:"varint,16,opt,name=virtual_size,json=virtualSize,proto3" json:"virtual_size,omitempty"`
	GraphDriver     *GraphDriverData `protobuf:"bytes,17,opt,name=graph_driver,json=graphDriver" json:"graph_driver,omitempty"`
	RootFs          *RootFS          `protobuf:"bytes,18,opt,name=root_fs,json=rootFs" json:"root_fs,omitempty"`
	Metadata        *ImageMetadata   `protobuf:"bytes,19,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *ImageInspect) Reset()                    { *m = ImageInspect{} }
func (m *ImageInspect) String() string            { return proto.CompactTextString(m) }
func (*ImageInspect) ProtoMessage()               {}
func (*ImageInspect) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{22} }

func (m *ImageInspect) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ImageInspect) GetRepoTags() []string {
	if m != nil {
		return m.RepoTags
	}
	return nil
}

func (m *ImageInspect) GetRepoDigests() []string {
	if m != nil {
		return m.RepoDigests
	}
	return nil
}

func (m *ImageInspect) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *ImageInspect) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *ImageInspect) GetCreated() string {
	if m != nil {
		return m.Created
	}
	return ""
}

func (m *ImageInspect) GetContainer() string {
	if m != nil {
		return m.Container
	}
	return ""
}

func (m *ImageInspect) GetContainerConfig() *Config {
	if m != nil {
		return m.ContainerConfig
	}
	return nil
}

func (m *ImageInspect) GetDockerVersion() string {
	if m != nil {
		return m.DockerVersion
	}
	return ""
}

func (m *ImageInspect) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

func (m *ImageInspect) GetConfig() *Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *ImageInspect) GetArchitecture() string {
	if m != nil {
		return m.Architecture
	}
	return ""
}

func (m *ImageInspect) GetOs() string {
	if m != nil {
		return m.Os
	}
	return ""
}

func (m *ImageInspect) GetOsVersion() string {
	if m != nil {
		return m.OsVersion
	}
	return ""
}

func (m *ImageInspect) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *ImageInspect) GetVirtualSize() int64 {
	if m != nil {
		return m.VirtualSize
	}
	return 0
}

func (m *ImageInspect) GetGraphDriver() *GraphDriverData {
	if m != nil {
		return m.GraphDriver
	}
	return nil
}

func (m *ImageInspect) GetRootFs() *RootFS {
	if m != nil {
		return m.RootFs
	}
	return nil
}

func (m *ImageInspect) GetMetadata() *ImageMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// RootFS returns Image's RootFS description including the layer IDs.
type RootFS struct {
	FsType    string   `protobuf:"bytes,1,opt,name=fs_type,json=fsType,proto3" json:"fs_type,omitempty"`
	Layers    []string `protobuf:"bytes,2,rep,name=layers" json:"layers,omitempty"`
	BaseLayer string   `protobuf:"bytes,3,opt,name=base_layer,json=baseLayer,proto3" json:"base_layer,omitempty"`
}

func (m *RootFS) Reset()                    { *m = RootFS{} }
func (m *RootFS) String() string            { return proto.CompactTextString(m) }
func (*RootFS) ProtoMessage()               {}
func (*RootFS) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{23} }

func (m *RootFS) GetFsType() string {
	if m != nil {
		return m.FsType
	}
	return ""
}

func (m *RootFS) GetLayers() []string {
	if m != nil {
		return m.Layers
	}
	return nil
}

func (m *RootFS) GetBaseLayer() string {
	if m != nil {
		return m.BaseLayer
	}
	return ""
}

// ImageMetadata contains engine-local data about the image
type ImageMetadata struct {
	LastTagTime string `protobuf:"bytes,1,opt,name=last_tag_time,json=lastTagTime,proto3" json:"last_tag_time,omitempty"`
}

func (m *ImageMetadata) Reset()                    { *m = ImageMetadata{} }
func (m *ImageMetadata) String() string            { return proto.CompactTextString(m) }
func (*ImageMetadata) ProtoMessage()               {}
func (*ImageMetadata) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{24} }

func (m *ImageMetadata) GetLastTagTime() string {
	if m != nil {
		return m.LastTagTime
	}
	return ""
}

// GraphDriverData Information about a container's graph driver.
// swagger:model GraphDriverData
// to see https://github.com/moby/moby/blob/master/api/types/graph_driver_data.go
type GraphDriverData struct {
	// data
	// Required: true
	Data map[string]string `protobuf:"bytes,1,rep,name=data" json:"data,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// name
	// Required: true
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GraphDriverData) Reset()                    { *m = GraphDriverData{} }
func (m *GraphDriverData) String() string            { return proto.CompactTextString(m) }
func (*GraphDriverData) ProtoMessage()               {}
func (*GraphDriverData) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{25} }

func (m *GraphDriverData) GetData() map[string]string {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *GraphDriverData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Port stores open ports info of container
// e.g. {"PrivatePort": 8080, "PublicPort": 80, "Type": "tcp"}
type Port struct {
	Ip          string `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	PrivatePort int32  `protobuf:"varint,2,opt,name=private_port,json=privatePort,proto3" json:"private_port,omitempty"`
	PublicPort  int32  `protobuf:"varint,3,opt,name=public_port,json=publicPort,proto3" json:"public_port,omitempty"`
	Type        string `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *Port) Reset()                    { *m = Port{} }
func (m *Port) String() string            { return proto.CompactTextString(m) }
func (*Port) ProtoMessage()               {}
func (*Port) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{26} }

func (m *Port) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *Port) GetPrivatePort() int32 {
	if m != nil {
		return m.PrivatePort
	}
	return 0
}

func (m *Port) GetPublicPort() int32 {
	if m != nil {
		return m.PublicPort
	}
	return 0
}

func (m *Port) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

// NetworkSettings exposes the network settings in the api
type NetworkSettings struct {
	NetworkSettingsBase    *NetworkSettingsBase         `protobuf:"bytes,1,opt,name=network_settings_base,json=networkSettingsBase" json:"network_settings_base,omitempty"`
	DefaultNetworkSettings *DefaultNetworkSettings      `protobuf:"bytes,2,opt,name=default_network_settings,json=defaultNetworkSettings" json:"default_network_settings,omitempty"`
	Networks               map[string]*EndpointSettings `protobuf:"bytes,3,rep,name=networks" json:"networks,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *NetworkSettings) Reset()                    { *m = NetworkSettings{} }
func (m *NetworkSettings) String() string            { return proto.CompactTextString(m) }
func (*NetworkSettings) ProtoMessage()               {}
func (*NetworkSettings) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{27} }

func (m *NetworkSettings) GetNetworkSettingsBase() *NetworkSettingsBase {
	if m != nil {
		return m.NetworkSettingsBase
	}
	return nil
}

func (m *NetworkSettings) GetDefaultNetworkSettings() *DefaultNetworkSettings {
	if m != nil {
		return m.DefaultNetworkSettings
	}
	return nil
}

func (m *NetworkSettings) GetNetworks() map[string]*EndpointSettings {
	if m != nil {
		return m.Networks
	}
	return nil
}

// SummaryNetworkSettings provides a summary of container's networks
// in /containers/json
type SummaryNetworkSettings struct {
	Networks map[string]*EndpointSettings `protobuf:"bytes,1,rep,name=networks" json:"networks,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SummaryNetworkSettings) Reset()                    { *m = SummaryNetworkSettings{} }
func (m *SummaryNetworkSettings) String() string            { return proto.CompactTextString(m) }
func (*SummaryNetworkSettings) ProtoMessage()               {}
func (*SummaryNetworkSettings) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{28} }

func (m *SummaryNetworkSettings) GetNetworks() map[string]*EndpointSettings {
	if m != nil {
		return m.Networks
	}
	return nil
}

// Address represents an IP address
type Address struct {
	Addr      string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	PrefixLen int32  `protobuf:"varint,2,opt,name=prefix_len,json=prefixLen,proto3" json:"prefix_len,omitempty"`
}

func (m *Address) Reset()                    { *m = Address{} }
func (m *Address) String() string            { return proto.CompactTextString(m) }
func (*Address) ProtoMessage()               {}
func (*Address) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{29} }

func (m *Address) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *Address) GetPrefixLen() int32 {
	if m != nil {
		return m.PrefixLen
	}
	return 0
}

// NetworkSettingsBase holds basic information about networks
type NetworkSettingsBase struct {
	Bridge                 string     `protobuf:"bytes,1,opt,name=bridge,proto3" json:"bridge,omitempty"`
	SandboxId              string     `protobuf:"bytes,2,opt,name=sandbox_id,json=sandboxId,proto3" json:"sandbox_id,omitempty"`
	HairpinMode            bool       `protobuf:"varint,3,opt,name=hairpin_mode,json=hairpinMode,proto3" json:"hairpin_mode,omitempty"`
	LinkLocalIpv6Address   string     `protobuf:"bytes,4,opt,name=link_local_ipv6_address,json=linkLocalIpv6Address,proto3" json:"link_local_ipv6_address,omitempty"`
	LinkLocalIpv6PrefixLen int32      `protobuf:"varint,5,opt,name=link_local_ipv6_prefix_len,json=linkLocalIpv6PrefixLen,proto3" json:"link_local_ipv6_prefix_len,omitempty"`
	Ports                  *PortMap   `protobuf:"bytes,6,opt,name=ports" json:"ports,omitempty"`
	SandboxKey             string     `protobuf:"bytes,7,opt,name=sandbox_key,json=sandboxKey,proto3" json:"sandbox_key,omitempty"`
	SecondaryIpAddresses   []*Address `protobuf:"bytes,8,rep,name=secondary_ip_addresses,json=secondaryIpAddresses" json:"secondary_ip_addresses,omitempty"`
	SecondaryIpv6Addresses []*Address `protobuf:"bytes,9,rep,name=secondary_ipv6_addresses,json=secondaryIpv6Addresses" json:"secondary_ipv6_addresses,omitempty"`
}

func (m *NetworkSettingsBase) Reset()                    { *m = NetworkSettingsBase{} }
func (m *NetworkSettingsBase) String() string            { return proto.CompactTextString(m) }
func (*NetworkSettingsBase) ProtoMessage()               {}
func (*NetworkSettingsBase) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{30} }

func (m *NetworkSettingsBase) GetBridge() string {
	if m != nil {
		return m.Bridge
	}
	return ""
}

func (m *NetworkSettingsBase) GetSandboxId() string {
	if m != nil {
		return m.SandboxId
	}
	return ""
}

func (m *NetworkSettingsBase) GetHairpinMode() bool {
	if m != nil {
		return m.HairpinMode
	}
	return false
}

func (m *NetworkSettingsBase) GetLinkLocalIpv6Address() string {
	if m != nil {
		return m.LinkLocalIpv6Address
	}
	return ""
}

func (m *NetworkSettingsBase) GetLinkLocalIpv6PrefixLen() int32 {
	if m != nil {
		return m.LinkLocalIpv6PrefixLen
	}
	return 0
}

func (m *NetworkSettingsBase) GetPorts() *PortMap {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *NetworkSettingsBase) GetSandboxKey() string {
	if m != nil {
		return m.SandboxKey
	}
	return ""
}

func (m *NetworkSettingsBase) GetSecondaryIpAddresses() []*Address {
	if m != nil {
		return m.SecondaryIpAddresses
	}
	return nil
}

func (m *NetworkSettingsBase) GetSecondaryIpv6Addresses() []*Address {
	if m != nil {
		return m.SecondaryIpv6Addresses
	}
	return nil
}

// DefaultNetworkSettings holds network information
// during the 2 release deprecation period.
// It will be removed in Docker 1.11.
type DefaultNetworkSettings struct {
	EndpointId          string `protobuf:"bytes,1,opt,name=endpoint_id,json=endpointId,proto3" json:"endpoint_id,omitempty"`
	Gateway             string `protobuf:"bytes,2,opt,name=gateway,proto3" json:"gateway,omitempty"`
	GlobalIpv6Address   string `protobuf:"bytes,3,opt,name=global_ipv6_address,json=globalIpv6Address,proto3" json:"global_ipv6_address,omitempty"`
	GlobalIpv6PrefixLen int32  `protobuf:"varint,4,opt,name=global_ipv6_prefix_len,json=globalIpv6PrefixLen,proto3" json:"global_ipv6_prefix_len,omitempty"`
	IpAddress           string `protobuf:"bytes,5,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	IpPrefixLen         int32  `protobuf:"varint,6,opt,name=ip_prefix_len,json=ipPrefixLen,proto3" json:"ip_prefix_len,omitempty"`
	Ipv6Gateway         string `protobuf:"bytes,7,opt,name=ipv6_gateway,json=ipv6Gateway,proto3" json:"ipv6_gateway,omitempty"`
	MacAddress          string `protobuf:"bytes,8,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
}

func (m *DefaultNetworkSettings) Reset()                    { *m = DefaultNetworkSettings{} }
func (m *DefaultNetworkSettings) String() string            { return proto.CompactTextString(m) }
func (*DefaultNetworkSettings) ProtoMessage()               {}
func (*DefaultNetworkSettings) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{31} }

func (m *DefaultNetworkSettings) GetEndpointId() string {
	if m != nil {
		return m.EndpointId
	}
	return ""
}

func (m *DefaultNetworkSettings) GetGateway() string {
	if m != nil {
		return m.Gateway
	}
	return ""
}

func (m *DefaultNetworkSettings) GetGlobalIpv6Address() string {
	if m != nil {
		return m.GlobalIpv6Address
	}
	return ""
}

func (m *DefaultNetworkSettings) GetGlobalIpv6PrefixLen() int32 {
	if m != nil {
		return m.GlobalIpv6PrefixLen
	}
	return 0
}

func (m *DefaultNetworkSettings) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *DefaultNetworkSettings) GetIpPrefixLen() int32 {
	if m != nil {
		return m.IpPrefixLen
	}
	return 0
}

func (m *DefaultNetworkSettings) GetIpv6Gateway() string {
	if m != nil {
		return m.Ipv6Gateway
	}
	return ""
}

func (m *DefaultNetworkSettings) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

// MountPoint represents a mount point configuration inside the container.
type MountPoint struct {
	Name        string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Source      string `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	Destination string `protobuf:"bytes,3,opt,name=destination,proto3" json:"destination,omitempty"`
	Driver      string `protobuf:"bytes,4,opt,name=driver,proto3" json:"driver,omitempty"`
	Mode        string `protobuf:"bytes,5,opt,name=mode,proto3" json:"mode,omitempty"`
	Rw          bool   `protobuf:"varint,6,opt,name=rw,proto3" json:"rw,omitempty"`
	Propagation string `protobuf:"bytes,7,opt,name=propagation,proto3" json:"propagation,omitempty"`
}

func (m *MountPoint) Reset()                    { *m = MountPoint{} }
func (m *MountPoint) String() string            { return proto.CompactTextString(m) }
func (*MountPoint) ProtoMessage()               {}
func (*MountPoint) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{32} }

func (m *MountPoint) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MountPoint) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *MountPoint) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *MountPoint) GetDriver() string {
	if m != nil {
		return m.Driver
	}
	return ""
}

func (m *MountPoint) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

func (m *MountPoint) GetRw() bool {
	if m != nil {
		return m.Rw
	}
	return false
}

func (m *MountPoint) GetPropagation() string {
	if m != nil {
		return m.Propagation
	}
	return ""
}

// Container contains response of Remote API:
// GET  "/containers/json"
type Container struct {
	Id              string                  `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Names           []string                `protobuf:"bytes,2,rep,name=names" json:"names,omitempty"`
	Image           string                  `protobuf:"bytes,3,opt,name=image,proto3" json:"image,omitempty"`
	ImageId         string                  `protobuf:"bytes,4,opt,name=image_id,json=imageId,proto3" json:"image_id,omitempty"`
	Command         string                  `protobuf:"bytes,5,opt,name=command,proto3" json:"command,omitempty"`
	Created         int64                   `protobuf:"varint,6,opt,name=created,proto3" json:"created,omitempty"`
	Ports           []*Port                 `protobuf:"bytes,7,rep,name=Ports,json=ports" json:"Ports,omitempty"`
	SizeRw          int64                   `protobuf:"varint,8,opt,name=size_rw,json=sizeRw,proto3" json:"size_rw,omitempty"`
	SizeRootFs      int64                   `protobuf:"varint,9,opt,name=size_root_fs,json=sizeRootFs,proto3" json:"size_root_fs,omitempty"`
	Labels          map[string]string       `protobuf:"bytes,10,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	State           string                  `protobuf:"bytes,11,opt,name=state,proto3" json:"state,omitempty"`
	Status          string                  `protobuf:"bytes,12,opt,name=status,proto3" json:"status,omitempty"`
	HostConfig      *Container_HostConfig   `protobuf:"bytes,13,opt,name=host_config,json=hostConfig" json:"host_config,omitempty"`
	NetworkSettings *SummaryNetworkSettings `protobuf:"bytes,14,opt,name=network_settings,json=networkSettings" json:"network_settings,omitempty"`
	Mounts          []*MountPoint           `protobuf:"bytes,15,rep,name=mounts" json:"mounts,omitempty"`
}

func (m *Container) Reset()                    { *m = Container{} }
func (m *Container) String() string            { return proto.CompactTextString(m) }
func (*Container) ProtoMessage()               {}
func (*Container) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{33} }

func (m *Container) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Container) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

func (m *Container) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *Container) GetImageId() string {
	if m != nil {
		return m.ImageId
	}
	return ""
}

func (m *Container) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *Container) GetCreated() int64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *Container) GetPorts() []*Port {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *Container) GetSizeRw() int64 {
	if m != nil {
		return m.SizeRw
	}
	return 0
}

func (m *Container) GetSizeRootFs() int64 {
	if m != nil {
		return m.SizeRootFs
	}
	return 0
}

func (m *Container) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Container) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *Container) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Container) GetHostConfig() *Container_HostConfig {
	if m != nil {
		return m.HostConfig
	}
	return nil
}

func (m *Container) GetNetworkSettings() *SummaryNetworkSettings {
	if m != nil {
		return m.NetworkSettings
	}
	return nil
}

func (m *Container) GetMounts() []*MountPoint {
	if m != nil {
		return m.Mounts
	}
	return nil
}

type Container_HostConfig struct {
	NetworkMode string `protobuf:"bytes,1,opt,name=network_mode,json=networkMode,proto3" json:"network_mode,omitempty"`
}

func (m *Container_HostConfig) Reset()                    { *m = Container_HostConfig{} }
func (m *Container_HostConfig) String() string            { return proto.CompactTextString(m) }
func (*Container_HostConfig) ProtoMessage()               {}
func (*Container_HostConfig) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{33, 0} }

func (m *Container_HostConfig) GetNetworkMode() string {
	if m != nil {
		return m.NetworkMode
	}
	return ""
}

// ContainerState stores container's running state
// it's part of ContainerJSONBase and will return by "inspect" command
type ContainerState struct {
	Status     string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	Running    bool   `protobuf:"varint,2,opt,name=running,proto3" json:"running,omitempty"`
	Paused     bool   `protobuf:"varint,3,opt,name=paused,proto3" json:"paused,omitempty"`
	Restarting bool   `protobuf:"varint,4,opt,name=restarting,proto3" json:"restarting,omitempty"`
	OomKilled  bool   `protobuf:"varint,5,opt,name=oom_killed,json=oomKilled,proto3" json:"oom_killed,omitempty"`
	Dead       bool   `protobuf:"varint,6,opt,name=dead,proto3" json:"dead,omitempty"`
	Pid        int32  `protobuf:"varint,7,opt,name=pid,proto3" json:"pid,omitempty"`
	ExitCode   int32  `protobuf:"varint,8,opt,name=exit_code,json=exitCode,proto3" json:"exit_code,omitempty"`
	Error      string `protobuf:"bytes,9,opt,name=error,proto3" json:"error,omitempty"`
	StartedAt  string `protobuf:"bytes,10,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	FinishedAt string `protobuf:"bytes,11,opt,name=finished_at,json=finishedAt,proto3" json:"finished_at,omitempty"`
}

func (m *ContainerState) Reset()                    { *m = ContainerState{} }
func (m *ContainerState) String() string            { return proto.CompactTextString(m) }
func (*ContainerState) ProtoMessage()               {}
func (*ContainerState) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{34} }

func (m *ContainerState) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ContainerState) GetRunning() bool {
	if m != nil {
		return m.Running
	}
	return false
}

func (m *ContainerState) GetPaused() bool {
	if m != nil {
		return m.Paused
	}
	return false
}

func (m *ContainerState) GetRestarting() bool {
	if m != nil {
		return m.Restarting
	}
	return false
}

func (m *ContainerState) GetOomKilled() bool {
	if m != nil {
		return m.OomKilled
	}
	return false
}

func (m *ContainerState) GetDead() bool {
	if m != nil {
		return m.Dead
	}
	return false
}

func (m *ContainerState) GetPid() int32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *ContainerState) GetExitCode() int32 {
	if m != nil {
		return m.ExitCode
	}
	return 0
}

func (m *ContainerState) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *ContainerState) GetStartedAt() string {
	if m != nil {
		return m.StartedAt
	}
	return ""
}

func (m *ContainerState) GetFinishedAt() string {
	if m != nil {
		return m.FinishedAt
	}
	return ""
}

// ContainerNode stores information about the node that a container
// is running on.  It's only available in Docker Swarm
type ContainerNode struct {
	Id        string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	IpAddress string            `protobuf:"bytes,2,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	Addr      string            `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
	Name      string            `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	Cpus      int32             `protobuf:"varint,5,opt,name=cpus,proto3" json:"cpus,omitempty"`
	Memory    int32             `protobuf:"varint,6,opt,name=memory,proto3" json:"memory,omitempty"`
	Labels    map[string]string `protobuf:"bytes,7,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ContainerNode) Reset()                    { *m = ContainerNode{} }
func (m *ContainerNode) String() string            { return proto.CompactTextString(m) }
func (*ContainerNode) ProtoMessage()               {}
func (*ContainerNode) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{35} }

func (m *ContainerNode) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ContainerNode) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *ContainerNode) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *ContainerNode) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ContainerNode) GetCpus() int32 {
	if m != nil {
		return m.Cpus
	}
	return 0
}

func (m *ContainerNode) GetMemory() int32 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *ContainerNode) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// ContainerJSONBase contains response of Remote API:
// GET "/containers/{name:.*}/json"
type ContainerJSONBase struct {
	Id              string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Created         string           `protobuf:"bytes,2,opt,name=created,proto3" json:"created,omitempty"`
	Path            string           `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
	Args            []string         `protobuf:"bytes,4,rep,name=args" json:"args,omitempty"`
	State           *ContainerState  `protobuf:"bytes,5,opt,name=state" json:"state,omitempty"`
	Image           string           `protobuf:"bytes,6,opt,name=image,proto3" json:"image,omitempty"`
	ResolvConfPath  string           `protobuf:"bytes,7,opt,name=resolv_conf_path,json=resolvConfPath,proto3" json:"resolv_conf_path,omitempty"`
	HostnamePath    string           `protobuf:"bytes,8,opt,name=hostname_path,json=hostnamePath,proto3" json:"hostname_path,omitempty"`
	HostsPath       string           `protobuf:"bytes,9,opt,name=hosts_path,json=hostsPath,proto3" json:"hosts_path,omitempty"`
	LogPath         string           `protobuf:"bytes,10,opt,name=log_path,json=logPath,proto3" json:"log_path,omitempty"`
	Node            *ContainerNode   `protobuf:"bytes,11,opt,name=node" json:"node,omitempty"`
	Name            string           `protobuf:"bytes,12,opt,name=name,proto3" json:"name,omitempty"`
	RestartCount    int32            `protobuf:"varint,13,opt,name=restart_count,json=restartCount,proto3" json:"restart_count,omitempty"`
	Driver          string           `protobuf:"bytes,14,opt,name=driver,proto3" json:"driver,omitempty"`
	MountLabel      string           `protobuf:"bytes,15,opt,name=mount_label,json=mountLabel,proto3" json:"mount_label,omitempty"`
	ProcessLabel    string           `protobuf:"bytes,16,opt,name=process_label,json=processLabel,proto3" json:"process_label,omitempty"`
	AppArmorProfile string           `protobuf:"bytes,17,opt,name=app_armor_profile,json=appArmorProfile,proto3" json:"app_armor_profile,omitempty"`
	ExecIds         []string         `protobuf:"bytes,18,rep,name=exec_ids,json=execIds" json:"exec_ids,omitempty"`
	HostConfig      *HostConfig      `protobuf:"bytes,19,opt,name=host_config,json=hostConfig" json:"host_config,omitempty"`
	GraphDriver     *GraphDriverData `protobuf:"bytes,20,opt,name=graph_driver,json=graphDriver" json:"graph_driver,omitempty"`
	SizeRw          int64            `protobuf:"varint,21,opt,name=size_rw,json=sizeRw,proto3" json:"size_rw,omitempty"`
	SizeRootFs      int64            `protobuf:"varint,22,opt,name=size_root_fs,json=sizeRootFs,proto3" json:"size_root_fs,omitempty"`
}

func (m *ContainerJSONBase) Reset()                    { *m = ContainerJSONBase{} }
func (m *ContainerJSONBase) String() string            { return proto.CompactTextString(m) }
func (*ContainerJSONBase) ProtoMessage()               {}
func (*ContainerJSONBase) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{36} }

func (m *ContainerJSONBase) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ContainerJSONBase) GetCreated() string {
	if m != nil {
		return m.Created
	}
	return ""
}

func (m *ContainerJSONBase) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *ContainerJSONBase) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *ContainerJSONBase) GetState() *ContainerState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *ContainerJSONBase) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *ContainerJSONBase) GetResolvConfPath() string {
	if m != nil {
		return m.ResolvConfPath
	}
	return ""
}

func (m *ContainerJSONBase) GetHostnamePath() string {
	if m != nil {
		return m.HostnamePath
	}
	return ""
}

func (m *ContainerJSONBase) GetHostsPath() string {
	if m != nil {
		return m.HostsPath
	}
	return ""
}

func (m *ContainerJSONBase) GetLogPath() string {
	if m != nil {
		return m.LogPath
	}
	return ""
}

func (m *ContainerJSONBase) GetNode() *ContainerNode {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *ContainerJSONBase) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ContainerJSONBase) GetRestartCount() int32 {
	if m != nil {
		return m.RestartCount
	}
	return 0
}

func (m *ContainerJSONBase) GetDriver() string {
	if m != nil {
		return m.Driver
	}
	return ""
}

func (m *ContainerJSONBase) GetMountLabel() string {
	if m != nil {
		return m.MountLabel
	}
	return ""
}

func (m *ContainerJSONBase) GetProcessLabel() string {
	if m != nil {
		return m.ProcessLabel
	}
	return ""
}

func (m *ContainerJSONBase) GetAppArmorProfile() string {
	if m != nil {
		return m.AppArmorProfile
	}
	return ""
}

func (m *ContainerJSONBase) GetExecIds() []string {
	if m != nil {
		return m.ExecIds
	}
	return nil
}

func (m *ContainerJSONBase) GetHostConfig() *HostConfig {
	if m != nil {
		return m.HostConfig
	}
	return nil
}

func (m *ContainerJSONBase) GetGraphDriver() *GraphDriverData {
	if m != nil {
		return m.GraphDriver
	}
	return nil
}

func (m *ContainerJSONBase) GetSizeRw() int64 {
	if m != nil {
		return m.SizeRw
	}
	return 0
}

func (m *ContainerJSONBase) GetSizeRootFs() int64 {
	if m != nil {
		return m.SizeRootFs
	}
	return 0
}

// ContainerJSON is newly used struct along with MountPoint
type ContainerJSON struct {
	ContainerJsonBase *ContainerJSONBase `protobuf:"bytes,1,opt,name=container_json_base,json=containerJsonBase" json:"container_json_base,omitempty"`
	Mounts            []*MountPoint      `protobuf:"bytes,2,rep,name=mounts" json:"mounts,omitempty"`
	Config            *Config            `protobuf:"bytes,3,opt,name=config" json:"config,omitempty"`
	NetworkSettings   *NetworkSettings   `protobuf:"bytes,4,opt,name=network_settings,json=networkSettings" json:"network_settings,omitempty"`
}

func (m *ContainerJSON) Reset()                    { *m = ContainerJSON{} }
func (m *ContainerJSON) String() string            { return proto.CompactTextString(m) }
func (*ContainerJSON) ProtoMessage()               {}
func (*ContainerJSON) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{37} }

func (m *ContainerJSON) GetContainerJsonBase() *ContainerJSONBase {
	if m != nil {
		return m.ContainerJsonBase
	}
	return nil
}

func (m *ContainerJSON) GetMounts() []*MountPoint {
	if m != nil {
		return m.Mounts
	}
	return nil
}

func (m *ContainerJSON) GetConfig() *Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *ContainerJSON) GetNetworkSettings() *NetworkSettings {
	if m != nil {
		return m.NetworkSettings
	}
	return nil
}

// NetworkResource is the body of the "get network" http response message
type NetworkResource struct {
	Name       string                       `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Id         string                       `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	Scope      string                       `protobuf:"bytes,3,opt,name=scope,proto3" json:"scope,omitempty"`
	Driver     string                       `protobuf:"bytes,4,opt,name=driver,proto3" json:"driver,omitempty"`
	EnableIpv6 bool                         `protobuf:"varint,5,opt,name=enable_ipv6,json=enableIpv6,proto3" json:"enable_ipv6,omitempty"`
	Ipam       *IPAM                        `protobuf:"bytes,6,opt,name=ipam" json:"ipam,omitempty"`
	Internal   bool                         `protobuf:"varint,7,opt,name=internal,proto3" json:"internal,omitempty"`
	Containers map[string]*EndpointResource `protobuf:"bytes,8,rep,name=containers" json:"containers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Options    map[string]string            `protobuf:"bytes,9,rep,name=options" json:"options,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Labels     map[string]string            `protobuf:"bytes,10,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *NetworkResource) Reset()                    { *m = NetworkResource{} }
func (m *NetworkResource) String() string            { return proto.CompactTextString(m) }
func (*NetworkResource) ProtoMessage()               {}
func (*NetworkResource) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{38} }

func (m *NetworkResource) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NetworkResource) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NetworkResource) GetScope() string {
	if m != nil {
		return m.Scope
	}
	return ""
}

func (m *NetworkResource) GetDriver() string {
	if m != nil {
		return m.Driver
	}
	return ""
}

func (m *NetworkResource) GetEnableIpv6() bool {
	if m != nil {
		return m.EnableIpv6
	}
	return false
}

func (m *NetworkResource) GetIpam() *IPAM {
	if m != nil {
		return m.Ipam
	}
	return nil
}

func (m *NetworkResource) GetInternal() bool {
	if m != nil {
		return m.Internal
	}
	return false
}

func (m *NetworkResource) GetContainers() map[string]*EndpointResource {
	if m != nil {
		return m.Containers
	}
	return nil
}

func (m *NetworkResource) GetOptions() map[string]string {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *NetworkResource) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// EndpointResource contains network resources allocated and used for a container in a network
type EndpointResource struct {
	Name        string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	EndpointId  string `protobuf:"bytes,2,opt,name=endpoint_id,json=endpointId,proto3" json:"endpoint_id,omitempty"`
	MacAddress  string `protobuf:"bytes,3,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	Ipv4Address string `protobuf:"bytes,4,opt,name=ipv4_address,json=ipv4Address,proto3" json:"ipv4_address,omitempty"`
	Ipv6Address string `protobuf:"bytes,5,opt,name=ipv6_address,json=ipv6Address,proto3" json:"ipv6_address,omitempty"`
}

func (m *EndpointResource) Reset()                    { *m = EndpointResource{} }
func (m *EndpointResource) String() string            { return proto.CompactTextString(m) }
func (*EndpointResource) ProtoMessage()               {}
func (*EndpointResource) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{39} }

func (m *EndpointResource) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EndpointResource) GetEndpointId() string {
	if m != nil {
		return m.EndpointId
	}
	return ""
}

func (m *EndpointResource) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *EndpointResource) GetIpv4Address() string {
	if m != nil {
		return m.Ipv4Address
	}
	return ""
}

func (m *EndpointResource) GetIpv6Address() string {
	if m != nil {
		return m.Ipv6Address
	}
	return ""
}

// NetworkCreate is the expected body of the "create network" http request message
type NetworkCreate struct {
	CheckDuplicate bool              `protobuf:"varint,1,opt,name=check_duplicate,json=checkDuplicate,proto3" json:"check_duplicate,omitempty"`
	Driver         string            `protobuf:"bytes,2,opt,name=driver,proto3" json:"driver,omitempty"`
	EnableIpv6     bool              `protobuf:"varint,3,opt,name=enable_ipv6,json=enableIpv6,proto3" json:"enable_ipv6,omitempty"`
	Ipam           *IPAM             `protobuf:"bytes,4,opt,name=ipam" json:"ipam,omitempty"`
	Internal       bool              `protobuf:"varint,5,opt,name=internal,proto3" json:"internal,omitempty"`
	Options        map[string]string `protobuf:"bytes,6,rep,name=options" json:"options,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Labels         map[string]string `protobuf:"bytes,7,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *NetworkCreate) Reset()                    { *m = NetworkCreate{} }
func (m *NetworkCreate) String() string            { return proto.CompactTextString(m) }
func (*NetworkCreate) ProtoMessage()               {}
func (*NetworkCreate) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{40} }

func (m *NetworkCreate) GetCheckDuplicate() bool {
	if m != nil {
		return m.CheckDuplicate
	}
	return false
}

func (m *NetworkCreate) GetDriver() string {
	if m != nil {
		return m.Driver
	}
	return ""
}

func (m *NetworkCreate) GetEnableIpv6() bool {
	if m != nil {
		return m.EnableIpv6
	}
	return false
}

func (m *NetworkCreate) GetIpam() *IPAM {
	if m != nil {
		return m.Ipam
	}
	return nil
}

func (m *NetworkCreate) GetInternal() bool {
	if m != nil {
		return m.Internal
	}
	return false
}

func (m *NetworkCreate) GetOptions() map[string]string {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *NetworkCreate) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// NetworkCreateRequest is the request message sent to the server for network create call.
type NetworkCreateRequest struct {
	NetworkCreate *NetworkCreate `protobuf:"bytes,1,opt,name=network_create,json=networkCreate" json:"network_create,omitempty"`
	Name          string         `protobuf:"bytes,2,opt,name=Name,json=name,proto3" json:"Name,omitempty"`
}

func (m *NetworkCreateRequest) Reset()                    { *m = NetworkCreateRequest{} }
func (m *NetworkCreateRequest) String() string            { return proto.CompactTextString(m) }
func (*NetworkCreateRequest) ProtoMessage()               {}
func (*NetworkCreateRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{41} }

func (m *NetworkCreateRequest) GetNetworkCreate() *NetworkCreate {
	if m != nil {
		return m.NetworkCreate
	}
	return nil
}

func (m *NetworkCreateRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// NetworkCreateResponse is the response message sent by the server for network create call
type NetworkCreateResponse struct {
	Id      string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Warning string `protobuf:"bytes,2,opt,name=warning,proto3" json:"warning,omitempty"`
}

func (m *NetworkCreateResponse) Reset()                    { *m = NetworkCreateResponse{} }
func (m *NetworkCreateResponse) String() string            { return proto.CompactTextString(m) }
func (*NetworkCreateResponse) ProtoMessage()               {}
func (*NetworkCreateResponse) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{42} }

func (m *NetworkCreateResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NetworkCreateResponse) GetWarning() string {
	if m != nil {
		return m.Warning
	}
	return ""
}

// NetworkConnect represents the data to be used to connect a container to the network
type NetworkConnect struct {
	Container      string            `protobuf:"bytes,1,opt,name=container,proto3" json:"container,omitempty"`
	EndpointConfig *EndpointSettings `protobuf:"bytes,2,opt,name=endpoint_config,json=endpointConfig" json:"endpoint_config,omitempty"`
}

func (m *NetworkConnect) Reset()                    { *m = NetworkConnect{} }
func (m *NetworkConnect) String() string            { return proto.CompactTextString(m) }
func (*NetworkConnect) ProtoMessage()               {}
func (*NetworkConnect) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{43} }

func (m *NetworkConnect) GetContainer() string {
	if m != nil {
		return m.Container
	}
	return ""
}

func (m *NetworkConnect) GetEndpointConfig() *EndpointSettings {
	if m != nil {
		return m.EndpointConfig
	}
	return nil
}

// NetworkDisconnect represents the data to be used to disconnect a container from the network
type NetworkDisconnect struct {
	Container string `protobuf:"bytes,1,opt,name=container,proto3" json:"container,omitempty"`
	Force     bool   `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
}

func (m *NetworkDisconnect) Reset()                    { *m = NetworkDisconnect{} }
func (m *NetworkDisconnect) String() string            { return proto.CompactTextString(m) }
func (*NetworkDisconnect) ProtoMessage()               {}
func (*NetworkDisconnect) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{44} }

func (m *NetworkDisconnect) GetContainer() string {
	if m != nil {
		return m.Container
	}
	return ""
}

func (m *NetworkDisconnect) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

// IPAM represents IP Address Management
type IPAM struct {
	Driver  string            `protobuf:"bytes,1,opt,name=driver,proto3" json:"driver,omitempty"`
	Options map[string]string `protobuf:"bytes,2,rep,name=options" json:"options,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Config  []*IPAMConfig     `protobuf:"bytes,3,rep,name=config" json:"config,omitempty"`
}

func (m *IPAM) Reset()                    { *m = IPAM{} }
func (m *IPAM) String() string            { return proto.CompactTextString(m) }
func (*IPAM) ProtoMessage()               {}
func (*IPAM) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{45} }

func (m *IPAM) GetDriver() string {
	if m != nil {
		return m.Driver
	}
	return ""
}

func (m *IPAM) GetOptions() map[string]string {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *IPAM) GetConfig() []*IPAMConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

// IPAMConfig represents IPAM configurations
type IPAMConfig struct {
	Subnet     string            `protobuf:"bytes,1,opt,name=subnet,proto3" json:"subnet,omitempty"`
	IpRange    string            `protobuf:"bytes,2,opt,name=ip_range,json=ipRange,proto3" json:"ip_range,omitempty"`
	Gateway    string            `protobuf:"bytes,3,opt,name=gateway,proto3" json:"gateway,omitempty"`
	AuxAddress map[string]string `protobuf:"bytes,4,rep,name=aux_address,json=auxAddress" json:"aux_address,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *IPAMConfig) Reset()                    { *m = IPAMConfig{} }
func (m *IPAMConfig) String() string            { return proto.CompactTextString(m) }
func (*IPAMConfig) ProtoMessage()               {}
func (*IPAMConfig) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{46} }

func (m *IPAMConfig) GetSubnet() string {
	if m != nil {
		return m.Subnet
	}
	return ""
}

func (m *IPAMConfig) GetIpRange() string {
	if m != nil {
		return m.IpRange
	}
	return ""
}

func (m *IPAMConfig) GetGateway() string {
	if m != nil {
		return m.Gateway
	}
	return ""
}

func (m *IPAMConfig) GetAuxAddress() map[string]string {
	if m != nil {
		return m.AuxAddress
	}
	return nil
}

// Image contains response of Remote API:
// GET "/images/json"
type Image struct {
	Id          string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	ParentId    string            `protobuf:"bytes,2,opt,name=parent_id,json=parentId,proto3" json:"parent_id,omitempty"`
	RepoTags    []string          `protobuf:"bytes,3,rep,name=repo_tags,json=repoTags" json:"repo_tags,omitempty"`
	RepoDigests []string          `protobuf:"bytes,4,rep,name=repo_digests,json=repoDigests" json:"repo_digests,omitempty"`
	Created     int64             `protobuf:"varint,5,opt,name=created,proto3" json:"created,omitempty"`
	Size_       int64             `protobuf:"varint,6,opt,name=size,proto3" json:"size,omitempty"`
	VirtualSize int64             `protobuf:"varint,7,opt,name=virtual_size,json=virtualSize,proto3" json:"virtual_size,omitempty"`
	Labels      map[string]string `protobuf:"bytes,8,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Image) Reset()                    { *m = Image{} }
func (m *Image) String() string            { return proto.CompactTextString(m) }
func (*Image) ProtoMessage()               {}
func (*Image) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{47} }

func (m *Image) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Image) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *Image) GetRepoTags() []string {
	if m != nil {
		return m.RepoTags
	}
	return nil
}

func (m *Image) GetRepoDigests() []string {
	if m != nil {
		return m.RepoDigests
	}
	return nil
}

func (m *Image) GetCreated() int64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *Image) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *Image) GetVirtualSize() int64 {
	if m != nil {
		return m.VirtualSize
	}
	return 0
}

func (m *Image) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// ImageListOptions holds parameters to filter the list of images with.
type ImageListOptions struct {
	MatchName string       `protobuf:"bytes,1,opt,name=match_name,json=matchName,proto3" json:"match_name,omitempty"`
	All       bool         `protobuf:"varint,2,opt,name=all,proto3" json:"all,omitempty"`
	Filter    *FiltersArgs `protobuf:"bytes,3,opt,name=filter" json:"filter,omitempty"`
}

func (m *ImageListOptions) Reset()                    { *m = ImageListOptions{} }
func (m *ImageListOptions) String() string            { return proto.CompactTextString(m) }
func (*ImageListOptions) ProtoMessage()               {}
func (*ImageListOptions) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{48} }

func (m *ImageListOptions) GetMatchName() string {
	if m != nil {
		return m.MatchName
	}
	return ""
}

func (m *ImageListOptions) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

func (m *ImageListOptions) GetFilter() *FiltersArgs {
	if m != nil {
		return m.Filter
	}
	return nil
}

// ContainerListOptions holds parameters to list containers with.
type ContainerListOptions struct {
	Quiet  bool         `protobuf:"varint,1,opt,name=quiet,proto3" json:"quiet,omitempty"`
	Size_  bool         `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	All    bool         `protobuf:"varint,3,opt,name=all,proto3" json:"all,omitempty"`
	Latest bool         `protobuf:"varint,4,opt,name=latest,proto3" json:"latest,omitempty"`
	Since  string       `protobuf:"bytes,5,opt,name=since,proto3" json:"since,omitempty"`
	Before string       `protobuf:"bytes,6,opt,name=before,proto3" json:"before,omitempty"`
	Limit  int32        `protobuf:"varint,7,opt,name=limit,proto3" json:"limit,omitempty"`
	Filter *FiltersArgs `protobuf:"bytes,8,opt,name=filter" json:"filter,omitempty"`
}

func (m *ContainerListOptions) Reset()                    { *m = ContainerListOptions{} }
func (m *ContainerListOptions) String() string            { return proto.CompactTextString(m) }
func (*ContainerListOptions) ProtoMessage()               {}
func (*ContainerListOptions) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{49} }

func (m *ContainerListOptions) GetQuiet() bool {
	if m != nil {
		return m.Quiet
	}
	return false
}

func (m *ContainerListOptions) GetSize_() bool {
	if m != nil {
		return m.Size_
	}
	return false
}

func (m *ContainerListOptions) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

func (m *ContainerListOptions) GetLatest() bool {
	if m != nil {
		return m.Latest
	}
	return false
}

func (m *ContainerListOptions) GetSince() string {
	if m != nil {
		return m.Since
	}
	return ""
}

func (m *ContainerListOptions) GetBefore() string {
	if m != nil {
		return m.Before
	}
	return ""
}

func (m *ContainerListOptions) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ContainerListOptions) GetFilter() *FiltersArgs {
	if m != nil {
		return m.Filter
	}
	return nil
}

// Args stores filter arguments as map key:{map key: bool}.
// It contains an aggregation of the map of arguments (which are in the form
// of -f 'key=value') based on the key, and stores values for the same key
// in a map with string keys and boolean values.
// e.g given -f 'label=label1=1' -f 'label=label2=2' -f 'image.name=ubuntu'
// the args will be {"image.name":{"ubuntu":true},"label":{"label1=1":true,"label2=2":true}}
type FiltersArgs struct {
	Fields map[string]*FiltersArgs_Value `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *FiltersArgs) Reset()                    { *m = FiltersArgs{} }
func (m *FiltersArgs) String() string            { return proto.CompactTextString(m) }
func (*FiltersArgs) ProtoMessage()               {}
func (*FiltersArgs) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{50} }

func (m *FiltersArgs) GetFields() map[string]*FiltersArgs_Value {
	if m != nil {
		return m.Fields
	}
	return nil
}

type FiltersArgs_Value struct {
	Value map[string]bool `protobuf:"bytes,1,rep,name=value" json:"value,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *FiltersArgs_Value) Reset()                    { *m = FiltersArgs_Value{} }
func (m *FiltersArgs_Value) String() string            { return proto.CompactTextString(m) }
func (*FiltersArgs_Value) ProtoMessage()               {}
func (*FiltersArgs_Value) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{50, 0} }

func (m *FiltersArgs_Value) GetValue() map[string]bool {
	if m != nil {
		return m.Value
	}
	return nil
}

func init() {
	proto.RegisterType((*HealthConfig)(nil), "moby.HealthConfig")
	proto.RegisterType((*Config)(nil), "moby.Config")
	proto.RegisterType((*LogConfig)(nil), "moby.LogConfig")
	proto.RegisterType((*RestartPolicy)(nil), "moby.RestartPolicy")
	proto.RegisterType((*Resources)(nil), "moby.Resources")
	proto.RegisterType((*DeviceMapping)(nil), "moby.DeviceMapping")
	proto.RegisterType((*HostConfig)(nil), "moby.HostConfig")
	proto.RegisterType((*PortBinding)(nil), "moby.PortBinding")
	proto.RegisterType((*PortMap)(nil), "moby.PortMap")
	proto.RegisterType((*PortMap_PortBindings)(nil), "moby.PortMap.PortBindings")
	proto.RegisterType((*PortSet)(nil), "moby.PortSet")
	proto.RegisterType((*VolumeMount)(nil), "moby.VolumeMount")
	proto.RegisterType((*BindOptions)(nil), "moby.BindOptions")
	proto.RegisterType((*VolumeOptions)(nil), "moby.VolumeOptions")
	proto.RegisterType((*DriverConfig)(nil), "moby.DriverConfig")
	proto.RegisterType((*TmpfsOptions)(nil), "moby.TmpfsOptions")
	proto.RegisterType((*WeightDevice)(nil), "moby.WeightDevice")
	proto.RegisterType((*ThrottleDevice)(nil), "moby.ThrottleDevice")
	proto.RegisterType((*Ulimit)(nil), "moby.Ulimit")
	proto.RegisterType((*NetworkingConfig)(nil), "moby.NetworkingConfig")
	proto.RegisterType((*EndpointSettings)(nil), "moby.EndpointSettings")
	proto.RegisterType((*EndpointIPAMConfig)(nil), "moby.EndpointIPAMConfig")
	proto.RegisterType((*ImageSummary)(nil), "moby.ImageSummary")
	proto.RegisterType((*ImageInspect)(nil), "moby.ImageInspect")
	proto.RegisterType((*RootFS)(nil), "moby.RootFS")
	proto.RegisterType((*ImageMetadata)(nil), "moby.ImageMetadata")
	proto.RegisterType((*GraphDriverData)(nil), "moby.GraphDriverData")
	proto.RegisterType((*Port)(nil), "moby.Port")
	proto.RegisterType((*NetworkSettings)(nil), "moby.NetworkSettings")
	proto.RegisterType((*SummaryNetworkSettings)(nil), "moby.SummaryNetworkSettings")
	proto.RegisterType((*Address)(nil), "moby.Address")
	proto.RegisterType((*NetworkSettingsBase)(nil), "moby.NetworkSettingsBase")
	proto.RegisterType((*DefaultNetworkSettings)(nil), "moby.DefaultNetworkSettings")
	proto.RegisterType((*MountPoint)(nil), "moby.MountPoint")
	proto.RegisterType((*Container)(nil), "moby.Container")
	proto.RegisterType((*Container_HostConfig)(nil), "moby.Container.HostConfig")
	proto.RegisterType((*ContainerState)(nil), "moby.ContainerState")
	proto.RegisterType((*ContainerNode)(nil), "moby.ContainerNode")
	proto.RegisterType((*ContainerJSONBase)(nil), "moby.ContainerJSONBase")
	proto.RegisterType((*ContainerJSON)(nil), "moby.ContainerJSON")
	proto.RegisterType((*NetworkResource)(nil), "moby.NetworkResource")
	proto.RegisterType((*EndpointResource)(nil), "moby.EndpointResource")
	proto.RegisterType((*NetworkCreate)(nil), "moby.NetworkCreate")
	proto.RegisterType((*NetworkCreateRequest)(nil), "moby.NetworkCreateRequest")
	proto.RegisterType((*NetworkCreateResponse)(nil), "moby.NetworkCreateResponse")
	proto.RegisterType((*NetworkConnect)(nil), "moby.NetworkConnect")
	proto.RegisterType((*NetworkDisconnect)(nil), "moby.NetworkDisconnect")
	proto.RegisterType((*IPAM)(nil), "moby.IPAM")
	proto.RegisterType((*IPAMConfig)(nil), "moby.IPAMConfig")
	proto.RegisterType((*Image)(nil), "moby.Image")
	proto.RegisterType((*ImageListOptions)(nil), "moby.ImageListOptions")
	proto.RegisterType((*ContainerListOptions)(nil), "moby.ContainerListOptions")
	proto.RegisterType((*FiltersArgs)(nil), "moby.FiltersArgs")
	proto.RegisterType((*FiltersArgs_Value)(nil), "moby.FiltersArgs.Value")
}
func (m *HealthConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Test) > 0 {
		for _, s := range m.Test {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IntervalSeconds != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.IntervalSeconds))
	}
	if m.TimeoutSeconds != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TimeoutSeconds))
	}
	if m.StartPeriod != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.StartPeriod))
	}
	if m.Retries != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Retries))
	}
	return i, nil
}

func (m *Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Config) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hostname) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	if len(m.Domainname) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Domainname)))
		i += copy(dAtA[i:], m.Domainname)
	}
	if len(m.User) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	if m.AttachStdin {
		dAtA[i] = 0x20
		i++
		if m.AttachStdin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AttachStdout {
		dAtA[i] = 0x28
		i++
		if m.AttachStdout {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AttachStderr {
		dAtA[i] = 0x30
		i++
		if m.AttachStderr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ExposedPorts != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ExposedPorts.Size()))
		n1, err := m.ExposedPorts.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Tty {
		dAtA[i] = 0x40
		i++
		if m.Tty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OpenStdin {
		dAtA[i] = 0x48
		i++
		if m.OpenStdin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StdinOnce {
		dAtA[i] = 0x50
		i++
		if m.StdinOnce {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Env) > 0 {
		for _, s := range m.Env {
			dAtA[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Cmd) > 0 {
		for _, s := range m.Cmd {
			dAtA[i] = 0x62
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Healthcheck != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Healthcheck.Size()))
		n2, err := m.Healthcheck.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.ArgsEscaped {
		dAtA[i] = 0x70
		i++
		if m.ArgsEscaped {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.Volumes) > 0 {
		for k, _ := range m.Volumes {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			v := m.Volumes[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.WorkingDir) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.WorkingDir)))
		i += copy(dAtA[i:], m.WorkingDir)
	}
	if len(m.Entrypoint) > 0 {
		for _, s := range m.Entrypoint {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.NetworkDisabled {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.NetworkDisabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	if len(m.OnBuild) > 0 {
		for _, s := range m.OnBuild {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.StopSignal) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.StopSignal)))
		i += copy(dAtA[i:], m.StopSignal)
	}
	if m.StopTimeout != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.StopTimeout))
	}
	if len(m.Shell) > 0 {
		for _, s := range m.Shell {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *LogConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Config) > 0 {
		for k, _ := range m.Config {
			dAtA[i] = 0x12
			i++
			v := m.Config[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *RestartPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestartPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.MaximumRetryCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MaximumRetryCount))
	}
	return i, nil
}

func (m *Resources) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resources) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CpuShares != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CpuShares))
	}
	if m.Memory != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Memory))
	}
	if m.NanoCpus != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.NanoCpus))
	}
	if len(m.CgroupParent) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.CgroupParent)))
		i += copy(dAtA[i:], m.CgroupParent)
	}
	if m.BlkioWeight != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.BlkioWeight))
	}
	if len(m.BlkioWeightDevice) > 0 {
		for _, msg := range m.BlkioWeightDevice {
			dAtA[i] = 0x32
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BlkioDeviceReadBps) > 0 {
		for _, msg := range m.BlkioDeviceReadBps {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BlkioDeviceWriteBps) > 0 {
		for _, msg := range m.BlkioDeviceWriteBps {
			dAtA[i] = 0x42
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BlkioDeviceReadIops) > 0 {
		for _, msg := range m.BlkioDeviceReadIops {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BlkioDeviceWriteIops) > 0 {
		for _, msg := range m.BlkioDeviceWriteIops {
			dAtA[i] = 0x52
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CpuPeriod != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CpuPeriod))
	}
	if m.CpuQuota != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CpuQuota))
	}
	if m.CpuRealtimePeriod != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CpuRealtimePeriod))
	}
	if m.CpuRealtimeRuntime != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CpuRealtimeRuntime))
	}
	if len(m.CpusetCpus) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.CpusetCpus)))
		i += copy(dAtA[i:], m.CpusetCpus)
	}
	if len(m.CpusetMems) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.CpusetMems)))
		i += copy(dAtA[i:], m.CpusetMems)
	}
	if len(m.Devices) > 0 {
		for _, msg := range m.Devices {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DeviceCgroupRules) > 0 {
		for _, s := range m.DeviceCgroupRules {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.DiskQuota != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DiskQuota))
	}
	if m.KernelMemory != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.KernelMemory))
	}
	if m.MemoryReservation != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MemoryReservation))
	}
	if m.MemorySwap != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MemorySwap))
	}
	if m.MemorySwappiness != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MemorySwappiness))
	}
	if m.OomKillDisable {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		if m.OomKillDisable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PidsLimit != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PidsLimit))
	}
	if len(m.Ulimits) > 0 {
		for _, msg := range m.Ulimits {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CpuCount != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CpuCount))
	}
	if m.CpuPercent != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CpuPercent))
	}
	if m.IoMaximumIops != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.IoMaximumIops))
	}
	if m.IoMaximumBandwidth != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.IoMaximumBandwidth))
	}
	return i, nil
}

func (m *DeviceMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceMapping) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PathOnHost) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.PathOnHost)))
		i += copy(dAtA[i:], m.PathOnHost)
	}
	if len(m.PathInContainer) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.PathInContainer)))
		i += copy(dAtA[i:], m.PathInContainer)
	}
	if len(m.CgroupPermissions) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.CgroupPermissions)))
		i += copy(dAtA[i:], m.CgroupPermissions)
	}
	return i, nil
}

func (m *HostConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Binds) > 0 {
		for _, s := range m.Binds {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ContainerIdFile) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ContainerIdFile)))
		i += copy(dAtA[i:], m.ContainerIdFile)
	}
	if m.LogConfig != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LogConfig.Size()))
		n3, err := m.LogConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.NetworkMode) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.NetworkMode)))
		i += copy(dAtA[i:], m.NetworkMode)
	}
	if m.PortBindings != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PortBindings.Size()))
		n4, err := m.PortBindings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.RestartPolicy != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RestartPolicy.Size()))
		n5, err := m.RestartPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.AutoRemove {
		dAtA[i] = 0x38
		i++
		if m.AutoRemove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.VolumeDriver) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.VolumeDriver)))
		i += copy(dAtA[i:], m.VolumeDriver)
	}
	if len(m.VolumesFrom) > 0 {
		for _, s := range m.VolumesFrom {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.CapAdd) > 0 {
		for _, s := range m.CapAdd {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.CapDrop) > 0 {
		for _, s := range m.CapDrop {
			dAtA[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Dns) > 0 {
		for _, s := range m.Dns {
			dAtA[i] = 0x62
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DnsOptions) > 0 {
		for _, s := range m.DnsOptions {
			dAtA[i] = 0x6a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DnsSearch) > 0 {
		for _, s := range m.DnsSearch {
			dAtA[i] = 0x72
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ExtraHosts) > 0 {
		for _, s := range m.ExtraHosts {
			dAtA[i] = 0x7a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.GroupAdd) > 0 {
		for _, s := range m.GroupAdd {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.IpcMode) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.IpcMode)))
		i += copy(dAtA[i:], m.IpcMode)
	}
	if len(m.Cgroup) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Cgroup)))
		i += copy(dAtA[i:], m.Cgroup)
	}
	if len(m.Links) > 0 {
		for _, s := range m.Links {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.OomScoreAdj != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.OomScoreAdj))
	}
	if len(m.PidMode) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.PidMode)))
		i += copy(dAtA[i:], m.PidMode)
	}
	if m.Privileged {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		if m.Privileged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PublishAllPorts {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		if m.PublishAllPorts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReadonlyRootfs {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		if m.ReadonlyRootfs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.SecurityOpt) > 0 {
		for _, s := range m.SecurityOpt {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.StorageOpt) > 0 {
		for k, _ := range m.StorageOpt {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x1
			i++
			v := m.StorageOpt[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Tmpfs) > 0 {
		for k, _ := range m.Tmpfs {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x1
			i++
			v := m.Tmpfs[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.UtsMode) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.UtsMode)))
		i += copy(dAtA[i:], m.UtsMode)
	}
	if len(m.UsernsMode) > 0 {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.UsernsMode)))
		i += copy(dAtA[i:], m.UsernsMode)
	}
	if m.ShmSize != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ShmSize))
	}
	if len(m.Sysctls) > 0 {
		for k, _ := range m.Sysctls {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x1
			i++
			v := m.Sysctls[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Runtime) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Runtime)))
		i += copy(dAtA[i:], m.Runtime)
	}
	if m.ConsoleSizeHeight != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ConsoleSizeHeight))
	}
	if m.ConsoleSizeWidth != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ConsoleSizeWidth))
	}
	if len(m.Isolation) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Isolation)))
		i += copy(dAtA[i:], m.Isolation)
	}
	if m.Resources != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Resources.Size()))
		n6, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.Mounts) > 0 {
		for _, msg := range m.Mounts {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Init {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		if m.Init {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *PortBinding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortBinding) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostIp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.HostIp)))
		i += copy(dAtA[i:], m.HostIp)
	}
	if len(m.HostPort) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.HostPort)))
		i += copy(dAtA[i:], m.HostPort)
	}
	return i, nil
}

func (m *PortMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortMap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for k, _ := range m.Value {
			dAtA[i] = 0xa
			i++
			v := m.Value[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n7, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n7
			}
		}
	}
	if len(m.MappingInfo) > 0 {
		for k, _ := range m.MappingInfo {
			dAtA[i] = 0x12
			i++
			v := m.MappingInfo[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n8, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n8
			}
		}
	}
	return i, nil
}

func (m *PortMap_PortBindings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortMap_PortBindings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PortBindings) > 0 {
		for _, msg := range m.PortBindings {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PortSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for k, _ := range m.Value {
			dAtA[i] = 0xa
			i++
			v := m.Value[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *VolumeMount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolumeMount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MountType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.MountType)))
		i += copy(dAtA[i:], m.MountType)
	}
	if len(m.Source) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Target) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Target)))
		i += copy(dAtA[i:], m.Target)
	}
	if len(m.ReadOnly) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ReadOnly)))
		i += copy(dAtA[i:], m.ReadOnly)
	}
	if len(m.Consistency) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Consistency)))
		i += copy(dAtA[i:], m.Consistency)
	}
	if m.BindOptions != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.BindOptions.Size()))
		n9, err := m.BindOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.VolumeOptions != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.VolumeOptions.Size()))
		n10, err := m.VolumeOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.TmpfsOptions != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TmpfsOptions.Size()))
		n11, err := m.TmpfsOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *BindOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BindOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Propagation) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Propagation)))
		i += copy(dAtA[i:], m.Propagation)
	}
	return i, nil
}

func (m *VolumeOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolumeOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NoCopy {
		dAtA[i] = 0x8
		i++
		if m.NoCopy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0x12
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Driver != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Driver.Size()))
		n12, err := m.Driver.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *DriverConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DriverConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Options) > 0 {
		for k, _ := range m.Options {
			dAtA[i] = 0x12
			i++
			v := m.Options[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *TmpfsOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TmpfsOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SizeBytes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SizeBytes))
	}
	if m.Mode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mode))
	}
	return i, nil
}

func (m *WeightDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WeightDevice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.Weight != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Weight))
	}
	return i, nil
}

func (m *ThrottleDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThrottleDevice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.Rate != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Rate))
	}
	return i, nil
}

func (m *Ulimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ulimit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Hard != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Hard))
	}
	if m.Soft != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Soft))
	}
	return i, nil
}

func (m *NetworkingConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkingConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EndpointsConfig) > 0 {
		for k, _ := range m.EndpointsConfig {
			dAtA[i] = 0xa
			i++
			v := m.EndpointsConfig[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n13, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n13
			}
		}
	}
	return i, nil
}

func (m *EndpointSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointSettings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IpamConfig != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.IpamConfig.Size()))
		n14, err := m.IpamConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.Links) > 0 {
		for _, s := range m.Links {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Aliases) > 0 {
		for _, s := range m.Aliases {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.NetworkId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.NetworkId)))
		i += copy(dAtA[i:], m.NetworkId)
	}
	if len(m.EndpointId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.EndpointId)))
		i += copy(dAtA[i:], m.EndpointId)
	}
	if len(m.Gateway) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Gateway)))
		i += copy(dAtA[i:], m.Gateway)
	}
	if len(m.IpAddress) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.IpAddress)))
		i += copy(dAtA[i:], m.IpAddress)
	}
	if m.IpPrefixLen != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.IpPrefixLen))
	}
	if len(m.Ipv6Gateway) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Ipv6Gateway)))
		i += copy(dAtA[i:], m.Ipv6Gateway)
	}
	if len(m.GlobalIpv6Address) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.GlobalIpv6Address)))
		i += copy(dAtA[i:], m.GlobalIpv6Address)
	}
	if m.GlobalIpv6PrefixLen != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.GlobalIpv6PrefixLen))
	}
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	if len(m.DriverOpts) > 0 {
		for k, _ := range m.DriverOpts {
			dAtA[i] = 0x6a
			i++
			v := m.DriverOpts[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *EndpointIPAMConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointIPAMConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ipv4Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Ipv4Address)))
		i += copy(dAtA[i:], m.Ipv4Address)
	}
	if len(m.Ipv6Address) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Ipv6Address)))
		i += copy(dAtA[i:], m.Ipv6Address)
	}
	if len(m.LinkLocalIps) > 0 {
		for _, s := range m.LinkLocalIps {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ImageSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageSummary) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Containers != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Containers))
	}
	if m.Created != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Created))
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0x22
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.ParentId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ParentId)))
		i += copy(dAtA[i:], m.ParentId)
	}
	if len(m.RepoDigests) > 0 {
		for _, s := range m.RepoDigests {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.RepoTags) > 0 {
		for _, s := range m.RepoTags {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.SharedSize != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SharedSize))
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Size_))
	}
	if m.VirtualSize != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.VirtualSize))
	}
	return i, nil
}

func (m *ImageInspect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageInspect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.RepoTags) > 0 {
		for _, s := range m.RepoTags {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.RepoDigests) > 0 {
		for _, s := range m.RepoDigests {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Parent) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Parent)))
		i += copy(dAtA[i:], m.Parent)
	}
	if len(m.Comment) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if len(m.Created) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Created)))
		i += copy(dAtA[i:], m.Created)
	}
	if len(m.Container) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Container)))
		i += copy(dAtA[i:], m.Container)
	}
	if m.ContainerConfig != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ContainerConfig.Size()))
		n15, err := m.ContainerConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.DockerVersion) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.DockerVersion)))
		i += copy(dAtA[i:], m.DockerVersion)
	}
	if len(m.Author) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Author)))
		i += copy(dAtA[i:], m.Author)
	}
	if m.Config != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Config.Size()))
		n16, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if len(m.Architecture) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Architecture)))
		i += copy(dAtA[i:], m.Architecture)
	}
	if len(m.Os) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Os)))
		i += copy(dAtA[i:], m.Os)
	}
	if len(m.OsVersion) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.OsVersion)))
		i += copy(dAtA[i:], m.OsVersion)
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Size_))
	}
	if m.VirtualSize != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.VirtualSize))
	}
	if m.GraphDriver != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.GraphDriver.Size()))
		n17, err := m.GraphDriver.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.RootFs != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RootFs.Size()))
		n18, err := m.RootFs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Metadata != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Metadata.Size()))
		n19, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *RootFS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RootFS) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FsType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.FsType)))
		i += copy(dAtA[i:], m.FsType)
	}
	if len(m.Layers) > 0 {
		for _, s := range m.Layers {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.BaseLayer) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.BaseLayer)))
		i += copy(dAtA[i:], m.BaseLayer)
	}
	return i, nil
}

func (m *ImageMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LastTagTime) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.LastTagTime)))
		i += copy(dAtA[i:], m.LastTagTime)
	}
	return i, nil
}

func (m *GraphDriverData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphDriverData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, _ := range m.Data {
			dAtA[i] = 0xa
			i++
			v := m.Data[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *Port) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Port) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ip) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Ip)))
		i += copy(dAtA[i:], m.Ip)
	}
	if m.PrivatePort != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PrivatePort))
	}
	if m.PublicPort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PublicPort))
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	return i, nil
}

func (m *NetworkSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkSettings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NetworkSettingsBase != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.NetworkSettingsBase.Size()))
		n20, err := m.NetworkSettingsBase.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.DefaultNetworkSettings != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DefaultNetworkSettings.Size()))
		n21, err := m.DefaultNetworkSettings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.Networks) > 0 {
		for k, _ := range m.Networks {
			dAtA[i] = 0x1a
			i++
			v := m.Networks[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n22, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n22
			}
		}
	}
	return i, nil
}

func (m *SummaryNetworkSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SummaryNetworkSettings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Networks) > 0 {
		for k, _ := range m.Networks {
			dAtA[i] = 0xa
			i++
			v := m.Networks[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n23, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n23
			}
		}
	}
	return i, nil
}

func (m *Address) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Address) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Addr)))
		i += copy(dAtA[i:], m.Addr)
	}
	if m.PrefixLen != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PrefixLen))
	}
	return i, nil
}

func (m *NetworkSettingsBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkSettingsBase) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Bridge) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Bridge)))
		i += copy(dAtA[i:], m.Bridge)
	}
	if len(m.SandboxId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.SandboxId)))
		i += copy(dAtA[i:], m.SandboxId)
	}
	if m.HairpinMode {
		dAtA[i] = 0x18
		i++
		if m.HairpinMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.LinkLocalIpv6Address) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.LinkLocalIpv6Address)))
		i += copy(dAtA[i:], m.LinkLocalIpv6Address)
	}
	if m.LinkLocalIpv6PrefixLen != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LinkLocalIpv6PrefixLen))
	}
	if m.Ports != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Ports.Size()))
		n24, err := m.Ports.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if len(m.SandboxKey) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.SandboxKey)))
		i += copy(dAtA[i:], m.SandboxKey)
	}
	if len(m.SecondaryIpAddresses) > 0 {
		for _, msg := range m.SecondaryIpAddresses {
			dAtA[i] = 0x42
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SecondaryIpv6Addresses) > 0 {
		for _, msg := range m.SecondaryIpv6Addresses {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DefaultNetworkSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefaultNetworkSettings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EndpointId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.EndpointId)))
		i += copy(dAtA[i:], m.EndpointId)
	}
	if len(m.Gateway) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Gateway)))
		i += copy(dAtA[i:], m.Gateway)
	}
	if len(m.GlobalIpv6Address) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.GlobalIpv6Address)))
		i += copy(dAtA[i:], m.GlobalIpv6Address)
	}
	if m.GlobalIpv6PrefixLen != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.GlobalIpv6PrefixLen))
	}
	if len(m.IpAddress) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.IpAddress)))
		i += copy(dAtA[i:], m.IpAddress)
	}
	if m.IpPrefixLen != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.IpPrefixLen))
	}
	if len(m.Ipv6Gateway) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Ipv6Gateway)))
		i += copy(dAtA[i:], m.Ipv6Gateway)
	}
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	return i, nil
}

func (m *MountPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MountPoint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Source) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Destination) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Destination)))
		i += copy(dAtA[i:], m.Destination)
	}
	if len(m.Driver) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Driver)))
		i += copy(dAtA[i:], m.Driver)
	}
	if len(m.Mode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Mode)))
		i += copy(dAtA[i:], m.Mode)
	}
	if m.Rw {
		dAtA[i] = 0x30
		i++
		if m.Rw {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Propagation) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Propagation)))
		i += copy(dAtA[i:], m.Propagation)
	}
	return i, nil
}

func (m *Container) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Container) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.ImageId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ImageId)))
		i += copy(dAtA[i:], m.ImageId)
	}
	if len(m.Command) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Command)))
		i += copy(dAtA[i:], m.Command)
	}
	if m.Created != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Created))
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SizeRw != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SizeRw))
	}
	if m.SizeRootFs != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SizeRootFs))
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0x52
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.State) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if m.HostConfig != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.HostConfig.Size()))
		n25, err := m.HostConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.NetworkSettings != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.NetworkSettings.Size()))
		n26, err := m.NetworkSettings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if len(m.Mounts) > 0 {
		for _, msg := range m.Mounts {
			dAtA[i] = 0x7a
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Container_HostConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Container_HostConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NetworkMode) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.NetworkMode)))
		i += copy(dAtA[i:], m.NetworkMode)
	}
	return i, nil
}

func (m *ContainerState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if m.Running {
		dAtA[i] = 0x10
		i++
		if m.Running {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Paused {
		dAtA[i] = 0x18
		i++
		if m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Restarting {
		dAtA[i] = 0x20
		i++
		if m.Restarting {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OomKilled {
		dAtA[i] = 0x28
		i++
		if m.OomKilled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Dead {
		dAtA[i] = 0x30
		i++
		if m.Dead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Pid != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Pid))
	}
	if m.ExitCode != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ExitCode))
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if len(m.StartedAt) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.StartedAt)))
		i += copy(dAtA[i:], m.StartedAt)
	}
	if len(m.FinishedAt) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.FinishedAt)))
		i += copy(dAtA[i:], m.FinishedAt)
	}
	return i, nil
}

func (m *ContainerNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.IpAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.IpAddress)))
		i += copy(dAtA[i:], m.IpAddress)
	}
	if len(m.Addr) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Addr)))
		i += copy(dAtA[i:], m.Addr)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Cpus != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Cpus))
	}
	if m.Memory != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Memory))
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0x3a
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *ContainerJSONBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerJSONBase) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Created) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Created)))
		i += copy(dAtA[i:], m.Created)
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.State != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.State.Size()))
		n27, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.ResolvConfPath) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ResolvConfPath)))
		i += copy(dAtA[i:], m.ResolvConfPath)
	}
	if len(m.HostnamePath) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.HostnamePath)))
		i += copy(dAtA[i:], m.HostnamePath)
	}
	if len(m.HostsPath) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.HostsPath)))
		i += copy(dAtA[i:], m.HostsPath)
	}
	if len(m.LogPath) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.LogPath)))
		i += copy(dAtA[i:], m.LogPath)
	}
	if m.Node != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Node.Size()))
		n28, err := m.Node.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.RestartCount != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RestartCount))
	}
	if len(m.Driver) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Driver)))
		i += copy(dAtA[i:], m.Driver)
	}
	if len(m.MountLabel) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.MountLabel)))
		i += copy(dAtA[i:], m.MountLabel)
	}
	if len(m.ProcessLabel) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ProcessLabel)))
		i += copy(dAtA[i:], m.ProcessLabel)
	}
	if len(m.AppArmorProfile) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.AppArmorProfile)))
		i += copy(dAtA[i:], m.AppArmorProfile)
	}
	if len(m.ExecIds) > 0 {
		for _, s := range m.ExecIds {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.HostConfig != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.HostConfig.Size()))
		n29, err := m.HostConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.GraphDriver != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.GraphDriver.Size()))
		n30, err := m.GraphDriver.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.SizeRw != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SizeRw))
	}
	if m.SizeRootFs != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SizeRootFs))
	}
	return i, nil
}

func (m *ContainerJSON) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerJSON) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ContainerJsonBase != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ContainerJsonBase.Size()))
		n31, err := m.ContainerJsonBase.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if len(m.Mounts) > 0 {
		for _, msg := range m.Mounts {
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Config != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Config.Size()))
		n32, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.NetworkSettings != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.NetworkSettings.Size()))
		n33, err := m.NetworkSettings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}

func (m *NetworkResource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkResource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Scope) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Scope)))
		i += copy(dAtA[i:], m.Scope)
	}
	if len(m.Driver) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Driver)))
		i += copy(dAtA[i:], m.Driver)
	}
	if m.EnableIpv6 {
		dAtA[i] = 0x28
		i++
		if m.EnableIpv6 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Ipam != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Ipam.Size()))
		n34, err := m.Ipam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.Internal {
		dAtA[i] = 0x38
		i++
		if m.Internal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Containers) > 0 {
		for k, _ := range m.Containers {
			dAtA[i] = 0x42
			i++
			v := m.Containers[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n35, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n35
			}
		}
	}
	if len(m.Options) > 0 {
		for k, _ := range m.Options {
			dAtA[i] = 0x4a
			i++
			v := m.Options[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0x52
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *EndpointResource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointResource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.EndpointId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.EndpointId)))
		i += copy(dAtA[i:], m.EndpointId)
	}
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	if len(m.Ipv4Address) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Ipv4Address)))
		i += copy(dAtA[i:], m.Ipv4Address)
	}
	if len(m.Ipv6Address) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Ipv6Address)))
		i += copy(dAtA[i:], m.Ipv6Address)
	}
	return i, nil
}

func (m *NetworkCreate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkCreate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CheckDuplicate {
		dAtA[i] = 0x8
		i++
		if m.CheckDuplicate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Driver) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Driver)))
		i += copy(dAtA[i:], m.Driver)
	}
	if m.EnableIpv6 {
		dAtA[i] = 0x18
		i++
		if m.EnableIpv6 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Ipam != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Ipam.Size()))
		n36, err := m.Ipam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.Internal {
		dAtA[i] = 0x28
		i++
		if m.Internal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Options) > 0 {
		for k, _ := range m.Options {
			dAtA[i] = 0x32
			i++
			v := m.Options[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0x3a
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *NetworkCreateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkCreateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NetworkCreate != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.NetworkCreate.Size()))
		n37, err := m.NetworkCreate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *NetworkCreateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkCreateResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Warning) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Warning)))
		i += copy(dAtA[i:], m.Warning)
	}
	return i, nil
}

func (m *NetworkConnect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkConnect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Container) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Container)))
		i += copy(dAtA[i:], m.Container)
	}
	if m.EndpointConfig != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.EndpointConfig.Size()))
		n38, err := m.EndpointConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}

func (m *NetworkDisconnect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkDisconnect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Container) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Container)))
		i += copy(dAtA[i:], m.Container)
	}
	if m.Force {
		dAtA[i] = 0x10
		i++
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *IPAM) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAM) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Driver) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Driver)))
		i += copy(dAtA[i:], m.Driver)
	}
	if len(m.Options) > 0 {
		for k, _ := range m.Options {
			dAtA[i] = 0x12
			i++
			v := m.Options[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Config) > 0 {
		for _, msg := range m.Config {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IPAMConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAMConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Subnet) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Subnet)))
		i += copy(dAtA[i:], m.Subnet)
	}
	if len(m.IpRange) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.IpRange)))
		i += copy(dAtA[i:], m.IpRange)
	}
	if len(m.Gateway) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Gateway)))
		i += copy(dAtA[i:], m.Gateway)
	}
	if len(m.AuxAddress) > 0 {
		for k, _ := range m.AuxAddress {
			dAtA[i] = 0x22
			i++
			v := m.AuxAddress[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *Image) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Image) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.ParentId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ParentId)))
		i += copy(dAtA[i:], m.ParentId)
	}
	if len(m.RepoTags) > 0 {
		for _, s := range m.RepoTags {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.RepoDigests) > 0 {
		for _, s := range m.RepoDigests {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Created != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Created))
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Size_))
	}
	if m.VirtualSize != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.VirtualSize))
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0x42
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *ImageListOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageListOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MatchName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.MatchName)))
		i += copy(dAtA[i:], m.MatchName)
	}
	if m.All {
		dAtA[i] = 0x10
		i++
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Filter != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Filter.Size()))
		n39, err := m.Filter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}

func (m *ContainerListOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerListOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Quiet {
		dAtA[i] = 0x8
		i++
		if m.Quiet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Size_ {
		dAtA[i] = 0x10
		i++
		if m.Size_ {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.All {
		dAtA[i] = 0x18
		i++
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Latest {
		dAtA[i] = 0x20
		i++
		if m.Latest {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Since) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Since)))
		i += copy(dAtA[i:], m.Since)
	}
	if len(m.Before) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Before)))
		i += copy(dAtA[i:], m.Before)
	}
	if m.Limit != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Limit))
	}
	if m.Filter != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Filter.Size()))
		n40, err := m.Filter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}

func (m *FiltersArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FiltersArgs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for k, _ := range m.Fields {
			dAtA[i] = 0xa
			i++
			v := m.Fields[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n41, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n41
			}
		}
	}
	return i, nil
}

func (m *FiltersArgs_Value) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FiltersArgs_Value) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for k, _ := range m.Value {
			dAtA[i] = 0xa
			i++
			v := m.Value[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + 1
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	return i, nil
}

func encodeFixed64Api(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Api(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *HealthConfig) Size() (n int) {
	var l int
	_ = l
	if len(m.Test) > 0 {
		for _, s := range m.Test {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.IntervalSeconds != 0 {
		n += 1 + sovApi(uint64(m.IntervalSeconds))
	}
	if m.TimeoutSeconds != 0 {
		n += 1 + sovApi(uint64(m.TimeoutSeconds))
	}
	if m.StartPeriod != 0 {
		n += 1 + sovApi(uint64(m.StartPeriod))
	}
	if m.Retries != 0 {
		n += 1 + sovApi(uint64(m.Retries))
	}
	return n
}

func (m *Config) Size() (n int) {
	var l int
	_ = l
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Domainname)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.AttachStdin {
		n += 2
	}
	if m.AttachStdout {
		n += 2
	}
	if m.AttachStderr {
		n += 2
	}
	if m.ExposedPorts != nil {
		l = m.ExposedPorts.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Tty {
		n += 2
	}
	if m.OpenStdin {
		n += 2
	}
	if m.StdinOnce {
		n += 2
	}
	if len(m.Env) > 0 {
		for _, s := range m.Env {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.Cmd) > 0 {
		for _, s := range m.Cmd {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Healthcheck != nil {
		l = m.Healthcheck.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ArgsEscaped {
		n += 2
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Volumes) > 0 {
		for k, v := range m.Volumes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovApi(uint64(mapEntrySize))
		}
	}
	l = len(m.WorkingDir)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if len(m.Entrypoint) > 0 {
		for _, s := range m.Entrypoint {
			l = len(s)
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if m.NetworkDisabled {
		n += 3
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if len(m.OnBuild) > 0 {
		for _, s := range m.OnBuild {
			l = len(s)
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovApi(uint64(mapEntrySize))
		}
	}
	l = len(m.StopSignal)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.StopTimeout != 0 {
		n += 2 + sovApi(uint64(m.StopTimeout))
	}
	if len(m.Shell) > 0 {
		for _, s := range m.Shell {
			l = len(s)
			n += 2 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *LogConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Config) > 0 {
		for k, v := range m.Config {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RestartPolicy) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MaximumRetryCount != 0 {
		n += 1 + sovApi(uint64(m.MaximumRetryCount))
	}
	return n
}

func (m *Resources) Size() (n int) {
	var l int
	_ = l
	if m.CpuShares != 0 {
		n += 1 + sovApi(uint64(m.CpuShares))
	}
	if m.Memory != 0 {
		n += 1 + sovApi(uint64(m.Memory))
	}
	if m.NanoCpus != 0 {
		n += 1 + sovApi(uint64(m.NanoCpus))
	}
	l = len(m.CgroupParent)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BlkioWeight != 0 {
		n += 1 + sovApi(uint64(m.BlkioWeight))
	}
	if len(m.BlkioWeightDevice) > 0 {
		for _, e := range m.BlkioWeightDevice {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.BlkioDeviceReadBps) > 0 {
		for _, e := range m.BlkioDeviceReadBps {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.BlkioDeviceWriteBps) > 0 {
		for _, e := range m.BlkioDeviceWriteBps {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.BlkioDeviceReadIops) > 0 {
		for _, e := range m.BlkioDeviceReadIops {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.BlkioDeviceWriteIops) > 0 {
		for _, e := range m.BlkioDeviceWriteIops {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.CpuPeriod != 0 {
		n += 1 + sovApi(uint64(m.CpuPeriod))
	}
	if m.CpuQuota != 0 {
		n += 1 + sovApi(uint64(m.CpuQuota))
	}
	if m.CpuRealtimePeriod != 0 {
		n += 1 + sovApi(uint64(m.CpuRealtimePeriod))
	}
	if m.CpuRealtimeRuntime != 0 {
		n += 1 + sovApi(uint64(m.CpuRealtimeRuntime))
	}
	l = len(m.CpusetCpus)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.CpusetMems)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if len(m.DeviceCgroupRules) > 0 {
		for _, s := range m.DeviceCgroupRules {
			l = len(s)
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if m.DiskQuota != 0 {
		n += 2 + sovApi(uint64(m.DiskQuota))
	}
	if m.KernelMemory != 0 {
		n += 2 + sovApi(uint64(m.KernelMemory))
	}
	if m.MemoryReservation != 0 {
		n += 2 + sovApi(uint64(m.MemoryReservation))
	}
	if m.MemorySwap != 0 {
		n += 2 + sovApi(uint64(m.MemorySwap))
	}
	if m.MemorySwappiness != 0 {
		n += 2 + sovApi(uint64(m.MemorySwappiness))
	}
	if m.OomKillDisable {
		n += 3
	}
	if m.PidsLimit != 0 {
		n += 2 + sovApi(uint64(m.PidsLimit))
	}
	if len(m.Ulimits) > 0 {
		for _, e := range m.Ulimits {
			l = e.Size()
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if m.CpuCount != 0 {
		n += 2 + sovApi(uint64(m.CpuCount))
	}
	if m.CpuPercent != 0 {
		n += 2 + sovApi(uint64(m.CpuPercent))
	}
	if m.IoMaximumIops != 0 {
		n += 2 + sovApi(uint64(m.IoMaximumIops))
	}
	if m.IoMaximumBandwidth != 0 {
		n += 2 + sovApi(uint64(m.IoMaximumBandwidth))
	}
	return n
}

func (m *DeviceMapping) Size() (n int) {
	var l int
	_ = l
	l = len(m.PathOnHost)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.PathInContainer)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.CgroupPermissions)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *HostConfig) Size() (n int) {
	var l int
	_ = l
	if len(m.Binds) > 0 {
		for _, s := range m.Binds {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = len(m.ContainerIdFile)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.LogConfig != nil {
		l = m.LogConfig.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.NetworkMode)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.PortBindings != nil {
		l = m.PortBindings.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.RestartPolicy != nil {
		l = m.RestartPolicy.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.AutoRemove {
		n += 2
	}
	l = len(m.VolumeDriver)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.VolumesFrom) > 0 {
		for _, s := range m.VolumesFrom {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.CapAdd) > 0 {
		for _, s := range m.CapAdd {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.CapDrop) > 0 {
		for _, s := range m.CapDrop {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.Dns) > 0 {
		for _, s := range m.Dns {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.DnsOptions) > 0 {
		for _, s := range m.DnsOptions {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.DnsSearch) > 0 {
		for _, s := range m.DnsSearch {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.ExtraHosts) > 0 {
		for _, s := range m.ExtraHosts {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.GroupAdd) > 0 {
		for _, s := range m.GroupAdd {
			l = len(s)
			n += 2 + l + sovApi(uint64(l))
		}
	}
	l = len(m.IpcMode)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.Cgroup)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if len(m.Links) > 0 {
		for _, s := range m.Links {
			l = len(s)
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if m.OomScoreAdj != 0 {
		n += 2 + sovApi(uint64(m.OomScoreAdj))
	}
	l = len(m.PidMode)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.Privileged {
		n += 3
	}
	if m.PublishAllPorts {
		n += 3
	}
	if m.ReadonlyRootfs {
		n += 3
	}
	if len(m.SecurityOpt) > 0 {
		for _, s := range m.SecurityOpt {
			l = len(s)
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if len(m.StorageOpt) > 0 {
		for k, v := range m.StorageOpt {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovApi(uint64(mapEntrySize))
		}
	}
	if len(m.Tmpfs) > 0 {
		for k, v := range m.Tmpfs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovApi(uint64(mapEntrySize))
		}
	}
	l = len(m.UtsMode)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.UsernsMode)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.ShmSize != 0 {
		n += 2 + sovApi(uint64(m.ShmSize))
	}
	if len(m.Sysctls) > 0 {
		for k, v := range m.Sysctls {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 2 + sovApi(uint64(mapEntrySize))
		}
	}
	l = len(m.Runtime)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.ConsoleSizeHeight != 0 {
		n += 2 + sovApi(uint64(m.ConsoleSizeHeight))
	}
	if m.ConsoleSizeWidth != 0 {
		n += 2 + sovApi(uint64(m.ConsoleSizeWidth))
	}
	l = len(m.Isolation)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	if len(m.Mounts) > 0 {
		for _, e := range m.Mounts {
			l = e.Size()
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if m.Init {
		n += 3
	}
	return n
}

func (m *PortBinding) Size() (n int) {
	var l int
	_ = l
	l = len(m.HostIp)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.HostPort)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *PortMap) Size() (n int) {
	var l int
	_ = l
	if len(m.Value) > 0 {
		for k, v := range m.Value {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if len(m.MappingInfo) > 0 {
		for k, v := range m.MappingInfo {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PortMap_PortBindings) Size() (n int) {
	var l int
	_ = l
	if len(m.PortBindings) > 0 {
		for _, e := range m.PortBindings {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *PortSet) Size() (n int) {
	var l int
	_ = l
	if len(m.Value) > 0 {
		for k, v := range m.Value {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VolumeMount) Size() (n int) {
	var l int
	_ = l
	l = len(m.MountType)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ReadOnly)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Consistency)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BindOptions != nil {
		l = m.BindOptions.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.VolumeOptions != nil {
		l = m.VolumeOptions.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.TmpfsOptions != nil {
		l = m.TmpfsOptions.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *BindOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.Propagation)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *VolumeOptions) Size() (n int) {
	var l int
	_ = l
	if m.NoCopy {
		n += 2
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.Driver != nil {
		l = m.Driver.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *DriverConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Options) > 0 {
		for k, v := range m.Options {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TmpfsOptions) Size() (n int) {
	var l int
	_ = l
	if m.SizeBytes != 0 {
		n += 1 + sovApi(uint64(m.SizeBytes))
	}
	if m.Mode != 0 {
		n += 1 + sovApi(uint64(m.Mode))
	}
	return n
}

func (m *WeightDevice) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Weight != 0 {
		n += 1 + sovApi(uint64(m.Weight))
	}
	return n
}

func (m *ThrottleDevice) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Rate != 0 {
		n += 1 + sovApi(uint64(m.Rate))
	}
	return n
}

func (m *Ulimit) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Hard != 0 {
		n += 1 + sovApi(uint64(m.Hard))
	}
	if m.Soft != 0 {
		n += 1 + sovApi(uint64(m.Soft))
	}
	return n
}

func (m *NetworkingConfig) Size() (n int) {
	var l int
	_ = l
	if len(m.EndpointsConfig) > 0 {
		for k, v := range m.EndpointsConfig {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EndpointSettings) Size() (n int) {
	var l int
	_ = l
	if m.IpamConfig != nil {
		l = m.IpamConfig.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Links) > 0 {
		for _, s := range m.Links {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.Aliases) > 0 {
		for _, s := range m.Aliases {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = len(m.NetworkId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.EndpointId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Gateway)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.IpPrefixLen != 0 {
		n += 1 + sovApi(uint64(m.IpPrefixLen))
	}
	l = len(m.Ipv6Gateway)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.GlobalIpv6Address)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GlobalIpv6PrefixLen != 0 {
		n += 1 + sovApi(uint64(m.GlobalIpv6PrefixLen))
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.DriverOpts) > 0 {
		for k, v := range m.DriverOpts {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EndpointIPAMConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ipv4Address)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Ipv6Address)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.LinkLocalIps) > 0 {
		for _, s := range m.LinkLocalIps {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *ImageSummary) Size() (n int) {
	var l int
	_ = l
	if m.Containers != 0 {
		n += 1 + sovApi(uint64(m.Containers))
	}
	if m.Created != 0 {
		n += 1 + sovApi(uint64(m.Created))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.RepoDigests) > 0 {
		for _, s := range m.RepoDigests {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.RepoTags) > 0 {
		for _, s := range m.RepoTags {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.SharedSize != 0 {
		n += 1 + sovApi(uint64(m.SharedSize))
	}
	if m.Size_ != 0 {
		n += 1 + sovApi(uint64(m.Size_))
	}
	if m.VirtualSize != 0 {
		n += 1 + sovApi(uint64(m.VirtualSize))
	}
	return n
}

func (m *ImageInspect) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.RepoTags) > 0 {
		for _, s := range m.RepoTags {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.RepoDigests) > 0 {
		for _, s := range m.RepoDigests {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = len(m.Parent)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Created)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Container)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ContainerConfig != nil {
		l = m.ContainerConfig.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.DockerVersion)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Architecture)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Os)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.OsVersion)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovApi(uint64(m.Size_))
	}
	if m.VirtualSize != 0 {
		n += 2 + sovApi(uint64(m.VirtualSize))
	}
	if m.GraphDriver != nil {
		l = m.GraphDriver.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	if m.RootFs != nil {
		l = m.RootFs.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}

func (m *RootFS) Size() (n int) {
	var l int
	_ = l
	l = len(m.FsType)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Layers) > 0 {
		for _, s := range m.Layers {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = len(m.BaseLayer)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ImageMetadata) Size() (n int) {
	var l int
	_ = l
	l = len(m.LastTagTime)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *GraphDriverData) Size() (n int) {
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *Port) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.PrivatePort != 0 {
		n += 1 + sovApi(uint64(m.PrivatePort))
	}
	if m.PublicPort != 0 {
		n += 1 + sovApi(uint64(m.PublicPort))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *NetworkSettings) Size() (n int) {
	var l int
	_ = l
	if m.NetworkSettingsBase != nil {
		l = m.NetworkSettingsBase.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.DefaultNetworkSettings != nil {
		l = m.DefaultNetworkSettings.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Networks) > 0 {
		for k, v := range m.Networks {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SummaryNetworkSettings) Size() (n int) {
	var l int
	_ = l
	if len(m.Networks) > 0 {
		for k, v := range m.Networks {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Address) Size() (n int) {
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.PrefixLen != 0 {
		n += 1 + sovApi(uint64(m.PrefixLen))
	}
	return n
}

func (m *NetworkSettingsBase) Size() (n int) {
	var l int
	_ = l
	l = len(m.Bridge)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.SandboxId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.HairpinMode {
		n += 2
	}
	l = len(m.LinkLocalIpv6Address)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.LinkLocalIpv6PrefixLen != 0 {
		n += 1 + sovApi(uint64(m.LinkLocalIpv6PrefixLen))
	}
	if m.Ports != nil {
		l = m.Ports.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.SandboxKey)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.SecondaryIpAddresses) > 0 {
		for _, e := range m.SecondaryIpAddresses {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.SecondaryIpv6Addresses) > 0 {
		for _, e := range m.SecondaryIpv6Addresses {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *DefaultNetworkSettings) Size() (n int) {
	var l int
	_ = l
	l = len(m.EndpointId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Gateway)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.GlobalIpv6Address)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GlobalIpv6PrefixLen != 0 {
		n += 1 + sovApi(uint64(m.GlobalIpv6PrefixLen))
	}
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.IpPrefixLen != 0 {
		n += 1 + sovApi(uint64(m.IpPrefixLen))
	}
	l = len(m.Ipv6Gateway)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *MountPoint) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Driver)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Rw {
		n += 2
	}
	l = len(m.Propagation)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *Container) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ImageId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Command)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Created != 0 {
		n += 1 + sovApi(uint64(m.Created))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.SizeRw != 0 {
		n += 1 + sovApi(uint64(m.SizeRw))
	}
	if m.SizeRootFs != 0 {
		n += 1 + sovApi(uint64(m.SizeRootFs))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.HostConfig != nil {
		l = m.HostConfig.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.NetworkSettings != nil {
		l = m.NetworkSettings.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Mounts) > 0 {
		for _, e := range m.Mounts {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *Container_HostConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.NetworkMode)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ContainerState) Size() (n int) {
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Running {
		n += 2
	}
	if m.Paused {
		n += 2
	}
	if m.Restarting {
		n += 2
	}
	if m.OomKilled {
		n += 2
	}
	if m.Dead {
		n += 2
	}
	if m.Pid != 0 {
		n += 1 + sovApi(uint64(m.Pid))
	}
	if m.ExitCode != 0 {
		n += 1 + sovApi(uint64(m.ExitCode))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.StartedAt)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.FinishedAt)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ContainerNode) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Cpus != 0 {
		n += 1 + sovApi(uint64(m.Cpus))
	}
	if m.Memory != 0 {
		n += 1 + sovApi(uint64(m.Memory))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ContainerJSONBase) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Created)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ResolvConfPath)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.HostnamePath)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.HostsPath)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.LogPath)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.RestartCount != 0 {
		n += 1 + sovApi(uint64(m.RestartCount))
	}
	l = len(m.Driver)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.MountLabel)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ProcessLabel)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.AppArmorProfile)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if len(m.ExecIds) > 0 {
		for _, s := range m.ExecIds {
			l = len(s)
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if m.HostConfig != nil {
		l = m.HostConfig.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	if m.GraphDriver != nil {
		l = m.GraphDriver.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	if m.SizeRw != 0 {
		n += 2 + sovApi(uint64(m.SizeRw))
	}
	if m.SizeRootFs != 0 {
		n += 2 + sovApi(uint64(m.SizeRootFs))
	}
	return n
}

func (m *ContainerJSON) Size() (n int) {
	var l int
	_ = l
	if m.ContainerJsonBase != nil {
		l = m.ContainerJsonBase.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Mounts) > 0 {
		for _, e := range m.Mounts {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.NetworkSettings != nil {
		l = m.NetworkSettings.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *NetworkResource) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Scope)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Driver)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.EnableIpv6 {
		n += 2
	}
	if m.Ipam != nil {
		l = m.Ipam.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Internal {
		n += 2
	}
	if len(m.Containers) > 0 {
		for k, v := range m.Containers {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if len(m.Options) > 0 {
		for k, v := range m.Options {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EndpointResource) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.EndpointId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Ipv4Address)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Ipv6Address)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *NetworkCreate) Size() (n int) {
	var l int
	_ = l
	if m.CheckDuplicate {
		n += 2
	}
	l = len(m.Driver)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.EnableIpv6 {
		n += 2
	}
	if m.Ipam != nil {
		l = m.Ipam.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Internal {
		n += 2
	}
	if len(m.Options) > 0 {
		for k, v := range m.Options {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *NetworkCreateRequest) Size() (n int) {
	var l int
	_ = l
	if m.NetworkCreate != nil {
		l = m.NetworkCreate.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *NetworkCreateResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Warning)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *NetworkConnect) Size() (n int) {
	var l int
	_ = l
	l = len(m.Container)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.EndpointConfig != nil {
		l = m.EndpointConfig.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *NetworkDisconnect) Size() (n int) {
	var l int
	_ = l
	l = len(m.Container)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Force {
		n += 2
	}
	return n
}

func (m *IPAM) Size() (n int) {
	var l int
	_ = l
	l = len(m.Driver)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Options) > 0 {
		for k, v := range m.Options {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if len(m.Config) > 0 {
		for _, e := range m.Config {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *IPAMConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Subnet)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.IpRange)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Gateway)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.AuxAddress) > 0 {
		for k, v := range m.AuxAddress {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Image) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.RepoTags) > 0 {
		for _, s := range m.RepoTags {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.RepoDigests) > 0 {
		for _, s := range m.RepoDigests {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Created != 0 {
		n += 1 + sovApi(uint64(m.Created))
	}
	if m.Size_ != 0 {
		n += 1 + sovApi(uint64(m.Size_))
	}
	if m.VirtualSize != 0 {
		n += 1 + sovApi(uint64(m.VirtualSize))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ImageListOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.MatchName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.All {
		n += 2
	}
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ContainerListOptions) Size() (n int) {
	var l int
	_ = l
	if m.Quiet {
		n += 2
	}
	if m.Size_ {
		n += 2
	}
	if m.All {
		n += 2
	}
	if m.Latest {
		n += 2
	}
	l = len(m.Since)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Before)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovApi(uint64(m.Limit))
	}
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *FiltersArgs) Size() (n int) {
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for k, v := range m.Fields {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FiltersArgs_Value) Size() (n int) {
	var l int
	_ = l
	if len(m.Value) > 0 {
		for k, v := range m.Value {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + 1
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HealthConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Test", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Test = append(m.Test, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalSeconds", wireType)
			}
			m.IntervalSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntervalSeconds |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutSeconds", wireType)
			}
			m.TimeoutSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutSeconds |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPeriod", wireType)
			}
			m.StartPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartPeriod |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retries", wireType)
			}
			m.Retries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retries |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domainname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domainname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachStdin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AttachStdin = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachStdout", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AttachStdout = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachStderr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AttachStderr = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExposedPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExposedPorts == nil {
				m.ExposedPorts = &PortSet{}
			}
			if err := m.ExposedPorts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tty = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenStdin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OpenStdin = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StdinOnce", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StdinOnce = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = append(m.Env, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmd = append(m.Cmd, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Healthcheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Healthcheck == nil {
				m.Healthcheck = &HealthConfig{}
			}
			if err := m.Healthcheck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgsEscaped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ArgsEscaped = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Volumes == nil {
				m.Volumes = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Volumes[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Volumes[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkingDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entrypoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entrypoint = append(m.Entrypoint, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkDisabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NetworkDisabled = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnBuild", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnBuild = append(m.OnBuild, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Labels[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Labels[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopSignal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StopSignal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopTimeout", wireType)
			}
			m.StopTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StopTimeout |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shell", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shell = append(m.Shell, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Config == nil {
				m.Config = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Config[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Config[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestartPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestartPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestartPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumRetryCount", wireType)
			}
			m.MaximumRetryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumRetryCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resources) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resources: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resources: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuShares", wireType)
			}
			m.CpuShares = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuShares |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NanoCpus", wireType)
			}
			m.NanoCpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NanoCpus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CgroupParent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CgroupParent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlkioWeight", wireType)
			}
			m.BlkioWeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlkioWeight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlkioWeightDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlkioWeightDevice = append(m.BlkioWeightDevice, &WeightDevice{})
			if err := m.BlkioWeightDevice[len(m.BlkioWeightDevice)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlkioDeviceReadBps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlkioDeviceReadBps = append(m.BlkioDeviceReadBps, &ThrottleDevice{})
			if err := m.BlkioDeviceReadBps[len(m.BlkioDeviceReadBps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlkioDeviceWriteBps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlkioDeviceWriteBps = append(m.BlkioDeviceWriteBps, &ThrottleDevice{})
			if err := m.BlkioDeviceWriteBps[len(m.BlkioDeviceWriteBps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlkioDeviceReadIops", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlkioDeviceReadIops = append(m.BlkioDeviceReadIops, &ThrottleDevice{})
			if err := m.BlkioDeviceReadIops[len(m.BlkioDeviceReadIops)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlkioDeviceWriteIops", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlkioDeviceWriteIops = append(m.BlkioDeviceWriteIops, &ThrottleDevice{})
			if err := m.BlkioDeviceWriteIops[len(m.BlkioDeviceWriteIops)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuPeriod", wireType)
			}
			m.CpuPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuPeriod |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuQuota", wireType)
			}
			m.CpuQuota = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuQuota |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuRealtimePeriod", wireType)
			}
			m.CpuRealtimePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuRealtimePeriod |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuRealtimeRuntime", wireType)
			}
			m.CpuRealtimeRuntime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuRealtimeRuntime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpusetCpus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpusetCpus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpusetMems", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpusetMems = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, &DeviceMapping{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceCgroupRules", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceCgroupRules = append(m.DeviceCgroupRules, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskQuota", wireType)
			}
			m.DiskQuota = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskQuota |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelMemory", wireType)
			}
			m.KernelMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KernelMemory |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryReservation", wireType)
			}
			m.MemoryReservation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryReservation |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemorySwap", wireType)
			}
			m.MemorySwap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemorySwap |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemorySwappiness", wireType)
			}
			m.MemorySwappiness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemorySwappiness |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OomKillDisable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OomKillDisable = bool(v != 0)
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PidsLimit", wireType)
			}
			m.PidsLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PidsLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ulimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ulimits = append(m.Ulimits, &Ulimit{})
			if err := m.Ulimits[len(m.Ulimits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuCount", wireType)
			}
			m.CpuCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuPercent", wireType)
			}
			m.CpuPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuPercent |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoMaximumIops", wireType)
			}
			m.IoMaximumIops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IoMaximumIops |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoMaximumBandwidth", wireType)
			}
			m.IoMaximumBandwidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IoMaximumBandwidth |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathOnHost", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathOnHost = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathInContainer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathInContainer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CgroupPermissions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CgroupPermissions = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Binds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Binds = append(m.Binds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerIdFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerIdFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LogConfig == nil {
				m.LogConfig = &LogConfig{}
			}
			if err := m.LogConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortBindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortBindings == nil {
				m.PortBindings = &PortMap{}
			}
			if err := m.PortBindings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestartPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RestartPolicy == nil {
				m.RestartPolicy = &RestartPolicy{}
			}
			if err := m.RestartPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoRemove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoRemove = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeDriver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeDriver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumesFrom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumesFrom = append(m.VolumesFrom, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapAdd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapAdd = append(m.CapAdd, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapDrop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapDrop = append(m.CapDrop, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dns = append(m.Dns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsOptions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsOptions = append(m.DnsOptions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsSearch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsSearch = append(m.DnsSearch, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraHosts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraHosts = append(m.ExtraHosts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupAdd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupAdd = append(m.GroupAdd, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpcMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpcMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cgroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cgroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Links = append(m.Links, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OomScoreAdj", wireType)
			}
			m.OomScoreAdj = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OomScoreAdj |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PidMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PidMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Privileged = bool(v != 0)
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishAllPorts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PublishAllPorts = bool(v != 0)
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadonlyRootfs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadonlyRootfs = bool(v != 0)
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityOpt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityOpt = append(m.SecurityOpt, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageOpt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.StorageOpt == nil {
				m.StorageOpt = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.StorageOpt[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.StorageOpt[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tmpfs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Tmpfs == nil {
				m.Tmpfs = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Tmpfs[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Tmpfs[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UtsMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UtsMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsernsMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsernsMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShmSize", wireType)
			}
			m.ShmSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShmSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sysctls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Sysctls == nil {
				m.Sysctls = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Sysctls[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Sysctls[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Runtime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Runtime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsoleSizeHeight", wireType)
			}
			m.ConsoleSizeHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConsoleSizeHeight |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsoleSizeWidth", wireType)
			}
			m.ConsoleSizeWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConsoleSizeWidth |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isolation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Isolation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &Resources{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mounts = append(m.Mounts, &VolumeMount{})
			if err := m.Mounts[len(m.Mounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Init", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Init = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortBinding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortBinding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortBinding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Value == nil {
				m.Value = make(map[string]*PortBinding)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthApi
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthApi
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &PortBinding{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Value[mapkey] = mapvalue
			} else {
				var mapvalue *PortBinding
				m.Value[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MappingInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.MappingInfo == nil {
				m.MappingInfo = make(map[string]*PortMap_PortBindings)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthApi
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthApi
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &PortMap_PortBindings{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.MappingInfo[mapkey] = mapvalue
			} else {
				var mapvalue *PortMap_PortBindings
				m.MappingInfo[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortMap_PortBindings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortBindings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortBindings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortBindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortBindings = append(m.PortBindings, &PortBinding{})
			if err := m.PortBindings[len(m.PortBindings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Value == nil {
				m.Value = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Value[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Value[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolumeMount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolumeMount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolumeMount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadOnly = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Consistency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Consistency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BindOptions == nil {
				m.BindOptions = &BindOptions{}
			}
			if err := m.BindOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeOptions == nil {
				m.VolumeOptions = &VolumeOptions{}
			}
			if err := m.VolumeOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TmpfsOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TmpfsOptions == nil {
				m.TmpfsOptions = &TmpfsOptions{}
			}
			if err := m.TmpfsOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BindOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BindOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BindOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Propagation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Propagation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolumeOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolumeOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolumeOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoCopy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoCopy = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Labels[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Labels[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Driver == nil {
				m.Driver = &DriverConfig{}
			}
			if err := m.Driver.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DriverConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DriverConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DriverConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Options == nil {
				m.Options = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Options[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Options[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TmpfsOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TmpfsOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TmpfsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WeightDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WeightDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WeightDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThrottleDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThrottleDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThrottleDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			m.Rate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rate |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ulimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ulimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ulimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hard", wireType)
			}
			m.Hard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hard |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Soft", wireType)
			}
			m.Soft = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Soft |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkingConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkingConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkingConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.EndpointsConfig == nil {
				m.EndpointsConfig = make(map[string]*EndpointSettings)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthApi
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthApi
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &EndpointSettings{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.EndpointsConfig[mapkey] = mapvalue
			} else {
				var mapvalue *EndpointSettings
				m.EndpointsConfig[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpamConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpamConfig == nil {
				m.IpamConfig = &EndpointIPAMConfig{}
			}
			if err := m.IpamConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Links = append(m.Links, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aliases", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aliases = append(m.Aliases, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixLen", wireType)
			}
			m.IpPrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpPrefixLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6Gateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv6Gateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalIpv6Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GlobalIpv6Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalIpv6PrefixLen", wireType)
			}
			m.GlobalIpv6PrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalIpv6PrefixLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DriverOpts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.DriverOpts == nil {
				m.DriverOpts = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.DriverOpts[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.DriverOpts[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointIPAMConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointIPAMConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointIPAMConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv6Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkLocalIps", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkLocalIps = append(m.LinkLocalIps, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			m.Containers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Containers |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Created |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Labels[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Labels[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoDigests", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoDigests = append(m.RepoDigests, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoTags = append(m.RepoTags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharedSize", wireType)
			}
			m.SharedSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SharedSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualSize", wireType)
			}
			m.VirtualSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VirtualSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageInspect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageInspect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageInspect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoTags = append(m.RepoTags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoDigests", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoDigests = append(m.RepoDigests, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Created = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Container = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerConfig == nil {
				m.ContainerConfig = &Config{}
			}
			if err := m.ContainerConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DockerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DockerVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &Config{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Architecture", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Architecture = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Os = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OsVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualSize", wireType)
			}
			m.VirtualSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VirtualSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphDriver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GraphDriver == nil {
				m.GraphDriver = &GraphDriverData{}
			}
			if err := m.GraphDriver.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootFs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RootFs == nil {
				m.RootFs = &RootFS{}
			}
			if err := m.RootFs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &ImageMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RootFS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RootFS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RootFS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FsType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FsType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Layers = append(m.Layers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseLayer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseLayer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTagTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastTagTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GraphDriverData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphDriverData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphDriverData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Data == nil {
				m.Data = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Data[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Data[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Port) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Port: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Port: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivatePort", wireType)
			}
			m.PrivatePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrivatePort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicPort", wireType)
			}
			m.PublicPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PublicPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkSettingsBase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkSettingsBase == nil {
				m.NetworkSettingsBase = &NetworkSettingsBase{}
			}
			if err := m.NetworkSettingsBase.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultNetworkSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultNetworkSettings == nil {
				m.DefaultNetworkSettings = &DefaultNetworkSettings{}
			}
			if err := m.DefaultNetworkSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Networks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Networks == nil {
				m.Networks = make(map[string]*EndpointSettings)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthApi
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthApi
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &EndpointSettings{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Networks[mapkey] = mapvalue
			} else {
				var mapvalue *EndpointSettings
				m.Networks[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SummaryNetworkSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SummaryNetworkSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SummaryNetworkSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Networks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Networks == nil {
				m.Networks = make(map[string]*EndpointSettings)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthApi
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthApi
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &EndpointSettings{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Networks[mapkey] = mapvalue
			} else {
				var mapvalue *EndpointSettings
				m.Networks[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Address) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Address: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Address: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLen", wireType)
			}
			m.PrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkSettingsBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkSettingsBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkSettingsBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bridge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bridge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SandboxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SandboxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HairpinMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HairpinMode = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkLocalIpv6Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkLocalIpv6Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkLocalIpv6PrefixLen", wireType)
			}
			m.LinkLocalIpv6PrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkLocalIpv6PrefixLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ports == nil {
				m.Ports = &PortMap{}
			}
			if err := m.Ports.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SandboxKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SandboxKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryIpAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecondaryIpAddresses = append(m.SecondaryIpAddresses, &Address{})
			if err := m.SecondaryIpAddresses[len(m.SecondaryIpAddresses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryIpv6Addresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecondaryIpv6Addresses = append(m.SecondaryIpv6Addresses, &Address{})
			if err := m.SecondaryIpv6Addresses[len(m.SecondaryIpv6Addresses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefaultNetworkSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefaultNetworkSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefaultNetworkSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalIpv6Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GlobalIpv6Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalIpv6PrefixLen", wireType)
			}
			m.GlobalIpv6PrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalIpv6PrefixLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixLen", wireType)
			}
			m.IpPrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpPrefixLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6Gateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv6Gateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MountPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MountPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MountPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Driver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rw", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rw = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Propagation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Propagation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Container) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Container: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Container: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Created |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &Port{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeRw", wireType)
			}
			m.SizeRw = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeRw |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeRootFs", wireType)
			}
			m.SizeRootFs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeRootFs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Labels[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Labels[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HostConfig == nil {
				m.HostConfig = &Container_HostConfig{}
			}
			if err := m.HostConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkSettings == nil {
				m.NetworkSettings = &SummaryNetworkSettings{}
			}
			if err := m.NetworkSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mounts = append(m.Mounts, &MountPoint{})
			if err := m.Mounts[len(m.Mounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Container_HostConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Running", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Running = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paused = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Restarting", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Restarting = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OomKilled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OomKilled = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dead = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitCode", wireType)
			}
			m.ExitCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExitCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FinishedAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpus", wireType)
			}
			m.Cpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cpus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Labels[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Labels[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerJSONBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerJSONBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerJSONBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Created = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &ContainerState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvConfPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResolvConfPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostnamePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostnamePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostsPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostsPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &ContainerNode{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestartCount", wireType)
			}
			m.RestartCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RestartCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Driver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcessLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppArmorProfile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppArmorProfile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecIds = append(m.ExecIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HostConfig == nil {
				m.HostConfig = &HostConfig{}
			}
			if err := m.HostConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphDriver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GraphDriver == nil {
				m.GraphDriver = &GraphDriverData{}
			}
			if err := m.GraphDriver.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeRw", wireType)
			}
			m.SizeRw = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeRw |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeRootFs", wireType)
			}
			m.SizeRootFs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeRootFs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerJSON) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerJSON: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerJSON: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerJsonBase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerJsonBase == nil {
				m.ContainerJsonBase = &ContainerJSONBase{}
			}
			if err := m.ContainerJsonBase.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mounts = append(m.Mounts, &MountPoint{})
			if err := m.Mounts[len(m.Mounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &Config{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkSettings == nil {
				m.NetworkSettings = &NetworkSettings{}
			}
			if err := m.NetworkSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkResource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkResource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkResource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scope = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Driver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableIpv6", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableIpv6 = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ipam == nil {
				m.Ipam = &IPAM{}
			}
			if err := m.Ipam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Internal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Internal = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Containers == nil {
				m.Containers = make(map[string]*EndpointResource)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthApi
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthApi
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &EndpointResource{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Containers[mapkey] = mapvalue
			} else {
				var mapvalue *EndpointResource
				m.Containers[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Options == nil {
				m.Options = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Options[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Options[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Labels[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Labels[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointResource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointResource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointResource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv6Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkCreate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkCreate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkCreate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckDuplicate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CheckDuplicate = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Driver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableIpv6", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableIpv6 = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ipam == nil {
				m.Ipam = &IPAM{}
			}
			if err := m.Ipam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Internal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Internal = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Options == nil {
				m.Options = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Options[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Options[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Labels[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Labels[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkCreateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkCreateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkCreateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkCreate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkCreate == nil {
				m.NetworkCreate = &NetworkCreate{}
			}
			if err := m.NetworkCreate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkCreateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkCreateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkCreateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Warning", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Warning = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkConnect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkConnect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkConnect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Container = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndpointConfig == nil {
				m.EndpointConfig = &EndpointSettings{}
			}
			if err := m.EndpointConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkDisconnect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkDisconnect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkDisconnect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Container = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAM) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAM: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAM: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Driver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Options == nil {
				m.Options = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Options[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Options[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = append(m.Config, &IPAMConfig{})
			if err := m.Config[len(m.Config)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAMConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAMConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAMConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpRange", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpRange = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuxAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.AuxAddress == nil {
				m.AuxAddress = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.AuxAddress[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.AuxAddress[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Image) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Image: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Image: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoTags = append(m.RepoTags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoDigests", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoDigests = append(m.RepoDigests, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Created |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualSize", wireType)
			}
			m.VirtualSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VirtualSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthApi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Labels[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Labels[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageListOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &FiltersArgs{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerListOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quiet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Quiet = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Size_ = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Latest = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Since", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Since = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Before = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &FiltersArgs{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FiltersArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FiltersArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FiltersArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Fields == nil {
				m.Fields = make(map[string]*FiltersArgs_Value)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthApi
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthApi
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &FiltersArgs_Value{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Fields[mapkey] = mapvalue
			} else {
				var mapvalue *FiltersArgs_Value
				m.Fields[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FiltersArgs_Value) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthApi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Value == nil {
				m.Value = make(map[string]bool)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvaluetemp int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapvaluetemp |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				mapvalue := bool(mapvaluetemp != 0)
				m.Value[mapkey] = mapvalue
			} else {
				var mapvalue bool
				m.Value[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("pb/moby/api.proto", fileDescriptorApi) }

var fileDescriptorApi = []byte{
	// 5180 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x7b, 0x4b, 0x8f, 0x1c, 0xc9,
	0x71, 0xff, 0xbf, 0xdf, 0xdd, 0xd1, 0x3d, 0xaf, 0xe2, 0x70, 0xd8, 0x9c, 0x5d, 0x72, 0x67, 0x9b,
	0xda, 0x5d, 0x6a, 0xa5, 0x9d, 0x5d, 0x2d, 0x57, 0xfb, 0xe0, 0x5f, 0x82, 0x3c, 0x24, 0x97, 0xd4,
	0x68, 0xc9, 0xe5, 0xb8, 0x86, 0x5a, 0x19, 0xba, 0x14, 0x6a, 0xba, 0x72, 0xba, 0x53, 0xac, 0xae,
	0x2c, 0x55, 0x56, 0x0f, 0x39, 0xf2, 0x45, 0xf0, 0xc1, 0x27, 0x03, 0x3e, 0x18, 0x06, 0xac, 0x83,
	0x01, 0x7f, 0x02, 0x03, 0xb6, 0xe1, 0xc7, 0xc1, 0x80, 0x6f, 0x82, 0x00, 0x03, 0x82, 0xaf, 0x86,
	0x0f, 0x36, 0xd6, 0x37, 0x03, 0xbe, 0xf8, 0x13, 0x18, 0x11, 0x91, 0x59, 0x95, 0xd5, 0xd3, 0x1c,
	0x2e, 0x4d, 0xc1, 0xbe, 0xcc, 0x54, 0x46, 0x46, 0xbe, 0x22, 0x23, 0x23, 0x7e, 0x11, 0x99, 0x0d,
	0x1b, 0xe9, 0xd1, 0xbb, 0x33, 0x75, 0x74, 0xfa, 0x6e, 0x98, 0xca, 0xdd, 0x34, 0x53, 0xb9, 0xf2,
	0x9a, 0x58, 0x1e, 0xfd, 0x55, 0x0d, 0x06, 0xdf, 0x17, 0x61, 0x9c, 0x4f, 0x6f, 0xab, 0xe4, 0x58,
	0x4e, 0x3c, 0x0f, 0x9a, 0xb9, 0xd0, 0xf9, 0xb0, 0xb6, 0xd3, 0xb8, 0xde, 0xf3, 0xe9, 0xdb, 0xfb,
	0x3a, 0xac, 0xcb, 0x24, 0x17, 0xd9, 0x49, 0x18, 0x07, 0x5a, 0x8c, 0x55, 0x12, 0xe9, 0x61, 0x7d,
	0xa7, 0x76, 0xbd, 0xe1, 0xaf, 0x59, 0xfa, 0x21, 0x93, 0xbd, 0xb7, 0x60, 0x2d, 0x97, 0x33, 0xa1,
	0xe6, 0x79, 0xc1, 0xd9, 0x20, 0xce, 0x55, 0x43, 0xb6, 0x8c, 0xaf, 0xc3, 0x40, 0xe7, 0x61, 0x96,
	0x07, 0xa9, 0xc8, 0xa4, 0x8a, 0x86, 0x4d, 0xe2, 0xea, 0x13, 0xed, 0x80, 0x48, 0xde, 0x10, 0x3a,
	0x99, 0xc8, 0x33, 0x29, 0xf4, 0xb0, 0xb5, 0x53, 0xbb, 0xde, 0xf2, 0x6d, 0x71, 0xf4, 0xf7, 0x1d,
	0x68, 0x9b, 0xf9, 0x6e, 0x43, 0x77, 0xaa, 0x74, 0x9e, 0x84, 0x33, 0x31, 0xac, 0xed, 0xd4, 0xae,
	0xf7, 0xfc, 0xa2, 0xec, 0x5d, 0x05, 0x88, 0xd4, 0x2c, 0x94, 0x09, 0xd5, 0xd6, 0xa9, 0xd6, 0xa1,
	0xe0, 0x5a, 0xe7, 0x5a, 0x64, 0x34, 0xc3, 0x9e, 0x4f, 0xdf, 0x38, 0xaf, 0x30, 0xcf, 0xc3, 0xf1,
	0x34, 0xd0, 0x79, 0x24, 0x13, 0x9a, 0x57, 0xd7, 0xef, 0x33, 0xed, 0x10, 0x49, 0xde, 0x35, 0x58,
	0x29, 0x59, 0xd4, 0x3c, 0xa7, 0xd9, 0x75, 0xfd, 0x41, 0xc1, 0xa3, 0xe6, 0x79, 0x95, 0x49, 0x64,
	0xd9, 0xb0, 0xbd, 0xc0, 0x24, 0xb2, 0xcc, 0x7b, 0x1f, 0x56, 0xc4, 0xd3, 0x54, 0x69, 0x11, 0x05,
	0xa9, 0xca, 0x72, 0x3d, 0xec, 0xec, 0xd4, 0xae, 0xf7, 0xdf, 0x5f, 0xd9, 0xc5, 0xbd, 0xd9, 0x3d,
	0x50, 0x59, 0x7e, 0x28, 0x72, 0x7f, 0x60, 0x78, 0xb0, 0xac, 0xbd, 0x75, 0x68, 0xe4, 0xf9, 0xe9,
	0xb0, 0x4b, 0xdd, 0xe1, 0xa7, 0x77, 0x05, 0x40, 0xa5, 0x22, 0x31, 0x13, 0xee, 0x51, 0x45, 0x0f,
	0x29, 0x3c, 0xdd, 0x2b, 0x00, 0x54, 0x13, 0xa8, 0x64, 0x2c, 0x86, 0xc0, 0xd5, 0x44, 0x79, 0x98,
	0x8c, 0x05, 0xf6, 0x27, 0x92, 0x93, 0x61, 0x9f, 0xf6, 0x1b, 0x3f, 0x91, 0x32, 0x9e, 0x45, 0xc3,
	0x01, 0x53, 0xc6, 0xb3, 0xc8, 0xfb, 0x00, 0xfa, 0x53, 0x52, 0x92, 0xf1, 0x54, 0x8c, 0x1f, 0x0f,
	0x57, 0x68, 0x96, 0x1e, 0xcf, 0xd2, 0xd5, 0x1e, 0xdf, 0x65, 0x23, 0x51, 0x66, 0x13, 0x1d, 0x08,
	0x3d, 0x0e, 0x53, 0x11, 0x0d, 0x57, 0x8d, 0x28, 0xb3, 0x89, 0xfe, 0x94, 0x49, 0xde, 0x26, 0xb4,
	0xe4, 0x2c, 0x9c, 0x88, 0xe1, 0x1a, 0x6d, 0x01, 0x17, 0xbc, 0x1b, 0xd0, 0x39, 0x51, 0xf1, 0x7c,
	0x26, 0xf4, 0x70, 0x7d, 0xa7, 0x71, 0xbd, 0xff, 0xfe, 0x65, 0x1e, 0x8a, 0x07, 0xd9, 0xfd, 0x82,
	0xeb, 0x3e, 0x4d, 0xf2, 0xec, 0xd4, 0xb7, 0x9c, 0xde, 0x6b, 0xd0, 0x7f, 0xa2, 0xb2, 0xc7, 0x32,
	0x99, 0x04, 0x91, 0xcc, 0x86, 0x1b, 0xbc, 0xdb, 0x86, 0x74, 0x47, 0x66, 0xa8, 0x0d, 0x02, 0x9b,
	0xa4, 0x4a, 0x26, 0xf9, 0xd0, 0xa3, 0xd5, 0x39, 0x14, 0xd4, 0xf2, 0x44, 0xe4, 0xd8, 0x20, 0x88,
	0xa4, 0x0e, 0x8f, 0x62, 0x11, 0x0d, 0x2f, 0xd0, 0x94, 0xd7, 0x0c, 0xfd, 0x8e, 0x21, 0xe3, 0x58,
	0xb3, 0x70, 0x1c, 0x84, 0x51, 0x94, 0x09, 0xad, 0x87, 0x9b, 0x3c, 0xd6, 0x2c, 0x1c, 0xef, 0x31,
	0xc5, 0xbb, 0x0c, 0x5d, 0x95, 0x04, 0x47, 0x73, 0x19, 0x47, 0xc3, 0x8b, 0x34, 0x52, 0x47, 0x25,
	0xb7, 0xb0, 0xe8, 0xbd, 0x07, 0xed, 0x38, 0x3c, 0x12, 0xb1, 0x1e, 0x6e, 0xd1, 0xda, 0x86, 0x95,
	0xb5, 0xdd, 0xa7, 0x2a, 0x5e, 0x9a, 0xe1, 0xc3, 0xd1, 0x74, 0xae, 0xd2, 0x40, 0xcb, 0x49, 0x12,
	0xc6, 0xc3, 0x4b, 0x3c, 0x1a, 0x92, 0x0e, 0x89, 0xc2, 0x67, 0x49, 0xa5, 0x81, 0x39, 0x62, 0xc3,
	0x21, 0x9d, 0x16, 0x6a, 0xf4, 0x88, 0x49, 0x28, 0x68, 0x3d, 0x15, 0x71, 0x3c, 0xbc, 0x4c, 0xb3,
	0xe1, 0xc2, 0xf6, 0x4d, 0x18, 0xb8, 0xc2, 0xc4, 0x9d, 0x7f, 0x2c, 0x4e, 0xcd, 0x39, 0xc2, 0x4f,
	0x6c, 0x77, 0x12, 0xc6, 0x73, 0x7b, 0x7a, 0xb8, 0x70, 0xb3, 0xfe, 0x71, 0x6d, 0xfb, 0x13, 0xe8,
	0x3b, 0x93, 0x7d, 0x91, 0xa6, 0xa3, 0x3f, 0xac, 0x41, 0xef, 0xbe, 0x9a, 0x38, 0x16, 0xe7, 0x34,
	0xb5, 0xa7, 0x97, 0xbe, 0xbd, 0x1b, 0xd0, 0x1e, 0x53, 0xed, 0xb0, 0x4e, 0x42, 0x7a, 0x85, 0x85,
	0x54, 0x34, 0x32, 0xe2, 0x32, 0x72, 0x62, 0x56, 0x9c, 0x91, 0x43, 0x7e, 0xa1, 0x19, 0x1d, 0xc2,
	0x8a, 0x2f, 0xd8, 0xf6, 0xa8, 0x58, 0x8e, 0x4f, 0x71, 0x52, 0x8e, 0x49, 0xa1, 0x6f, 0x6f, 0x17,
	0x2e, 0xcc, 0xc2, 0xa7, 0x72, 0x36, 0x9f, 0x05, 0x68, 0x88, 0x4e, 0x83, 0xb1, 0x9a, 0x27, 0x39,
	0x75, 0xd6, 0xf2, 0x37, 0x4c, 0x95, 0x8f, 0x35, 0xb7, 0xb1, 0x62, 0xf4, 0x67, 0x00, 0x3d, 0x5f,
	0x68, 0x35, 0xcf, 0xc6, 0x42, 0xe3, 0x31, 0x1c, 0xa7, 0xf3, 0x40, 0x4f, 0xc3, 0x4c, 0x68, 0xea,
	0xb7, 0xe1, 0xf7, 0xc6, 0xe9, 0xfc, 0x90, 0x08, 0xde, 0x16, 0xb4, 0x67, 0x62, 0xa6, 0xb2, 0x53,
	0x63, 0x59, 0x4d, 0xc9, 0x7b, 0x05, 0x7a, 0x49, 0x98, 0xa8, 0x60, 0x9c, 0xce, 0xad, 0x29, 0xed,
	0x22, 0xe1, 0x76, 0x3a, 0xd7, 0x68, 0x64, 0xc6, 0x93, 0x4c, 0xcd, 0xd3, 0x20, 0x0d, 0x33, 0x91,
	0xe4, 0x64, 0xad, 0x7a, 0xfe, 0x80, 0x89, 0x07, 0x44, 0x43, 0xed, 0x38, 0x8a, 0x1f, 0x4b, 0x15,
	0x3c, 0x11, 0x72, 0x32, 0xcd, 0x8d, 0x2d, 0xed, 0x13, 0xed, 0x47, 0x44, 0xf2, 0x6e, 0xc1, 0x05,
	0x97, 0x25, 0x88, 0xc4, 0x89, 0x1c, 0x8b, 0x61, 0x9b, 0x64, 0x6f, 0xce, 0x39, 0xb3, 0xde, 0xa1,
	0x1a, 0x7f, 0xc3, 0x69, 0xcd, 0x24, 0xef, 0x1e, 0x5c, 0xe4, 0x3e, 0xb8, 0x71, 0x90, 0x89, 0x30,
	0x0a, 0x8e, 0x52, 0xb4, 0x69, 0xd8, 0xcb, 0x26, 0xf7, 0xf2, 0x68, 0x9a, 0xa9, 0x3c, 0x8f, 0x85,
	0xe9, 0xc7, 0xa3, 0x26, 0xa6, 0x20, 0xc2, 0xe8, 0x56, 0xaa, 0xbd, 0x7d, 0xd8, 0xaa, 0x74, 0xf4,
	0x24, 0x93, 0xb9, 0xa0, 0x9e, 0xba, 0xe7, 0xf4, 0x74, 0xc1, 0xe9, 0xe9, 0x47, 0xd8, 0x62, 0x59,
	0x57, 0x34, 0x27, 0xa9, 0x52, 0x3d, 0xec, 0x7d, 0xc5, 0xae, 0x70, 0x52, 0xfb, 0x2a, 0xd5, 0xde,
	0x67, 0x70, 0x69, 0xc9, 0xac, 0xa8, 0x2f, 0x38, 0xa7, 0xaf, 0xcd, 0xc5, 0x69, 0x51, 0x67, 0x46,
	0x17, 0x8c, 0xeb, 0xeb, 0x17, 0xba, 0x60, 0x1c, 0xdf, 0x2b, 0x80, 0x85, 0xe0, 0xa7, 0x73, 0x95,
	0x87, 0xc3, 0x01, 0xef, 0xf9, 0x38, 0x9d, 0xff, 0x36, 0x96, 0x51, 0x0b, 0xb1, 0x32, 0x43, 0x43,
	0x2b, 0x67, 0xc2, 0x76, 0xb2, 0x42, 0x6c, 0x1b, 0xe3, 0x74, 0xee, 0x9b, 0x1a, 0xd3, 0xd9, 0x7b,
	0xb0, 0x59, 0xe1, 0xcf, 0xe6, 0x09, 0xfe, 0x27, 0x6b, 0xdc, 0xf0, 0x3d, 0xa7, 0x81, 0xcf, 0x35,
	0x68, 0x6f, 0x50, 0xdb, 0x44, 0xce, 0x4a, 0xc7, 0xa6, 0x19, 0x98, 0x44, 0x6a, 0x57, 0x32, 0xcc,
	0xc4, 0x0c, 0x6d, 0xb4, 0xc3, 0xf0, 0x40, 0xcc, 0xb4, 0xf7, 0x0e, 0x74, 0x58, 0x4c, 0x7a, 0xb8,
	0x41, 0xc2, 0xb9, 0xc0, 0xc2, 0x61, 0x39, 0x3c, 0x08, 0xd3, 0x54, 0x26, 0x13, 0xdf, 0xf2, 0xe0,
	0x92, 0x8c, 0x54, 0x8d, 0x36, 0x67, 0xf3, 0x58, 0x68, 0x63, 0xa2, 0x37, 0xb8, 0xea, 0x36, 0xd5,
	0xf8, 0x58, 0x81, 0xe2, 0x8b, 0xa4, 0x7e, 0x6c, 0x04, 0x74, 0x81, 0xc5, 0x87, 0x14, 0x96, 0xd0,
	0x35, 0x58, 0x79, 0x2c, 0xb2, 0x44, 0xc4, 0x81, 0x39, 0x51, 0x9b, 0xc4, 0x31, 0x60, 0xe2, 0x03,
	0x3e, 0x57, 0xef, 0x80, 0xc7, 0xb5, 0x41, 0x26, 0x34, 0x42, 0x98, 0x5c, 0xaa, 0x64, 0x78, 0x91,
	0xa5, 0xc8, 0x35, 0x7e, 0x59, 0x41, 0x16, 0x9f, 0xd9, 0xf5, 0x93, 0x30, 0x1d, 0x6e, 0x11, 0x1f,
	0x30, 0xe9, 0xf0, 0x49, 0x98, 0x7a, 0xdf, 0x80, 0x0d, 0x87, 0x21, 0x95, 0x09, 0x3a, 0x86, 0x4b,
	0xc4, 0xb6, 0x5e, 0xb2, 0x31, 0xdd, 0xbb, 0x0e, 0xeb, 0x4a, 0xcd, 0x82, 0xc7, 0x32, 0x8e, 0xad,
	0xaf, 0x21, 0xa3, 0xdd, 0xf5, 0x57, 0x95, 0x9a, 0x7d, 0x26, 0xe3, 0xd8, 0xb8, 0x1a, 0x5c, 0x6a,
	0x2a, 0x23, 0x1d, 0xc4, 0x72, 0x26, 0xf3, 0xe1, 0x65, 0x5e, 0x2a, 0x52, 0xee, 0x23, 0xc1, 0x7b,
	0x13, 0x3a, 0x73, 0xaa, 0xd2, 0xc3, 0x6d, 0x12, 0xf4, 0x80, 0x05, 0xfd, 0x43, 0x22, 0xfa, 0xb6,
	0xd2, 0x6a, 0x14, 0x1b, 0xac, 0x57, 0x0a, 0x8d, 0x22, 0x3b, 0x65, 0xb6, 0x13, 0x15, 0x69, 0x8c,
	0x36, 0xe4, 0x55, 0x5e, 0x1b, 0xab, 0x23, 0x52, 0xbc, 0x37, 0x61, 0x4d, 0xaa, 0xc0, 0xda, 0x3e,
	0xd2, 0xf9, 0x2b, 0x3b, 0xb5, 0xeb, 0x4d, 0x7f, 0x45, 0xaa, 0x07, 0x4c, 0x25, 0xb5, 0x7e, 0x0f,
	0x36, 0x1d, 0xbe, 0xa3, 0x30, 0x89, 0x9e, 0xc8, 0x28, 0x9f, 0x0e, 0xaf, 0x12, 0xb3, 0x57, 0x30,
	0xdf, 0xb2, 0x35, 0xa3, 0x3f, 0xa8, 0xc1, 0x4a, 0x45, 0x29, 0xbc, 0x1d, 0x18, 0xa4, 0x61, 0x3e,
	0x0d, 0x54, 0x12, 0x20, 0x8e, 0x33, 0x06, 0x18, 0x90, 0xf6, 0x30, 0xf9, 0xbe, 0xd2, 0xb9, 0xf7,
	0x36, 0x6c, 0x10, 0x87, 0x4c, 0x82, 0xb1, 0x4a, 0xf2, 0x50, 0x26, 0x22, 0x33, 0x16, 0x7d, 0x0d,
	0x2b, 0xf6, 0x93, 0xdb, 0x96, 0x8c, 0xbb, 0x6c, 0x0d, 0xa4, 0xc8, 0x66, 0x52, 0x6b, 0xa9, 0x12,
	0x6d, 0xf0, 0xde, 0x86, 0xb1, 0x92, 0x65, 0xc5, 0xe8, 0x4f, 0x07, 0x00, 0x38, 0x86, 0xf1, 0x4c,
	0x9b, 0xd0, 0x3a, 0x92, 0x08, 0x61, 0x19, 0x0c, 0x73, 0x01, 0xc7, 0x2f, 0xc6, 0x0d, 0x64, 0x14,
	0x1c, 0xcb, 0xd8, 0x7a, 0x94, 0xb5, 0xa2, 0x62, 0x3f, 0xba, 0x2b, 0x63, 0x74, 0x19, 0x10, 0xab,
	0x49, 0x60, 0x7c, 0x59, 0x83, 0x70, 0xd3, 0xda, 0x82, 0x2f, 0xf3, 0x7b, 0x71, 0xe1, 0x0b, 0x5f,
	0x87, 0x81, 0xc5, 0x20, 0x33, 0x15, 0x09, 0x63, 0xcf, 0xfb, 0x86, 0xf6, 0x40, 0x45, 0x02, 0x31,
	0x23, 0x62, 0xc5, 0x00, 0x27, 0x23, 0x93, 0x09, 0x63, 0xe3, 0x0a, 0x66, 0x7c, 0x10, 0xa6, 0xfe,
	0x00, 0x79, 0x6e, 0x19, 0x16, 0xef, 0x26, 0xac, 0x66, 0xc2, 0xc0, 0x6d, 0xf2, 0x6f, 0x84, 0x46,
	0x8b, 0x63, 0x59, 0x71, 0x7d, 0xfe, 0x4a, 0x56, 0xf1, 0x84, 0xaf, 0x41, 0x3f, 0x9c, 0xe7, 0x2a,
	0xc8, 0xc4, 0x4c, 0x9d, 0x08, 0x42, 0xa8, 0x5d, 0x1f, 0x90, 0xe4, 0x13, 0x05, 0x8f, 0x1b, 0x63,
	0xb0, 0x20, 0xca, 0xe4, 0x89, 0xc8, 0x08, 0x9a, 0xf6, 0xfc, 0x01, 0x13, 0xef, 0x10, 0x0d, 0x17,
	0x66, 0x80, 0x5a, 0x70, 0x9c, 0xa9, 0x19, 0xd9, 0xdf, 0x9e, 0xdf, 0x37, 0xb4, 0xbb, 0x99, 0x9a,
	0x79, 0x97, 0xa0, 0x33, 0x0e, 0x53, 0x04, 0x55, 0x64, 0x51, 0x7b, 0x7e, 0x7b, 0x1c, 0xa6, 0x7b,
	0x51, 0x84, 0x60, 0x0a, 0x2b, 0xa2, 0x4c, 0xa5, 0x06, 0xa6, 0x22, 0xe3, 0x9d, 0x4c, 0xa5, 0xe8,
	0xe3, 0xa3, 0x44, 0x5b, 0xa8, 0x1a, 0x25, 0x64, 0x9b, 0xa2, 0x44, 0x07, 0x2a, 0xcd, 0x69, 0xab,
	0x57, 0x18, 0xe6, 0x45, 0x89, 0x7e, 0xc8, 0x14, 0x32, 0x1e, 0x89, 0x0e, 0xb4, 0x08, 0xb3, 0xf1,
	0x74, 0xb8, 0x4a, 0xf5, 0xbd, 0x28, 0xd1, 0x87, 0x44, 0xc0, 0xf6, 0xe2, 0x69, 0x9e, 0x85, 0xa4,
	0x7d, 0x68, 0xfc, 0x18, 0x26, 0x22, 0x09, 0x35, 0x83, 0x8e, 0x12, 0x6b, 0x14, 0x4e, 0x74, 0x9d,
	0xaa, 0xbb, 0x44, 0x30, 0x53, 0x95, 0xe9, 0x98, 0xf7, 0x8e, 0x11, 0x68, 0x47, 0xa6, 0x63, 0xda,
	0xb7, 0x2d, 0x68, 0xb3, 0xc2, 0x0d, 0x3d, 0xaa, 0x30, 0x25, 0x54, 0xb2, 0x58, 0x26, 0x8f, 0xf5,
	0xf0, 0x02, 0x2b, 0x19, 0x15, 0xbc, 0x11, 0xac, 0xa0, 0x85, 0xd0, 0x63, 0x95, 0x89, 0x20, 0x8c,
	0x7e, 0x42, 0x36, 0xac, 0xe5, 0xf7, 0x95, 0x9a, 0x1d, 0x22, 0x6d, 0x2f, 0xfa, 0x09, 0x0e, 0x96,
	0xca, 0x88, 0x07, 0xbb, 0xc8, 0x83, 0xa5, 0x32, 0xa2, 0xc1, 0xae, 0x02, 0xa4, 0x99, 0x3c, 0x91,
	0xb1, 0x98, 0x88, 0x88, 0xac, 0x55, 0xd7, 0x77, 0x28, 0x74, 0x86, 0xe6, 0x47, 0xb1, 0xd4, 0xd3,
	0x20, 0x8c, 0x63, 0x13, 0x7c, 0x5c, 0x62, 0xb0, 0x6b, 0x2a, 0xf6, 0xe2, 0x98, 0x03, 0x8e, 0xb7,
	0x60, 0x0d, 0xfd, 0xa6, 0x4a, 0xe2, 0xd3, 0x20, 0x53, 0x2a, 0x3f, 0xd6, 0xd6, 0x56, 0x59, 0xb2,
	0x4f, 0x54, 0x82, 0xa1, 0x62, 0x3c, 0xcf, 0x64, 0x7e, 0x8a, 0xf2, 0x37, 0x50, 0xb3, 0x6f, 0x69,
	0x0f, 0xd3, 0xdc, 0xdb, 0x23, 0x28, 0x9b, 0x85, 0x13, 0x41, 0x1c, 0x6c, 0xb3, 0x76, 0x4c, 0x20,
	0x51, 0x1c, 0xbc, 0xdd, 0x43, 0xe6, 0x79, 0x98, 0xe6, 0x8c, 0xf0, 0x40, 0x17, 0x04, 0xef, 0x5b,
	0xd0, 0xca, 0x67, 0xe9, 0xb1, 0x1e, 0xbe, 0xe2, 0x22, 0x43, 0xa7, 0xf1, 0x23, 0xac, 0xe5, 0x76,
	0xcc, 0x89, 0x82, 0x9a, 0xe7, 0x9a, 0x05, 0xf5, 0x2a, 0x0b, 0x6a, 0x9e, 0x6b, 0x12, 0xd4, 0x6b,
	0xd0, 0xc7, 0xb0, 0x2f, 0x31, 0xb5, 0x57, 0xd8, 0xda, 0x30, 0x89, 0x18, 0x2e, 0x43, 0x57, 0x4f,
	0x67, 0x81, 0x96, 0x3f, 0x13, 0x64, 0xc7, 0x1a, 0x7e, 0x47, 0x4f, 0x67, 0x87, 0xf2, 0x67, 0xc2,
	0xfb, 0x08, 0x3a, 0xfa, 0x54, 0x8f, 0xf3, 0x58, 0x0f, 0x5f, 0xa3, 0xb9, 0x5c, 0x39, 0xbb, 0x10,
	0xae, 0x37, 0xa1, 0x8a, 0xe1, 0xa6, 0xc0, 0xd6, 0x78, 0xe1, 0x1d, 0x9e, 0x8e, 0x29, 0x92, 0x73,
	0x57, 0x89, 0x56, 0xb1, 0xa0, 0x11, 0x83, 0x29, 0x43, 0xb6, 0xd7, 0x77, 0x6a, 0xd7, 0x57, 0xfc,
	0x0d, 0x53, 0x85, 0x83, 0x7f, 0x9f, 0x81, 0xdb, 0x37, 0xc1, 0xab, 0xf0, 0xb3, 0xbd, 0x1d, 0x11,
	0xfb, 0xba, 0xc3, 0xfe, 0x23, 0xa4, 0x7b, 0xaf, 0x42, 0x4f, 0x6a, 0x15, 0xb3, 0xab, 0xbb, 0x46,
	0x23, 0x97, 0x04, 0xef, 0x1d, 0xe8, 0x65, 0x16, 0xad, 0x0e, 0xbf, 0xe6, 0x9a, 0xaa, 0x02, 0xc4,
	0xfa, 0x25, 0x87, 0xf7, 0x75, 0x68, 0xcf, 0xd0, 0x7d, 0xe8, 0xe1, 0x1b, 0xb4, 0xf8, 0x0d, 0xe6,
	0xe5, 0x78, 0xe2, 0x01, 0xd6, 0xf8, 0x86, 0x01, 0xc1, 0xb4, 0x4c, 0x64, 0x3e, 0x7c, 0x93, 0xd4,
	0x86, 0xbe, 0xb7, 0xbf, 0x0b, 0x6b, 0x0b, 0xbb, 0xfc, 0x42, 0xd1, 0xc7, 0xc7, 0x00, 0xe5, 0x3e,
	0xbf, 0x50, 0xcb, 0x9b, 0x30, 0x70, 0x77, 0xe5, 0x85, 0xc2, 0x84, 0xdb, 0xd0, 0x3f, 0x28, 0xed,
	0x2a, 0x5a, 0x2c, 0xb4, 0x12, 0x81, 0x4c, 0x4d, 0xf3, 0x36, 0x16, 0xf7, 0x53, 0xb4, 0x11, 0x54,
	0x81, 0xe7, 0xca, 0xf4, 0x42, 0x59, 0x09, 0x6c, 0x3c, 0xfa, 0xcf, 0x3a, 0x74, 0x8c, 0x99, 0xf6,
	0x76, 0xed, 0x50, 0x35, 0x37, 0x16, 0x34, 0xb5, 0xbb, 0x5f, 0x60, 0x95, 0xd1, 0x64, 0x62, 0xf3,
	0xf6, 0x60, 0x30, 0x63, 0x47, 0x19, 0xc8, 0xe4, 0x58, 0x99, 0xe8, 0xe8, 0x6a, 0xb5, 0x99, 0x71,
	0xa5, 0xfb, 0xc9, 0xb1, 0xe2, 0xc6, 0xfd, 0x59, 0x49, 0xd9, 0xbe, 0x0b, 0x83, 0x03, 0xd7, 0x37,
	0x7c, 0xb8, 0xe8, 0x4f, 0x6a, 0xee, 0x76, 0x3a, 0xac, 0x55, 0x9f, 0xb2, 0xfd, 0x19, 0x40, 0x39,
	0xbf, 0x25, 0x52, 0x7c, 0xcb, 0x95, 0xe2, 0xd2, 0xfe, 0x9c, 0x4d, 0xf9, 0x31, 0xac, 0x2f, 0xce,
	0x7a, 0x49, 0x97, 0xef, 0x55, 0xbb, 0xdc, 0xae, 0x2e, 0xdb, 0x5d, 0x95, 0xbb, 0x69, 0x9a, 0xc5,
	0x7d, 0x28, 0xf2, 0x73, 0xc4, 0x7d, 0x28, 0xf2, 0xb3, 0xe2, 0x46, 0x2d, 0x3b, 0x77, 0x8d, 0xcf,
	0xd6, 0x94, 0x5f, 0xd6, 0xa1, 0xef, 0x1c, 0x05, 0xf4, 0x3a, 0x74, 0x18, 0x02, 0x27, 0xd4, 0xed,
	0x11, 0xe5, 0x11, 0xc6, 0xbb, 0x5b, 0xd0, 0xe6, 0x73, 0x65, 0x7a, 0x32, 0x25, 0xa4, 0xe7, 0x61,
	0x36, 0x11, 0xb9, 0xc1, 0x2c, 0xa6, 0x84, 0x0a, 0x46, 0xb1, 0x0c, 0x5a, 0x5f, 0x03, 0x12, 0xba,
	0x48, 0x78, 0x98, 0xc4, 0xa7, 0xde, 0x0e, 0xf4, 0xf1, 0xe8, 0x4b, 0x9d, 0x8b, 0x64, 0x7c, 0x4a,
	0xf8, 0xa0, 0xe7, 0xbb, 0x24, 0xef, 0x03, 0x18, 0xe0, 0x76, 0x17, 0x5e, 0xb2, 0xed, 0x6e, 0x11,
	0xca, 0xd0, 0x38, 0x4b, 0xbf, 0x7f, 0x54, 0x16, 0x10, 0x45, 0x18, 0x47, 0x6f, 0xdb, 0x75, 0x5c,
	0x14, 0xc1, 0xcb, 0xb5, 0x2d, 0x0d, 0x26, 0xb0, 0x6d, 0x3f, 0x82, 0x15, 0xb2, 0xc5, 0x45, 0xd3,
	0xae, 0x9b, 0x43, 0xa2, 0xa3, 0x6c, 0x5b, 0x0e, 0x72, 0xa7, 0x34, 0x7a, 0x17, 0xfa, 0xce, 0x84,
	0x70, 0x6d, 0x69, 0xa6, 0xd2, 0x70, 0xc2, 0x46, 0x8c, 0x05, 0xe9, 0x92, 0x46, 0xbf, 0xaa, 0xc1,
	0x4a, 0x65, 0x2a, 0x78, 0x4c, 0x31, 0x80, 0x56, 0x29, 0xef, 0x5d, 0xd7, 0x6f, 0x27, 0xea, 0xb6,
	0x4a, 0x4f, 0xbd, 0x8f, 0x8a, 0x54, 0x0c, 0x9f, 0xa3, 0xd7, 0x96, 0x2c, 0x64, 0x69, 0x46, 0xe6,
	0x6d, 0x68, 0x1b, 0xac, 0xd3, 0x70, 0x97, 0xc1, 0x58, 0xc7, 0xa0, 0x3a, 0xc3, 0xf1, 0x32, 0x79,
	0x92, 0x5f, 0xd4, 0x60, 0xe0, 0xf6, 0xb9, 0x34, 0x2b, 0xf1, 0x09, 0x74, 0xac, 0x4c, 0x2b, 0xab,
	0x70, 0x1b, 0xee, 0x9a, 0xc5, 0x18, 0x3f, 0x64, 0xf8, 0xd1, 0x14, 0xba, 0x15, 0x2f, 0x34, 0xb7,
	0x3d, 0x18, 0xb8, 0xbb, 0x46, 0x59, 0x46, 0xf4, 0x40, 0x47, 0xa7, 0x79, 0x99, 0xde, 0x40, 0xca,
	0x2d, 0x24, 0xe0, 0xcc, 0xc9, 0xc1, 0xd6, 0xc9, 0x35, 0xd1, 0xf7, 0xe8, 0x26, 0x0c, 0x2a, 0x19,
	0x04, 0x0f, 0x9a, 0x88, 0xdf, 0xed, 0xea, 0xf0, 0x1b, 0x0f, 0x80, 0x49, 0x5b, 0x70, 0x9a, 0xc5,
	0x94, 0x46, 0x1f, 0xc3, 0x6a, 0x35, 0xd2, 0x5e, 0xda, 0xda, 0x83, 0x66, 0x16, 0xe6, 0x3c, 0x6a,
	0xd3, 0xa7, 0xef, 0xd1, 0x1d, 0x68, 0x73, 0x74, 0xb4, 0x54, 0x9a, 0x1e, 0x34, 0xa7, 0x61, 0x16,
	0x99, 0x24, 0x0c, 0x7d, 0x23, 0x4d, 0xab, 0xe3, 0xdc, 0x64, 0x5f, 0xe8, 0x7b, 0xf4, 0xcb, 0x1a,
	0xac, 0x7f, 0xce, 0xa8, 0x5c, 0x26, 0x16, 0xbd, 0x7f, 0x01, 0xeb, 0x22, 0x89, 0x28, 0x9b, 0xa8,
	0x2d, 0xe6, 0x67, 0x4b, 0xf3, 0x0d, 0xde, 0x93, 0xc5, 0x16, 0xbb, 0x9f, 0x5a, 0x76, 0x37, 0x9f,
	0xb5, 0x26, 0xaa, 0xd4, 0xed, 0x1f, 0xc3, 0xe6, 0x32, 0xc6, 0x25, 0xfb, 0xf5, 0xcd, 0xaa, 0x85,
	0xdc, 0xe2, 0x61, 0x6d, 0xe3, 0x43, 0x91, 0xe7, 0x8b, 0xd6, 0xf1, 0x1f, 0x9b, 0xb0, 0xbe, 0x58,
	0xef, 0x7d, 0x02, 0x7d, 0x99, 0x86, 0xb3, 0x72, 0x0d, 0xb5, 0xd2, 0x5a, 0x5a, 0xe6, 0xfd, 0x83,
	0xbd, 0x07, 0x46, 0xd5, 0x01, 0x99, 0xcb, 0x98, 0x89, 0xe1, 0x6c, 0xdd, 0x85, 0xb3, 0x43, 0xe8,
	0x84, 0xb1, 0x0c, 0xb5, 0xc0, 0xe0, 0x8b, 0x10, 0xbc, 0x29, 0xa2, 0xde, 0xd8, 0x88, 0x47, 0x46,
	0xc6, 0x94, 0xf5, 0x0c, 0x65, 0x9f, 0x32, 0xad, 0x56, 0x1a, 0x58, 0xcf, 0xb6, 0x0c, 0x2c, 0x69,
	0x9f, 0x2e, 0x09, 0x26, 0x61, 0x2e, 0x9e, 0x84, 0x1c, 0xd3, 0xf4, 0x7c, 0x5b, 0xc4, 0x9e, 0x65,
	0x5a, 0xe4, 0x68, 0x3b, 0x06, 0xee, 0xa4, 0x36, 0x45, 0x3b, 0x82, 0x15, 0x99, 0x06, 0x69, 0x26,
	0x8e, 0xe5, 0xd3, 0x20, 0x16, 0x09, 0x59, 0xa4, 0x96, 0xdf, 0x97, 0xe9, 0x01, 0xd1, 0xee, 0x8b,
	0x04, 0x11, 0xad, 0x4c, 0x4f, 0x3e, 0x0c, 0xec, 0x08, 0x3d, 0x36, 0x37, 0x48, 0xbb, 0x67, 0x46,
	0xd9, 0x85, 0x0b, 0x93, 0x58, 0x1d, 0x85, 0x71, 0x40, 0x9c, 0x76, 0x38, 0xe0, 0x10, 0x93, 0xab,
	0xf6, 0xd3, 0x93, 0x0f, 0xed, 0xb0, 0x37, 0x60, 0xcb, 0xe5, 0x77, 0xc6, 0xef, 0xd3, 0xf8, 0x17,
	0xca, 0x26, 0xe5, 0x3c, 0x16, 0xf2, 0xcd, 0x83, 0x33, 0xf9, 0xe6, 0x7b, 0xd0, 0x67, 0x73, 0x83,
	0xf6, 0x95, 0xa3, 0x9e, 0xfe, 0xfb, 0x6f, 0x2e, 0xdf, 0x7d, 0x63, 0x19, 0x1e, 0xa6, 0xb9, 0xb1,
	0x07, 0x10, 0x15, 0x04, 0x84, 0x65, 0x0b, 0xd5, 0x2f, 0x64, 0x15, 0x7e, 0x5e, 0x03, 0xef, 0xac,
	0x82, 0x18, 0x39, 0x7e, 0x50, 0x2c, 0xa0, 0x56, 0xc8, 0xf1, 0x03, 0xbb, 0x02, 0x2b, 0x6a, 0xcb,
	0x52, 0x2f, 0x45, 0x6d, 0x59, 0xbe, 0x06, 0xab, 0xa8, 0x4d, 0x41, 0xac, 0xc6, 0x24, 0x3e, 0xab,
	0x4b, 0x03, 0xa4, 0xde, 0x47, 0xe2, 0x7e, 0xaa, 0x47, 0x3f, 0x6f, 0xc0, 0x60, 0x7f, 0x16, 0x4e,
	0xc4, 0xe1, 0x7c, 0x36, 0x0b, 0xb3, 0x53, 0x8c, 0x85, 0x8a, 0xb0, 0xdc, 0x5a, 0x26, 0x87, 0x82,
	0x1a, 0x34, 0xce, 0x44, 0x98, 0x0b, 0x7b, 0xea, 0x6d, 0xd1, 0x5b, 0x85, 0xba, 0x8c, 0x8c, 0xe7,
	0xad, 0xcb, 0xc8, 0xfb, 0xb0, 0xf0, 0x17, 0x4d, 0x17, 0x77, 0xb9, 0xa3, 0x2d, 0x75, 0x17, 0xaf,
	0x40, 0x8f, 0xf3, 0xb3, 0xa5, 0x0a, 0x77, 0x99, 0xb0, 0x1f, 0xe1, 0xc2, 0x33, 0x91, 0xaa, 0x20,
	0x92, 0x13, 0x81, 0x11, 0x67, 0x9b, 0xa3, 0x26, 0xa4, 0xdd, 0x61, 0x12, 0x7b, 0xfb, 0x54, 0x05,
	0x79, 0x38, 0xe1, 0x74, 0x2a, 0x79, 0xfb, 0x54, 0x3d, 0x0a, 0x27, 0x7c, 0x3b, 0x30, 0x0d, 0x33,
	0x11, 0x71, 0x8c, 0xd2, 0xe5, 0xf5, 0x31, 0x89, 0xc2, 0x14, 0x34, 0x5f, 0x58, 0xd3, 0x33, 0xe6,
	0x0b, 0x69, 0x18, 0x8e, 0xcb, 0x2c, 0x9f, 0x87, 0x31, 0xb7, 0x02, 0xbe, 0x7d, 0x33, 0x34, 0x6c,
	0xf6, 0x32, 0x7e, 0xeb, 0xf7, 0x5a, 0x66, 0x0b, 0xf6, 0x13, 0x9d, 0x8a, 0x71, 0x6e, 0x04, 0x59,
	0x2b, 0x04, 0x59, 0x59, 0x50, 0x7d, 0x61, 0x41, 0x8b, 0x02, 0x69, 0x9c, 0x15, 0xc8, 0x16, 0xb4,
	0x2b, 0x09, 0x6f, 0x53, 0xa2, 0xad, 0x54, 0xb3, 0x19, 0x56, 0xb0, 0x98, 0x6d, 0xd1, 0xdd, 0x64,
	0x63, 0x26, 0xec, 0x26, 0xbf, 0x0a, 0xbd, 0x32, 0x8d, 0x64, 0xac, 0x44, 0x41, 0xf0, 0x3e, 0x82,
	0xf5, 0x32, 0xd9, 0x63, 0xcc, 0x21, 0x43, 0x97, 0x81, 0x7b, 0x6f, 0xe3, 0x64, 0x7e, 0x8c, 0xca,
	0xbf, 0x01, 0xab, 0x91, 0x1a, 0x3f, 0x16, 0x59, 0x70, 0x22, 0x32, 0x8d, 0x58, 0x85, 0x8d, 0xc7,
	0x0a, 0x53, 0xbf, 0x60, 0x22, 0xae, 0x24, 0x9c, 0xe7, 0x53, 0x95, 0x19, 0x8b, 0x61, 0x4a, 0xde,
	0xd7, 0x8a, 0x0b, 0x90, 0xfe, 0x92, 0xd1, 0x4c, 0x9d, 0x37, 0x82, 0x41, 0x98, 0x8d, 0xa7, 0x32,
	0x17, 0xe3, 0x7c, 0x9e, 0x09, 0x63, 0x18, 0x2a, 0x34, 0x94, 0xbd, 0xd2, 0x94, 0x1e, 0xee, 0xf9,
	0x75, 0x45, 0x06, 0x57, 0xe9, 0x62, 0x52, 0xab, 0xbc, 0x60, 0xa5, 0xed, 0x84, 0xac, 0xb6, 0xac,
	0x9d, 0xa3, 0x2d, 0xeb, 0x67, 0xb4, 0xc5, 0xfb, 0x18, 0x06, 0x93, 0x2c, 0x4c, 0xa7, 0x36, 0x07,
	0xb4, 0x41, 0xb3, 0xbe, 0xc8, 0xb3, 0xbe, 0x87, 0x35, 0x6c, 0x56, 0xee, 0x84, 0x79, 0xe8, 0xf7,
	0x27, 0x25, 0xc1, 0x7b, 0x03, 0x3a, 0x99, 0x52, 0x79, 0x70, 0xac, 0x29, 0x31, 0x52, 0x2c, 0xd5,
	0x57, 0x2a, 0xbf, 0x7b, 0xe8, 0xb7, 0xb1, 0xf2, 0xae, 0xf6, 0xde, 0x85, 0xee, 0x4c, 0xe4, 0x61,
	0x14, 0x9a, 0x8c, 0x6f, 0x01, 0x3b, 0x49, 0xd1, 0x1e, 0x98, 0x2a, 0xbf, 0x60, 0x1a, 0xfd, 0x0e,
	0xb4, 0xb9, 0x0b, 0xc4, 0x7f, 0xc7, 0xda, 0x05, 0xde, 0xed, 0x63, 0x6d, 0x51, 0x77, 0x1c, 0x9e,
	0xa2, 0x55, 0x60, 0x1d, 0x34, 0x25, 0x14, 0xd1, 0x51, 0xa8, 0x45, 0x40, 0x45, 0x73, 0xfe, 0x7b,
	0x48, 0xb9, 0x8f, 0x84, 0xd1, 0x0d, 0x58, 0xa9, 0x0c, 0x8a, 0xae, 0x24, 0x0e, 0x75, 0x8e, 0xea,
	0x4c, 0x77, 0x70, 0xd6, 0xbe, 0x21, 0xf1, 0x51, 0x38, 0x79, 0x24, 0x67, 0x62, 0xf4, 0x47, 0x35,
	0x58, 0x5b, 0x90, 0x83, 0x77, 0x03, 0x9a, 0xb4, 0x9e, 0x9a, 0x8b, 0xdb, 0x16, 0x98, 0x76, 0xf1,
	0x0f, 0x9b, 0x13, 0x62, 0x2e, 0x50, 0x4b, 0xbd, 0x44, 0x2d, 0xdb, 0x1f, 0x41, 0xaf, 0x60, 0x7b,
	0xa1, 0x93, 0x9a, 0x40, 0x13, 0xa3, 0x1f, 0x3a, 0xa0, 0x69, 0x71, 0x40, 0x53, 0xdc, 0xf1, 0x34,
	0x93, 0x27, 0x61, 0x2e, 0xca, 0x18, 0xb6, 0x85, 0x38, 0x9b, 0x68, 0xd4, 0xe4, 0x35, 0xe8, 0x53,
	0xa6, 0x68, 0xcc, 0x1c, 0x0d, 0xe2, 0x00, 0x26, 0x11, 0x83, 0xbd, 0xd7, 0x6b, 0x96, 0xf7, 0x7a,
	0xa3, 0x5f, 0xd7, 0x61, 0xcd, 0x80, 0xa0, 0x02, 0x6c, 0x3c, 0x80, 0x8b, 0x16, 0x01, 0x68, 0x43,
	0x0b, 0x50, 0xd8, 0x06, 0x76, 0x5c, 0xae, 0x40, 0x27, 0xdb, 0xea, 0x56, 0xa8, 0x85, 0x7f, 0x21,
	0x39, 0x4b, 0xf4, 0xbe, 0x80, 0x61, 0x24, 0x8e, 0xc3, 0x79, 0x9c, 0x07, 0x8b, 0xdd, 0x1a, 0x54,
	0xf4, 0xaa, 0xbd, 0x8c, 0x20, 0xae, 0x85, 0x8e, 0xfd, 0xad, 0x68, 0x29, 0xdd, 0xfb, 0x1e, 0x74,
	0x4d, 0x7f, 0x6c, 0x92, 0xfa, 0xef, 0x5f, 0x5b, 0x3a, 0x33, 0x5b, 0x36, 0x3e, 0xa0, 0x68, 0xb4,
	0x7d, 0x08, 0x2b, 0x95, 0xaa, 0xdf, 0x08, 0x7c, 0xfb, 0xeb, 0x1a, 0x6c, 0x19, 0xd7, 0xb3, 0x38,
	0xe1, 0xbb, 0xce, 0x84, 0x59, 0xc3, 0xde, 0xe6, 0xfe, 0x96, 0xf3, 0xff, 0xef, 0xce, 0xfb, 0x3b,
	0xd0, 0xb1, 0x6e, 0xdd, 0x83, 0x26, 0x3a, 0x7d, 0x0b, 0xc3, 0xf1, 0x9b, 0xae, 0x3d, 0x4a, 0x64,
	0xc4, 0xda, 0xd7, 0x4b, 0x2d, 0x1e, 0x1a, 0xfd, 0x4d, 0x03, 0x2e, 0x2c, 0x51, 0x08, 0x3c, 0xd0,
	0x47, 0x99, 0x8c, 0x26, 0xc5, 0x41, 0xe7, 0x12, 0x05, 0x27, 0x61, 0x12, 0x1d, 0xa9, 0xa7, 0xe8,
	0x81, 0xf9, 0x14, 0xf4, 0x0c, 0x85, 0x5d, 0xf0, 0x34, 0x94, 0x59, 0x2a, 0x13, 0xce, 0x02, 0x36,
	0xf8, 0xa1, 0x82, 0xa1, 0x51, 0x1a, 0xf0, 0xdb, 0x70, 0xa9, 0x82, 0x3d, 0x1c, 0xa4, 0xc2, 0xfa,
	0xbd, 0xe9, 0x80, 0x90, 0x12, 0xb2, 0xdc, 0x84, 0xed, 0xc5, 0x66, 0xce, 0xba, 0xf8, 0x26, 0x76,
	0xab, 0xd2, 0xb2, 0x04, 0x7d, 0xd7, 0xa0, 0xc5, 0x79, 0xd9, 0xf6, 0xb2, 0x04, 0x3f, 0xd7, 0x91,
	0xf7, 0x37, 0x2b, 0xc3, 0x3d, 0xe9, 0x98, 0xb7, 0x01, 0x4c, 0xfa, 0x4c, 0x9c, 0x7a, 0xb7, 0x61,
	0x8b, 0x1f, 0xe2, 0x84, 0xd9, 0x69, 0x50, 0xe2, 0x61, 0x61, 0x6f, 0x53, 0x4d, 0xb7, 0x66, 0xc2,
	0xfe, 0x66, 0xc1, 0xbc, 0x6f, 0x91, 0xb2, 0x40, 0x78, 0x39, 0x74, 0x3b, 0x29, 0x17, 0x2f, 0xec,
	0x4d, 0xea, 0x42, 0x37, 0x5b, 0x4e, 0x37, 0x85, 0x34, 0x84, 0x1e, 0xfd, 0x43, 0x1d, 0xb6, 0x96,
	0x9f, 0xbb, 0x45, 0xa4, 0x5f, 0x3b, 0x0f, 0xe9, 0xd7, 0xab, 0x48, 0xff, 0x19, 0x18, 0xbc, 0xf1,
	0xe2, 0x18, 0xbc, 0xf9, 0x6c, 0x0c, 0x5e, 0x0d, 0x27, 0x5a, 0xcf, 0x0d, 0x27, 0xda, 0xcf, 0x0f,
	0x27, 0x3a, 0x67, 0xc3, 0x89, 0x05, 0xa4, 0xdf, 0x5d, 0x44, 0xfa, 0xa3, 0xbf, 0xab, 0x01, 0x50,
	0x4a, 0xe9, 0x80, 0x1e, 0xad, 0x2c, 0x8b, 0x61, 0x9f, 0x95, 0x4c, 0xda, 0x81, 0x7e, 0x24, 0x74,
	0x2e, 0x13, 0xce, 0x9d, 0xb0, 0x78, 0x5c, 0x12, 0xb6, 0x34, 0xfe, 0xdb, 0xe0, 0x2a, 0x2e, 0x15,
	0xd1, 0x3b, 0xaf, 0x9a, 0xbe, 0xd1, 0x65, 0x64, 0x4f, 0xcc, 0xab, 0xa6, 0x7a, 0xf6, 0x64, 0x31,
	0x33, 0xd3, 0x39, 0x9b, 0x99, 0xf9, 0xaf, 0x26, 0xf4, 0xca, 0xab, 0xb9, 0x45, 0x4c, 0xb8, 0x09,
	0x2d, 0x9c, 0x7d, 0x11, 0x38, 0x52, 0xa1, 0x7c, 0x20, 0xd4, 0x70, 0x1f, 0x08, 0x5d, 0x86, 0x2e,
	0x7d, 0x94, 0x21, 0x63, 0x87, 0xca, 0xac, 0x25, 0x88, 0xf9, 0xc2, 0x24, 0x72, 0x21, 0x60, 0x98,
	0x44, 0x8b, 0x10, 0xd0, 0xc1, 0xf9, 0x3b, 0xd0, 0x3a, 0x30, 0xcf, 0xaf, 0x50, 0x97, 0xa1, 0x3c,
	0x69, 0xf6, 0x98, 0x5d, 0x82, 0x0e, 0x65, 0x37, 0xb2, 0x27, 0x06, 0x60, 0xb7, 0xb1, 0xe8, 0xe3,
	0xaa, 0x07, 0x5c, 0x61, 0x20, 0x4c, 0xcf, 0xc0, 0x6f, 0xac, 0x65, 0xe0, 0x72, 0xa3, 0x08, 0x1a,
	0xc0, 0xbd, 0xb0, 0x28, 0x04, 0xb1, 0x34, 0x62, 0xd8, 0x84, 0x96, 0xce, 0xc3, 0x5c, 0x10, 0xfa,
	0xeb, 0xf9, 0x5c, 0xa0, 0x8d, 0xcd, 0xc3, 0x7c, 0x6e, 0x23, 0x40, 0x53, 0xf2, 0xfe, 0x3f, 0xf4,
	0x29, 0xdd, 0x6c, 0x10, 0xe3, 0x8a, 0x9b, 0x1d, 0x2d, 0xc7, 0x29, 0xaf, 0x25, 0x7c, 0x98, 0x96,
	0x97, 0x9c, 0xf7, 0xca, 0x67, 0x4f, 0x85, 0x9f, 0x5c, 0x75, 0xfd, 0xe4, 0x72, 0x77, 0x51, 0x3c,
	0x8a, 0x2a, 0x0e, 0xf0, 0xf5, 0xe2, 0x42, 0x60, 0x8d, 0x16, 0xba, 0xce, 0xcd, 0x4b, 0x65, 0xb5,
	0xf7, 0x01, 0xdb, 0xef, 0x56, 0x6e, 0x59, 0x17, 0xef, 0x3c, 0x6b, 0x67, 0xee, 0x3c, 0x5f, 0x26,
	0x16, 0xf9, 0xcb, 0x3a, 0xac, 0x16, 0x32, 0x38, 0x5c, 0x10, 0x63, 0xad, 0x22, 0x46, 0xbe, 0x96,
	0x49, 0x64, 0x32, 0xa1, 0x6e, 0xba, 0xbe, 0x2d, 0x72, 0xbc, 0x31, 0xd7, 0x22, 0x32, 0xae, 0xc1,
	0x94, 0x30, 0xb4, 0x34, 0x97, 0xa5, 0xd8, 0x88, 0x9f, 0x0a, 0x3a, 0x14, 0xc2, 0xda, 0xe6, 0x9e,
	0x5f, 0x44, 0xe6, 0x99, 0x60, 0xcf, 0xdc, 0xf0, 0x0b, 0x4a, 0x2c, 0x45, 0x22, 0x8c, 0xcc, 0x21,
	0xa2, 0x6f, 0x5c, 0x5b, 0x2a, 0x23, 0x3a, 0x3e, 0x2d, 0x1f, 0x3f, 0x31, 0x58, 0x12, 0x4f, 0x25,
	0xee, 0x6e, 0x24, 0x4c, 0x92, 0xa2, 0x8b, 0x84, 0xdb, 0x78, 0x0a, 0x37, 0xa1, 0x25, 0xb2, 0x4c,
	0x65, 0x26, 0xba, 0xe0, 0x02, 0x3f, 0xf9, 0x0b, 0xb3, 0x5c, 0x44, 0x41, 0x98, 0x9b, 0xc8, 0xa2,
	0x67, 0x28, 0x7b, 0x04, 0xdd, 0x8e, 0x65, 0x22, 0xf5, 0x94, 0xeb, 0x59, 0xc7, 0xc0, 0x92, 0xf6,
	0xf2, 0xd1, 0xef, 0xd7, 0x61, 0xa5, 0x10, 0xda, 0xe7, 0xe6, 0xb4, 0x57, 0x4e, 0x6b, 0xd5, 0x1a,
	0xd6, 0x17, 0xad, 0xa1, 0xf5, 0xe9, 0x0d, 0xc7, 0xa7, 0x5b, 0x53, 0xd5, 0xac, 0xa6, 0xdb, 0xe8,
	0x8d, 0x09, 0x7b, 0x42, 0xfa, 0x76, 0x5e, 0x42, 0xb1, 0x09, 0xb5, 0x2f, 0xa1, 0xca, 0x6c, 0x6d,
	0xc7, 0xc5, 0xcb, 0x95, 0x79, 0x2e, 0x3b, 0x4c, 0x2f, 0xa3, 0x3d, 0xff, 0xda, 0x82, 0x8d, 0x62,
	0x80, 0x1f, 0x1c, 0x3e, 0xfc, 0x9c, 0x60, 0xc6, 0xa2, 0x30, 0x16, 0x32, 0x08, 0x4e, 0x70, 0x69,
	0x93, 0x92, 0x8d, 0x6a, 0x52, 0x32, 0xcc, 0x26, 0x9c, 0x43, 0x40, 0xd9, 0x64, 0x13, 0xed, 0xbd,
	0x6d, 0xcf, 0x3b, 0x5f, 0xe6, 0x6f, 0x2e, 0x2c, 0x8d, 0xf4, 0xd6, 0x5a, 0x81, 0xc2, 0x24, 0xb6,
	0x5d, 0x93, 0x78, 0x1d, 0xd6, 0x33, 0xa1, 0x55, 0x7c, 0x42, 0x56, 0x20, 0xa0, 0x51, 0xd9, 0x06,
	0xaf, 0x32, 0x1d, 0x4f, 0xdb, 0x01, 0x8e, 0x7f, 0x0d, 0x56, 0xec, 0x0b, 0x59, 0x66, 0x33, 0xf7,
	0xf5, 0x96, 0x48, 0x4c, 0x57, 0x80, 0x6c, 0x84, 0x66, 0x0e, 0x56, 0x2e, 0xba, 0xd3, 0xd2, 0x54,
	0x7d, 0x19, 0xba, 0xb1, 0x9a, 0x70, 0x25, 0xab, 0x57, 0x27, 0x56, 0x13, 0xaa, 0x7a, 0x0b, 0x9a,
	0x09, 0x6a, 0x6a, 0xdf, 0x0d, 0xd2, 0x2a, 0x9b, 0xe4, 0x13, 0x43, 0xa1, 0x0f, 0x03, 0x47, 0x1f,
	0xae, 0x81, 0x7d, 0x7d, 0x60, 0xde, 0xaa, 0xac, 0x90, 0x0a, 0x0c, 0x0c, 0x91, 0xdf, 0xab, 0x94,
	0x5e, 0x6a, 0xb5, 0xe2, 0xa5, 0xd0, 0x77, 0xd2, 0x1d, 0x0b, 0xed, 0xbb, 0x7d, 0xb7, 0x44, 0x24,
	0xda, 0x7f, 0xec, 0x3d, 0xcd, 0xd4, 0x58, 0x68, 0x6d, 0x58, 0xf8, 0xe5, 0xd2, 0xc0, 0x10, 0x99,
	0xe9, 0x6d, 0xd8, 0x08, 0xd3, 0x34, 0x08, 0xb3, 0x99, 0xca, 0x82, 0x34, 0x53, 0xf4, 0xbc, 0x83,
	0xef, 0xf2, 0xd7, 0xc2, 0x34, 0xdd, 0x43, 0xfa, 0x01, 0x93, 0x51, 0x0c, 0xe2, 0xa9, 0x18, 0x07,
	0x32, 0xb2, 0xaf, 0x95, 0x3a, 0x58, 0xde, 0x8f, 0xb4, 0xf7, 0xad, 0xaa, 0x4d, 0xe6, 0x90, 0x75,
	0x7d, 0xf1, 0x82, 0xb8, 0x62, 0x89, 0x17, 0x63, 0xe8, 0xcd, 0xaf, 0x1c, 0x43, 0x3b, 0xee, 0xe9,
	0xe2, 0xb9, 0xee, 0x69, 0x6b, 0xd1, 0x3d, 0x8d, 0xfe, 0xa3, 0xe6, 0x1c, 0x75, 0xd4, 0x70, 0xef,
	0x1e, 0xdd, 0x41, 0x9b, 0x94, 0xc7, 0x4f, 0xb4, 0x4a, 0xdc, 0x68, 0xec, 0xd2, 0xc2, 0x7e, 0xda,
	0x33, 0xe1, 0x97, 0x6f, 0x62, 0x7e, 0xa0, 0x55, 0x42, 0xc7, 0xa4, 0x74, 0x08, 0xf5, 0xf3, 0x1d,
	0x82, 0x93, 0xed, 0x68, 0x9c, 0x93, 0xed, 0xf8, 0xad, 0x25, 0x9e, 0xaa, 0xe9, 0xca, 0xe8, 0x79,
	0x2e, 0x6a, 0xf4, 0xeb, 0x66, 0x11, 0x7e, 0xda, 0x3b, 0xed, 0xa5, 0x08, 0x8a, 0x0f, 0x78, 0xdd,
	0xc5, 0x26, 0x7a, 0xac, 0xd2, 0x02, 0x85, 0x50, 0xe1, 0x99, 0x68, 0x89, 0x90, 0x6c, 0x78, 0x14,
	0x0b, 0x82, 0x97, 0xc6, 0xec, 0x03, 0x93, 0x10, 0x53, 0x7a, 0x57, 0xa1, 0x29, 0xd3, 0x70, 0x66,
	0x80, 0xbd, 0x81, 0x1b, 0xfb, 0x07, 0x7b, 0x0f, 0x7c, 0xa2, 0x7b, 0xdb, 0xd0, 0xa5, 0x77, 0xf5,
	0x49, 0x18, 0x9b, 0xf7, 0x36, 0x45, 0xd9, 0xfb, 0xb4, 0x92, 0xcd, 0x64, 0x0c, 0xff, 0x46, 0x65,
	0xf9, 0x76, 0x65, 0xe5, 0x26, 0xd9, 0x3c, 0xaf, 0x93, 0xf4, 0xfc, 0x4e, 0x79, 0x6b, 0xc4, 0x00,
	0x7e, 0xb4, 0xbc, 0x8f, 0xa5, 0x17, 0x47, 0xde, 0x27, 0x0b, 0x98, 0xe6, 0xf5, 0xe5, 0x8d, 0x97,
	0x19, 0xe3, 0x1f, 0xc2, 0xda, 0xc2, 0xbc, 0x5e, 0x38, 0x9e, 0xb4, 0xfd, 0x2f, 0xdc, 0xea, 0xff,
	0x4f, 0xaf, 0xb2, 0x5e, 0xc6, 0x3f, 0xfc, 0x79, 0xad, 0xbc, 0x3d, 0x39, 0x57, 0xa3, 0x16, 0xa2,
	0x9b, 0xfa, 0x99, 0xe8, 0x66, 0x01, 0xf8, 0x37, 0xce, 0xa4, 0xf8, 0x17, 0x73, 0xe8, 0xcd, 0xe7,
	0xe7, 0xd0, 0x5b, 0x67, 0x72, 0xe8, 0xa3, 0x5f, 0x34, 0x8a, 0x68, 0xfe, 0x36, 0xf9, 0x28, 0xef,
	0x2d, 0x58, 0xa3, 0xe7, 0xfa, 0x41, 0x34, 0x4f, 0x63, 0x39, 0x46, 0x27, 0xc4, 0xb7, 0xa4, 0xab,
	0x44, 0xbe, 0x63, 0xa9, 0x8e, 0xba, 0xd7, 0xcf, 0x53, 0xf7, 0xc6, 0x33, 0xd5, 0xbd, 0xf9, 0x15,
	0xd4, 0xbd, 0xb5, 0xa0, 0xee, 0x37, 0x4b, 0x3d, 0x6d, 0xbb, 0x8f, 0x85, 0x2a, 0x6b, 0x78, 0x86,
	0x96, 0x3e, 0x03, 0x30, 0x54, 0x9b, 0x2e, 0xd3, 0xd1, 0xff, 0x23, 0x65, 0x3a, 0x86, 0xcd, 0xca,
	0xdc, 0x7c, 0xf1, 0xd3, 0xb9, 0xd0, 0xb9, 0x77, 0x13, 0x56, 0xad, 0xdd, 0x63, 0x5c, 0x61, 0x6c,
	0xf1, 0x85, 0x25, 0xeb, 0xf1, 0x57, 0x92, 0xca, 0xee, 0x7a, 0xd0, 0xfc, 0x7c, 0x21, 0x5b, 0x38,
	0xda, 0x83, 0x8b, 0x0b, 0xe3, 0xe8, 0x54, 0x25, 0xcb, 0x71, 0xcd, 0x93, 0x30, 0x2b, 0x00, 0x71,
	0xcf, 0xb7, 0xc5, 0x91, 0x82, 0x55, 0xdb, 0x85, 0x4a, 0x12, 0x31, 0xce, 0xab, 0x69, 0xf4, 0xda,
	0x62, 0x1a, 0xfd, 0x7b, 0x50, 0x5c, 0x6a, 0x06, 0xc5, 0xc3, 0xfe, 0xf3, 0x52, 0x45, 0xab, 0x96,
	0x9d, 0x7d, 0xc0, 0xe8, 0x1e, 0x6c, 0x7c, 0x5e, 0xfc, 0x08, 0x63, 0xfc, 0x95, 0xc6, 0xdc, 0x84,
	0xd6, 0xb1, 0xb2, 0x51, 0x70, 0xd7, 0xe7, 0xc2, 0xe8, 0x6f, 0x6b, 0xd0, 0x44, 0xdd, 0x73, 0xd4,
	0xb9, 0x56, 0x51, 0xe7, 0x6f, 0x2d, 0xde, 0xa7, 0x5f, 0x2a, 0x15, 0xf6, 0x19, 0x8a, 0x76, 0xdd,
	0x71, 0x5f, 0x8e, 0xa3, 0x73, 0x6e, 0x48, 0xed, 0x4f, 0x14, 0x5e, 0xe6, 0xc6, 0xfd, 0x5f, 0x6a,
	0x00, 0xce, 0x9d, 0x1a, 0x46, 0x31, 0xf3, 0xa3, 0x44, 0xe4, 0x45, 0x14, 0x43, 0x25, 0x7e, 0x82,
	0x18, 0x64, 0x61, 0x32, 0xb1, 0x7d, 0x74, 0x64, 0xea, 0x63, 0xd1, 0xcd, 0xa0, 0x34, 0xaa, 0x19,
	0x94, 0x3d, 0xe8, 0x87, 0xf3, 0xa7, 0x8e, 0x6d, 0x71, 0x8e, 0x5a, 0x39, 0xe6, 0xee, 0xde, 0xfc,
	0xa9, 0x31, 0x24, 0xc6, 0xa3, 0x84, 0x05, 0x61, 0xfb, 0xbb, 0xb0, 0xb6, 0x50, 0xfd, 0x42, 0xab,
	0xfb, 0x8b, 0x3a, 0xb4, 0x28, 0xab, 0xbe, 0xec, 0xb2, 0xa8, 0xbc, 0x3d, 0xab, 0x2f, 0xdc, 0x9e,
	0x55, 0x6e, 0x92, 0x1a, 0xcf, 0xb9, 0x49, 0x6a, 0x9e, 0xbd, 0x49, 0x72, 0xa0, 0x7b, 0xab, 0x9a,
	0x14, 0xb0, 0x17, 0x21, 0xed, 0x73, 0x2e, 0x42, 0x3a, 0x67, 0x2f, 0x42, 0xde, 0x2d, 0x8c, 0x4e,
	0xb7, 0xa2, 0x3d, 0xb8, 0xb4, 0xdf, 0x74, 0x74, 0x92, 0xc0, 0x3a, 0xf5, 0x7b, 0x5f, 0xea, 0xdc,
	0x79, 0x87, 0x31, 0x0b, 0xf3, 0xf1, 0x34, 0x70, 0x5c, 0x50, 0x8f, 0x28, 0x68, 0x07, 0xb0, 0xfb,
	0x30, 0x8e, 0xcd, 0x91, 0xc0, 0x4f, 0xef, 0xeb, 0xd0, 0x3e, 0x96, 0x71, 0x5e, 0xbc, 0x65, 0x31,
	0xaf, 0x80, 0xee, 0x12, 0x4d, 0xef, 0x65, 0x13, 0xed, 0x1b, 0x86, 0xd1, 0x3f, 0xd7, 0x60, 0xb3,
	0x70, 0xde, 0xee, 0xa0, 0x9b, 0xd0, 0xfa, 0xe9, 0x5c, 0x1a, 0x55, 0xec, 0xfa, 0x5c, 0x28, 0x24,
	0xc8, 0x83, 0xb1, 0x04, 0xcd, 0xf8, 0x8d, 0x72, 0x7c, 0xba, 0x84, 0xa1, 0x9f, 0x1c, 0x72, 0xfc,
	0x6c, 0x4a, 0x84, 0xb9, 0x64, 0x32, 0xb6, 0x49, 0x27, 0x2e, 0x50, 0x86, 0x57, 0x1c, 0xab, 0xcc,
	0x46, 0x3f, 0xa6, 0xc4, 0xcf, 0x0e, 0x66, 0x32, 0x37, 0x81, 0x33, 0x17, 0x9c, 0xb5, 0x75, 0x9f,
	0xb7, 0xb6, 0x3f, 0xae, 0x43, 0xdf, 0xa1, 0x7b, 0xdf, 0xc6, 0xa6, 0x22, 0x8e, 0x6c, 0xee, 0xfc,
	0xca, 0x99, 0xa6, 0xbb, 0x77, 0xa9, 0xde, 0xec, 0x26, 0x33, 0x6f, 0xff, 0x2e, 0xb4, 0xe8, 0xc5,
	0x98, 0xf7, 0x71, 0xf5, 0xa9, 0xd9, 0xe8, 0x6c, 0x73, 0xe2, 0x7b, 0xd9, 0x47, 0x67, 0x5d, 0xd7,
	0xf7, 0xf8, 0xb8, 0x84, 0x62, 0x4e, 0x4b, 0x9a, 0xbe, 0x53, 0xc5, 0x55, 0x97, 0x9e, 0x31, 0x29,
	0xa7, 0xcf, 0x5b, 0xeb, 0xbf, 0xfa, 0xf2, 0x6a, 0xed, 0x9f, 0xbe, 0xbc, 0x5a, 0xfb, 0xb7, 0x2f,
	0xaf, 0xd6, 0xfe, 0xe4, 0xdf, 0xaf, 0xfe, 0xbf, 0xa3, 0x36, 0xfd, 0x7e, 0xf4, 0xc6, 0x7f, 0x07,
	0x00, 0x00, 0xff, 0xff, 0xde, 0x1a, 0x56, 0x71, 0x54, 0x3a, 0x00, 0x00,
}
